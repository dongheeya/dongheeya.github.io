<h1>람다를 이용한 도메인 전용 언어</h1>

개발자들은 보통 프로그래밍 언어도 결국 언어라는 사실을 잊곤 한다.<BR/>
언어의 주요 목적은 메세지를 명확하고, 안정적인 방식으로 전달하는 것.<BR/>

애플리케이션의 핵심 비즈니스를 모델링하는 소프트웨어 영역에서 읽기 쉽고 이해하기 쉬운 코드는 특히 중요하다.<BR/>
개발팀과 도메인 전문가가 공유하고 이해할 수 잇는 코드는 생선성과 직결되기 때문이다.<BR/>
결과적으로 버그와 오해를 미리 방지할 수 있다.<BR/>

DSL(도메인 전용 언어)로 애플리케이션의 비즈니스 로직을 표현하여 이 문제를 해결할 수 있다.<BR/>
DSL은 범용이 아닌 특정 도메일을 대상으로 만들어진 특수 프로그래밍 언어이다.<BR/>
DSL은 도메일의 많은 특성 용어를 사용한다.<BR/>
자바는 역사적으로 완고함, 장황함 등의 특성 때문에 기술 배경이 없는 사람들이 사용하기에는 부적적한 용어로 간주되었음.<BR/>
자바가 람다 표현식을 지원하면서 달라지고 있다.<BR/>
코드를 간결하게 만들수도 잇고, 프로그램의 신호 대비 잡음을 줄일 수 있다.<BR/>

DSL은 외부/내부적 DSL로 나눠진다.<BR/>
외부적 DSL로 데이터베이스가 텍스트로 구현된 SQL표현식을 파싱하고 평가하는 API를 제공하는 것이 일반적이다.
내부적 DSL에서는 SQL의 SELECT FROM 구문처럼 애플리케이션 수준의 기본값이 자바 메서드가 사용할 수 있도록 데이터베이스를 대표하는 한 개
이상의 클래스 형식으로 노출된다.<BR/>
내부적 DSL에서는 적절한 클래스와 메서드를 노출하는 과정이 필요하다.

<h2>10.1 도메인 전용 언어</h2>
- DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어다.<BR/>
- 자바에서는 도메인을 표현하는 클래스와 메서드 집합이 필요하다.<BR/>
- DSL이란 특정 비즈니스 도메인을 인터페이스로 만든 API로 생각할 수 있다.<BR/>
- 동작과 용어는 특정 도메인에 국한되므로 다른 문제는 걱정할 필요가 없고, 자신의 앞에 놓인 문제를 어떻게 해결할지에만 집중할 수 있다.<BR/>

[DSL를 개발할때 고민해보아야하는 점]<BR/>
1) 의사 소통의 왕 : 우리의 코드의 의모가 명확히 전달되어야 하며 프로그래머가 아닌 사람도 이해할 수 있어야한다.<BR/>
2) 한번 코드를 구현하지만 여러번 읽는다 : 가독성은 유지보수의 핵심으로 동료가 이해할 수 있도록 구현해야한다.<BR/>

<h2>10.1.1 DSL의 장점과 단점</h2><BR/>

[DSL의 장점]<BR/>
1) 간결함 :API는 비즈니스 로직을 간펴하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들수 있다.<BR/>
2) 가독성 : 비 도메인 전문가도 코드를 쉽게 이해할 수 있다.<BR/>
3) 유지보수 : 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수하고 바꿀 수 있다<BR/>
4) 높은 수준의 추상화 : DSL은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨긴다.<BR/>
5) 집중 : 결과적으로 생산성이 좋아진다<BR/>
6) 관심사 분리 : 애플리케이션의 인프라구조와 관련된 문제와 독립적으로 비즈니스 관련된 코드에서 집중하기가 용이하다.<BR/>


[DSL의 단점] <BR/>
1) DSL 설계의 어려움 : 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다<BR/>
2) 개발 비용 : DSL유지보수와 변경은 프로젝트에 부담을 주는 요소이다.<BR/>
3) 추가 우회 계층 : DSL은 계층을 최대한 작게 만들어 성능 문제를 회피한다.<BR/>
4) 한 프로젝트에도 여러가지 언어를 사용하는 추세인데, DSL까지 추가되면 더 많은 언어를 배워야한다는 부담이 있다.<BR/>
5) 호스팅 언어 한계 : 일부 자바 같은 범용 프로그래밍 언어는 장황하고 엄격한 문법을 가졋다. 이런 언어로는 자연친화적인 DSL을 만들기가 힘들다.<BR/>

<h2>10.1.2 JVM에서 이용할 수 잇는 다른 DSL 해결책</h2>
DSL의 카테고리를 구분하는 가장 흔한 방법은 내부 DSL과 외부 DSL로 나누는 것이다.<BR/>
내부 DSL은 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현하는 반면,<BR/>
외부 DSL은 호스팅 언어와는 독립적으로 자체의 문법을 가진다.<BR/>

<b>내부 DSL</b>
- 내부 DSL 이란 자바로 구현한 DSL을 의미한다.<BR/>

```
List<String> numbers = Arrays.asList("one","two","three");
numbers.forEach(new Comsumer<String>(){
  @Override
  public void accept(String s){
    System.out.println(s);
  }
});

```

다음처럼 익명 내부 클래스를 람다 표현식으로 바꿀 수 있다.
```
numbers.forEach( s-> System.out.println(s));
```

순수 자바로 DSL을 구현함으로 다음과 같은 장점을 얻을 수 있다.
1) 기존 자바 언어를 이용하면 외부 DSL에 비해 새로운 패턴과 기술을 배워 DSL을 구현하는 노력이 현저하게 줄어든다.
2) 순수 자바로 DSL을 구현하면 나머지 코드와 함께 DSL을 컴파일러 할 수 있다.
3) 익숙하지 않고 복잡한 외부 도구를 배울 필요가 없다.
4) 기존의 자바 IDE를 이용해 자동완성, 자동 리팩토링 같은 기능을 그대로 즐길 수 있다.

<B>다중 DSL</B><BR/>
다중 DSL : 자바가 아니지만 JVM에서 실행됨(스칼라, 그루비 등)<BR/><BR/>

[장점]<BR/>
JVM에서 실행되는 언어 중에 문법이 간편하고 제약이 적은 언어가 많다.<BR/>
Scala에서 내장DSL로 3번 Hello World를 출력하는 프로그램 구현<BR/>
문법적 잡음이 없음을 확인<BR/>

```
//  주어진 함수 f를 주어진 횟수만큼 반복 실행하는 유틸리티 함수 구현
def times(i: Int, f: => Unit): Unit = { f
if (i > 1) timesStandard(i - 1, f)
}
times(3, pringln("Hello World"))
```
[단점]<BR/>
1) 새로운 프로그래밍 언어를 배워야만 한다.<BR/>
2) 두 개 이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.<BR/>
3)JVM에서 실행되는 거의 모든 언어가 자바와 100% 호환을 주장하고 있지만 완벽하지 않을 때가 많다.<BR/>
4) 스칼라와 자바 컬렉션은 호환되지 않으므로 상호 컬렉션을 전달하려면 기존 컬렉션을 대상 언어의 API에 맞게 변환해야 한다.<BR/>


<B>외부 DSL</B><BR/>
자신만의 문법과 구문으로 새 언어를 설계해야 한다.<BR/>
새 언어를 파싱하고, 파서의 결과를 분석하고, 외부 DSL을 실행할 코드를 만들어야 한다.<BR/>
무한한 유연성 장점이다.<BR/>
우리에게 필요한 특성을 완벽하게 제공하는 언어를 설계할 수 있다는 것이 장점이다.<BR/>

<h2>10.2 최신 자바 API의 작은 DSL</h2>
- 자바의 새로운 기능의 장점을 적용한 첫 API는 네이티브 자바 API 자신이다.
- 람다 표현식과 메소드 참조를 이용해 DSL의 가독성, 재사용성, 결합성이 높아졌다.

<h3>10.2.1 스트림 API는 컬렉션을 조작하는 DSL</h3>
Stream 인터페이스는 네이티브 자바 API에 작은 내부 DSL을 적용한 좋은 예다.<BR/>
Stream은 컬렉션의 항목을 필터, 정렬, 변환, 그룹화, 조작하는 작지만 강력한 DSL로 볼 수 있다.<BR/>

ex) 로그 파일을 읽어서 "ERROR"라는 단어로 시작하는 파일의 첫 40행을 수집하는 작업을 수행한다고 가정하자.<BR/>
```
List<String> errors = new ArrayList<>();
int errorCount = 0;
BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
String line = buferedReader.readLine();
while(errorcount < 40 && line != null){
  if(line.startWith("ERROR")){
    errors.add(line);
    errorCount++;
  }
  line = bufferedReader.readLine();
}
```
다음을 더 간단하게 보여준다면 다음과 같다.<BR/>
```
List<String> errors = Files.line(Paths.get(fileName))   ☜ 파일을 열어서 문자열 스트림을 만듦
                          .fileter(line -> line.startsWith("ERROR")) ☜ ERROR로 시작하는 행을 필터링
                          .limit(40) ☜ 결과를 첫 40행으로 제한
                          .collect(toList()); ☜ 결과 문자열을 리스트로 수집
```
String은 파일에서 파싱할 행을 의미하며 Files.lines는 정적 유틸리티 메서드로 Stream<String>을 반환한다.<BR/>
파일을 한행 씩 반환하는 코드는 이게 전부이다. 에러행을 첫 40개만 수집한다.<BR/>
  
스트림 API의 플루언트 형식은 잘 설계된 DSL의 또 다른 특징이다.<BR/>
모든 중간 연산은 게으르며 다른 연산으로 파이프라인될 수 있는 스트림으로 반환한다.<BR/>
최종 연산은 적극적이며 전체 파이프라인이 계산을 일으킨다.<BR/>
  

<h3>10.2.2 데이터를 수집하는 DSL인 Collectors</h3>
Stream  인터페이스를 데이터 리스트를 조작하는 DSL로 간주할 수 있음을 확인했다.<br/>
DSL관점에서 스트림 항목을 수집, 그룹화, 파이션을 이용하여 메서드가 설계되었는지 확인한다.<br/>
Comparator 인터페이스는 다중 필드 정렬을 지원하도록 합쳐질 수 있으며 Collectors는 다중 수준 그룹화를 달성할 수 있도록 합쳐질 수 있다.<br/>

  <h2>10.3 자바로 DSL을 만드는 패턴과 기법</h2>
  DSL은 특정 도메인 모델에 적용할 친화적이고 가독성 높은 API를 제공한다.<br/>
  직관적으로 도에인 모델을 반영할 수 있는 DSL이 필요하다.<br/>
  
  <h3>10.3.1 메서드 체인</h3>
  1) 메서드 체인을 통해 객체를 만든다.
  2) 플루언트 API로 도메인 객체를 만드는 몇 개의 빌더를 구현해야 한다.<br/>
  3) 사용자 미리 지정된 절차에 따라 설정하도록 한다.<br/>
  4) 사용자 파라미터가 빌더 내부로 국한된다.<br/>
  5) 정적 메서드 사용을 최소화하고 메서드 이름이 인수의 이름을 대신하도록 만들어 가독성을 높인다.<br/>
  6) 빌더를 구현하여야만 한다.<br/>
  
  <h3> 중첩된 함수 이용</h3>
  중첩된 함수 DSL 패턴은 이름에서 알 수 있듯이 다른 함수 안에 함수를 이용해 도메인 모델을 만든다,<br/>
  함수의 중첩 방식이 도메인 객체 계층 구조에 그대로 반영<br/>
  단점으로는 DSL에 더 많은 괄호가 사용되어야한다.<br/>
  인수로 덩적 메서드를 너겨줘야한다.<br/>
  여러 메서드 오버라이드 구현해야 한다.<br/>
  
  <h3>람다 표현식을 이용한 함수 시퀀싱</h3>
  메서드 체인 패턴처럼 플루언트 방식으로 정의가 가능하다.<br/>
  중첩 함수 형식처럼 람다 표현식의 중첩 수준과 비슷하게 도메인 객체의 계층 구조를 유지한다.<br/>
  더 많은 설정 코드가 필요하다는 게 단점이다.<br/>
  또 다른 단점은 DSL 자체가 자바 8 람다 표현식 문법에 의해 잡음의 영향을 받는다.<br/>
  
  <h3>10.4.1. jOOQ</h3>
 - SQL을 구현하는 내부적 DSL<br/>
 - 자바에 내장된 형식 안전 언어<br/>

```
//select * from BOOK where BOOK.PUBLISHED_IN = 2006 ORDER BY BOOK.TITLE
create.selectFrom(BOOK)
      .where(BOOK.PUBLISHED_IN.eq(2016))
      .orderBy(BOOK.TITLE)
```
  
  
  <h3>10.4.2. 큐컴버</h3>
다른 BDD(Behavior-driven Development)은 테스트 주도 개발의 확장으로 다양한 비즈니스 시나리오를 구조적으로 서술하는 간단한 도메인 전용 스크립팅 언어를 사용한다.<br/>
  명령문을 실행 할 수 잇는 테스트 케이스로 변환한다.<br/>

```
Feature: Buy stock
    Senario: Buy 10 IBM stocks
        Given the price of a "IBM" stock is 125$
        When I buy 10 "IBM"
        Then the order value should be 1250$

public class BuyStocksSteps {
    @Given("^the price of a \"(.*?\" stock is (\\d+)\\$$")
    public void setUnitPrice(String stockName, int unitPrice) {
    }
}

```

  <h3>4.3. 스프링 통합(Spring Integration)</h3>
의존성 주입에 기반한 스프링 프로그래밍 모델을 확장한다.<br/>

  <h3>10.5 마치며</h3>
DSL의 주요 기능은 개발자와 도메인 전문가 사이의 간격을 좁히는 것이다.<br/>
애플리케이션의 비즈니스 로직을 구현하는 코드를 만든 사람이 프로그램이 사용될 비즈니스 필드의 전문 지식을 갖추긴 어렵다.<br/>
개발자가 아닌 사람도 이해할 수 있는 언어로 이런 비즈니스 로직을 구현할 수 있다고 해서 도메인 전문가가 프로그래머가 될 수 있는 것은 아니지만 적어도 로직을 읽고 검증하는 역할은 할 수 있다.<br/>
DSL은 내부DSL, 다중DSL, 외부DSL로 구분할 수 있으며 구분 기준은 호스팅 언어를 기반으로 한 정도이다.<br/>
JVM에서 이용할 수 있는 스칼라, 그루비 등 다른 언어로 다중 DSL을 개발할 수 있다.<br/><br/>
장점 : 자바보다 유연하며 간결<br/>
단점 : 자바와 통합할 때 빌드 과정이 복잡해지며 상호 호환성 문제 발생 가능<br/>
자바의 장황함과 문법적 엄격함 때문에 내부DSL 개발 언어로 적합하지 않다.<br/>
자바 8의 람다 표현식과 메서드 참조 덕분에 상황이 많이 개선되었다.<br/>
