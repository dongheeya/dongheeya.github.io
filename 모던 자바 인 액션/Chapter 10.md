<h1>람다를 이용한 도메인 전용 언어</h1>

개발자들은 보통 프로그래밍 언어도 결국 언어라는 사실을 잊곤 한다.<BR/>
언어의 주요 목적은 메세지를 명확하고, 안정적인 방식으로 전달하는 것.<BR/>

애플리케이션의 핵심 비즈니스를 모델링하는 소프트웨어 영역에서 읽기 쉽고 이해하기 쉬운 코드는 특히 중요하다.<BR/>
개발팀과 도메인 전문가가 공유하고 이해할 수 잇는 코드는 생선성과 직결되기 때문이다.<BR/>
결과적으로 버그와 오해를 미리 방지할 수 있다.<BR/>

DSL(도메인 전용 언어)로 애플리케이션의 비즈니스 로직을 표현하여 이 문제를 해결할 수 있다.<BR/>
DSL은 범용이 아닌 특정 도메일을 대상으로 만들어진 특수 프로그래밍 언어이다.<BR/>
DSL은 도메일의 많은 특성 용어를 사용한다.<BR/>
자바는 역사적으로 완고함, 장황함 등의 특성 때문에 기술 배경이 없는 사람들이 사용하기에는 부적적한 용어로 간주되었음.<BR/>
자바가 람다 표현식을 지원하면서 달라지고 있다.<BR/>
코드를 간결하게 만들수도 잇고, 프로그램의 신호 대비 잡음을 줄일 수 있다.<BR/>

DSL은 외부/내부적 DSL로 나눠진다.<BR/>
외부적 DSL로 데이터베이스가 텍스트로 구현된 SQL표현식을 파싱하고 평가하는 API를 제공하는 것이 일반적이다.
내부적 DSL에서는 SQL의 SELECT FROM 구문처럼 애플리케이션 수준의 기본값이 자바 메서드가 사용할 수 있도록 데이터베이스를 대표하는 한 개
이상의 클래스 형식으로 노출된다.<BR/>
내부적 DSL에서는 적절한 클래스와 메서드를 노출하는 과정이 필요하다.

<h2>10.1 도메인 전용 언어</h2>
- DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어다.<BR/>
- 자바에서는 도메인을 표현하는 클래스와 메서드 집합이 필요하다.<BR/>
- DSL이란 특정 비즈니스 도메인을 인터페이스로 만든 API로 생각할 수 있다.<BR/>
- 동작과 용어는 특정 도메인에 국한되므로 다른 문제는 걱정할 필요가 없고, 자신의 앞에 놓인 문제를 어떻게 해결할지에만 집중할 수 있다.<BR/>

[DSL를 개발할때 고민해보아야하는 점]<BR/>
1) 의사 소통의 왕 : 우리의 코드의 의모가 명확히 전달되어야 하며 프로그래머가 아닌 사람도 이해할 수 있어야한다.<BR/>
2) 한번 코드를 구현하지만 여러번 읽는다 : 가독성은 유지보수의 핵심으로 동료가 이해할 수 있도록 구현해야한다.<BR/>

<h2>10.1.1 DSL의 장점과 단점</h2><BR/>
[DSL의 장점]<BR/>
1) 간결함 :API는 비즈니스 로직을 간펴하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들수 있다.<BR/>
2) 가독성 : 비 도메인 전문가도 코드를 쉽게 이해할 수 있다.<BR/>
3) 유지보수 : 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수하고 바꿀 수 있다<BR/>
4) 높은 수준의 추상화 : DSL은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨긴다.<BR/>
5) 집중 : 결과적으로 생산성이 좋아진다<BR/>
6) 관심사 분리 : 애플리케이션의 인프라구조와 관련된 문제와 독립적으로 비즈니스 관련된 코드에서 집중하기가 용이하다.<BR/>


[DSL의 단점] <BR/>
1) DSL 설계의 어려움 : 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다<BR/>
2) 개발 비용 : DSL유지보수와 변경은 프로젝트에 부담을 주는 요소이다.<BR/>
3) 추가 우회 계층 : DSL은 계층을 최대한 작게 만들어 성능 문제를 회피한다.<BR/>
4) 한 프로젝트에도 여러가지 언어를 사용하는 추세인데, DSL까지 추가되면 더 많은 언어를 배워야한다는 부담이 있다.<BR/>
5) 호스팅 언어 한계 : 일부 자바 같은 범용 프로그래밍 언어는 장황하고 엄격한 문법을 가졋다. 이런 언어로는 자연친화적인 DSL을 만들기가 힘들다.<BR/>

<h2>10.1.2 JVM에서 이용할 수 잇는 다른 DSL 해결책</h2>
DSL의 카테고리를 구분하는 가장 흔한 방법은 내부 DSL과 외부 DSL로 나누는 것이다.<BR/>
내부 DSL은 순수 자바 코드 같은 기존 호스팅 언어를 기반으로 구현하는 반면,<BR/>
외부 DSL은 호스팅 언어와는 독립적으로 자체의 문법을 가진다.<BR/>

<b>내부 DSL</b>
- 내부 DSL 이란 자바로 구현한 DSL을 의미한다.<BR/>

```
List<String> numbers = Arrays.asList("one","two","three");
numbers.forEach(new Comsumer<String>(){
  @Override
  public void accept(String s){
    System.out.println(s);
  }
});

```

다음처럼 익명 내부 클래스를 람다 표현식으로 바꿀 수 있다.
```
numbers.forEach( s-> System.out.println(s));
```

순수 자바로 DSL을 구현함으로 다음과 같은 장점을 얻을 수 있다.
1) 기존 자바 언어를 이용하면 외부 DSL에 비해 새로운 패턴과 기술을 배워 DSL을 구현하는 노력이 현저하게 줄어든다.
2) 순수 자바로 DSL을 구현하면 나머지 코드와 함께 DSL을 컴파일러 할 수 있다.
3) 익숙하지 않고 복잡한 외부 도구를 배울 필요가 없다.
4) 기존의 자바 IDE를 이용해 자동완성, 자동 리팩토링 같은 기능을 그대로 즐길 수 있다.

<B>다중 DSL</B>
다중 DSL : 자바가 아니지만 JVM에서 실행됨(스칼라, 그루비 등)
[장점]
JVM에서 실행되는 언어 중에 문법이 간편하고 제약이 적은 언어가 많다.<BR/>
Scala에서 내장DSL로 3번 Hello World를 출력하는 프로그램 구현<BR/>
문법적 잡음이 없음을 확인<BR/>

```
//  주어진 함수 f를 주어진 횟수만큼 반복 실행하는 유틸리티 함수 구현
def times(i: Int, f: => Unit): Unit = { f
if (i > 1) timesStandard(i - 1, f)
}
times(3, pringln("Hello World"))
```
[단점]
1) 새로운 프로그래밍 언어를 배워야만 한다.
2) 두 개 이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.
3)JVM에서 실행되는 거의 모든 언어가 자바와 100% 호환을 주장하고 있지만 완벽하지 않을 때가 많다.
4) 스칼라와 자바 컬렉션은 호환되지 않으므로 상호 컬렉션을 전달하려면 기존 컬렉션을 대상 언어의 API에 맞게 변환해야 한다.


<B>외부 DSL</B>
자신만의 문법과 구문으로 새 언어를 설계해야 한다.<BR/>
새 언어를 파싱하고, 파서의 결과를 분석하고, 외부 DSL을 실행할 코드를 만들어야 한다.<BR/>
무한한 유연성 장점이다.<BR/>
우리에게 필요한 특성을 완벽하게 제공하는 언어를 설계할 수 있다는 것이 장점이다.<BR/>

<h2>10.2 최신 자바 API의 작은 DSL</h2>
- 자바의 새로운 기능의 장점을 적용한 첫 API는 네이티브 자바 API 자신이다.
- 람다 표현식과 메소드 참조를 이용해 DSL의 가독성, 재사용성, 결합성이 높아졌다.

<h3>10.2.1 스트림 API는 컬렉션을 조작하는 DSL</h3>
Stream 인터페이스는 네이티브 자바 API에 작은 내부 DSL을 적용한 좋은 예다.<BR/>
Stream은 컬렉션의 항목을 필터, 정렬, 변환, 그룹화, 조작하는 작지만 강력한 DSL로 볼 수 있다.<BR/>

ex) 로그 파일을 읽어서 "ERROR"라는 단어로 시작하는 파일의 첫 40행을 수집하는 작업을 수행한다고 가정하자.
```
List<String> errors = new ArrayList<>();
int errorCount = 0;
BufferedReader bufferedReader = new BufferedReader(new FileReader(fileName));
String line = buferedReader.readLine();
while(errorcount < 40 && line != null){
  if(line.startWith("ERROR")){
    errors.add(line);
    errorCount++;
  }
  line = bufferedReader.readLine();
}
```
다음을 더 간단하게 보여준다면 다음과 같다.
```
List<String> errors = Files.line(Paths.get(fileName))   ☜ 파일을 열어서 문자열 스트림을 만듦
                          .fileter(line -> line.startsWith("ERROR")) ☜ ERROR로 시작하는 행을 필터링
                          .limit(40) ☜ 결과를 첫 40행으로 제한
                          .collect(toList()); ☜ 결과 문자열을 리스트로 수집
```
String은 파일에서 파싱할 행을 의미하며 Files.lines는 정적 유틸리티 메서드로 Stream<String>을 반환한다.<BR/>
파일을 한행 씩 반환하는 코드는 이게 전부이다. 에러행을 첫 40개만 수집한다.<BR/>
  
스트림 API의 플루언트 형식은 잘 설계된 DSL의 또 다른 특징이다.
모든 중간 연산은 게으르며 다른 연산으로 파이프라인될 수 있는 스트림으로 반환한다.
최종 연산은 적극적이며 전체 파이프라인이 계산을 일으킨다.
  

  
 




