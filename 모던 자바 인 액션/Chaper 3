Chaper 3. 람다 표현식
 - 이전 Chaper2.에서 동작 파라미터화를 이용해서 변화하는 요구사항에 효과적으로 대응하는 코드를 구현
 - 동작 파라미터를 활용하면 더 유연하고 재사용할 수 있는 코드를 만들수 있음.
 - 익명 클래스로도 구현 가능하지만, 깔끔하지 않다.
 - [람다 표현식]은 익명 클래스처럼 이름이 없는 함수 & 메서드를 인수로 전달한다 (~= 익명 클래스)

3.1 람다란 무엇인가?
 람다란?
 1) 메서드로 전달할 수 있는 익명 함수를 단순화
 2) 이름은 없지만 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트를 가질 수 있다.
 
 람다의 특징
 - 익명 : 보통 메스드와 다르게 이름이 없다.
 - 함수 : 메서드처럼 특정 클래스에 종속되지 않음. 하지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트를 가진다.
 - 전달 : 메서드 인수로 전달하거나 변수로 저장 가능.
 - 간결성 : 익명 클래스처럼 자질구레한 코드 구현할 필요 없음.
 
 ex) Comparator 객체의 활용
 Comparator<Apple> byWeight = new Comparator<Apple>(){
  public int compare(Apple a1, Apple a2){ return a1.getWeight().compareTo(a2.getWeight()));
 };
 
 Comparator<Apple> byWeight = (Apple a1, Apple a2) -> (a1.getWeight().compareTo(a2.getWeight());
 
 * 람다 표현식의 3 부분
 (Apple a1, Apple a2) -> (a1.getWeight().compareTo(a2.getWeight());
 -----------------(1) --(2) ----------------------------------------(3)
 
 (1) 파라미터 리스트 : Comparator의 compare 메서드 파라미터
 (2) 화살표 : -> 람다의 파라미터 리스트와 바디를 구분.
 (3) 람다 바디 : 람다의 반환값에 해당하는 표현식 
 
3.2 어디에, 어떻게 람다를 사용할까?
 람다식은 다음과 같이 활용될 수 있다.
 List<Apple> greenApple = filter(Apple, (Apple a) -> GREEN.equals(a.getColor()));
 -> 함수형 인터페이스라는 문맥에서 람다를 사용할 수 있다.
 다음 예제에서는 Predicate<T>를 기대하는 filter 두번째 인자로 사용하였다.
 
3.2.1 함수형 인터페이스
 2장에서 만든 Predicate<T> 인터페이스로 필터 메서드를 파라미터화할 수 있었음을 기억하는가?
 Predicate<T>가 바로 함수형 인터페이스다.
 오직 하나의 추상 메서드만 지정하기 때문이다.
 
 public interface Predicate<T>{
  boolean test(T t);
 }

 public interface Comparator<T>{
  int compare(T o1, T o2);
 }
 
 public interface Runnable{
  void run();
 }
 
 public interface ActionListener extends EventListener{
  void actionPerformed(ActionEvent e);
 }
 
 public interface Callable<V>{
  V call() throw Exception;
 }
 
 public interface PrivilegedAction<T>{
  T run();
 }

 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으며,
 전체 표현식을 함수형 인터페이스의 인스턴스로 취급한다.
 
 ex) Runnable r1 = () -> System.out.println("Hello world 1");
 Runnable r2 = new Runnable(){
  public void run(){
    System.out.println("Hello World2");
  }
 }
 
 3.2.2 함수 디스크립터
  함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
  람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.
  
  ex) Runnable 인터페이스의 run은 인수와 반환값이 없으므로 (void반환) Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.
  
  @FunctionalInterface
  - 함수형 인터페이스임을 가리키는 어노테이션이다.
  따라서 선언한 후, 함수형 인터페이스가 아니면 컴파일러 에러이다.
  
 3.3 람다 활용: 실행 어라운드 패턴
  자원처리에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이뤄진다.
  즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 가지며 이를 실행 어라운드 패턴이라고 한다.
  
  ex) 다음은 파일에서 한 행을 읽는 코드이다.
  public String processFile() throws IOException{
    try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))){
      return br.readLine();
    }
  }
 3.3.1 1단계  : 동작 파라미터화를 기억하라.
  해당 위의 코드에서는 한줄만 읽을 수 있다.
  한번에 2줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 어떻게 해야될까?
  기존 설정, 정리 과정을 재사용하고 processFile매서드만 다른 동작을 수행하도록 명령할 수 있다면 좋을 것이다.
  즉, processFile 동작을 파라미터화 하는 것이다.
  
  람다를 이용하여 한번에 두 행을 읽게하려면 다음과 같이 가능하다.
  String result = processFile((BufferReader br) -> br.readLine() + br.readLine());
  
 3.3.2 2단계 : 함수형 인터페이스를 이용해서 동작 전달.
 함수형 인터페이스 자리에 람다를 사용할 수 있다.
 BufferedReader -> String과 IOException을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스는 다음과 같다.
 
 @FunctionalInterface
 public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException;
 }
 
 그리고 인터페이스를 processFile메서드로 인수를 전달할 수 있다.
 public String processFile(BufferedReaderProcessor p) throws IOException {
 
 }
 
 3.3.3 3단계 : 동작 실행
 
 public String processFile(BufferedReaderProcessor p) throws IOException {
  try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))){
   return p.process(br);
  }
 }
 
 3.3.4 4단계 : 람다 전달
 람다를 이용해서 다양한 동작을 processFile메서드로 전달가능하다.
 String oneLine = processFile((BufferReader br) -> br.readLine());
 
 String twoLine = processFile((BufferReader br) -> br.readLine() + br.readLine() );
 
3.4 함수형 인터페이스 사용
 - 함수형 인터페이스는 오직 하나의 추상메서드를 지정하고, 람다의 시그니처를 묘사한다.
 함수형 인터페이스의 추상 메서드 시그니처를 함수 드시크립터라고 한다.
 자바 api는 Comparable, Runnable, Callable 등의 다양한 함수형 인터페이스를 포함하고있다.
 
 3.4.1 Predicate
  - java.util.function.Predicate<T> 는 test라는 추상 메서드를 정의하며, test는 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환.
  
  @FunctionalInterface  // 함수형 인터페이스
  public interface Predicate<T> {
   boolean test(T t);
  }
  
  public <T> List<T> filter(List<T> list, Predicate<T> p){
   List<T> results= new ArrayList<>();
   for(T t:list){
    if(p.test(t)) result.add(t)
   return results;
  }
  
  Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
  List<String> nonEmpty = filter(listOfString, nonEmptyStringPredicate);
  
 3.4.2 Consumer 
  - java.util.function.Consumer<T> 는 제네릭 형식 T객체를 받아서 void반환하는 accept라는 추상 메서드를 정의한다.
  
  @FunctionalInterface
  public interface Consumer<T> {
   void accept(T t);
  }
  
  public <T> void forEach(List<T> list, Consumer<T> c){
   for(T t : list) c.accept(t);
  }
  
  forEach(
   Arrays.asList(1, 2, 3, 4, 5), (Integer i) -> System.out.println(i)
  );

  3.4.3 Function
   - java.util.function.Function<T, R> 제네릭 형식 T를 인수로 받아서 제네릭 형식 R객체를 반환하는 추상 메서드 apply정의한다.
   ex) String리스트 인수로 받아 각 String 의 길이를 포함하는 Integer 리스트로 변환하는 map메서드 정의하는 예제.
   
   @FunctionalInterface
   public interface Function<T, R> {
     R apply(T t);
   }
   
   pubic <T, R> List<R> map(List<T> list, Function<T, R> f){
    List<R> result = new ArrayList<>();
    for(T t: list){
     result.add(f.apply(t));
    }
    return result;
   }
   
   List<Integer> l = map(Arrays.asList("lamdas","in","action"), (String s) -> s.length());
   
   
