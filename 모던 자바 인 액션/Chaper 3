Chaper 3. 람다 표현식
 - 이전 Chaper2.에서 동작 파라미터화를 이용해서 변화하는 요구사항에 효과적으로 대응하는 코드를 구현
 - 동작 파라미터를 활용하면 더 유연하고 재사용할 수 있는 코드를 만들수 있음.
 - 익명 클래스로도 구현 가능하지만, 깔끔하지 않다.
 - [람다 표현식]은 익명 클래스처럼 이름이 없는 함수 & 메서드를 인수로 전달한다 (~= 익명 클래스)

3.1 람다란 무엇인가?
 람다란?
 1) 메서드로 전달할 수 있는 익명 함수를 단순화
 2) 이름은 없지만 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트를 가질 수 있다.
 
 람다의 특징
 - 익명 : 보통 메스드와 다르게 이름이 없다.
 - 함수 : 메서드처럼 특정 클래스에 종속되지 않음. 하지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트를 가진다.
 - 전달 : 메서드 인수로 전달하거나 변수로 저장 가능.
 - 간결성 : 익명 클래스처럼 자질구레한 코드 구현할 필요 없음.
 
 ex) Comparator 객체의 활용
 Comparator<Apple> byWeight = new Comparator<Apple>(){
  public int compare(Apple a1, Apple a2){ return a1.getWeight().compareTo(a2.getWeight()));
 };
 
 Comparator<Apple> byWeight = (Apple a1, Apple a2) -> (a1.getWeight().compareTo(a2.getWeight());
 
 * 람다 표현식의 3 부분
 (Apple a1, Apple a2) -> (a1.getWeight().compareTo(a2.getWeight());
 -----------------(1) --(2) ----------------------------------------(3)
 
 (1) 파라미터 리스트 : Comparator의 compare 메서드 파라미터
 (2) 화살표 : -> 람다의 파라미터 리스트와 바디를 구분.
 (3) 람다 바디 : 람다의 반환값에 해당하는 표현식 
 
3.2 어디에, 어떻게 람다를 사용할까?
 람다식은 다음과 같이 활용될 수 있다.
 List<Apple> greenApple = filter(Apple, (Apple a) -> GREEN.equals(a.getColor()));
 -> 함수형 인터페이스라는 문맥에서 람다를 사용할 수 있다.
 다음 예제에서는 Predicate<T>를 기대하는 filter 두번째 인자로 사용하였다.
 
3.2.1 함수형 인터페이스
 2장에서 만든 Predicate<T> 인터페이스로 필터 메서드를 파라미터화할 수 있었음을 기억하는가?
 Predicate<T>가 바로 함수형 인터페이스다.
 오직 하나의 추상 메서드만 지정하기 때문이다.
 
 public interface Predicate<T>{
  boolean test(T t);
 }

 public interface Comparator<T>{
  int compare(T o1, T o2);
 }
 
 public interface Runnable{
  void run();
 }
 
 public interface ActionListener extends EventListener{
  void actionPerformed(ActionEvent e);
 }
 
 public interface Callable<V>{
  V call() throw Exception;
 }
 
 public interface PrivilegedAction<T>{
  T run();
 }

 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으며,
 전체 표현식을 함수형 인터페이스의 인스턴스로 취급한다.
 
 ex) Runnable r1 = () -> System.out.println("Hello world 1");
 Runnable r2 = new Runnable(){
  public void run(){
    System.out.println("Hello World2");
  }
 }
 
 3.2.2 함수 디스크립터
  함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
  람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.
  
  ex) Runnable 인터페이스의 run은 인수와 반환값이 없으므로 (void반환) Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.
  
  @FunctionalInterface
  - 함수형 인터페이스임을 가리키는 어노테이션이다.
  따라서 선언한 후, 함수형 인터페이스가 아니면 컴파일러 에러이다.
  
 3.3 람다 활용: 실행 어라운드 패턴
  자원처리에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이뤄진다.
  즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 가지며 이를 실행 어라운드 패턴이라고 한다.
  
  ex) 다음은 파일에서 한 행을 읽는 코드이다.
  public String processFile() throws IOException{
    try(BufferedReader br = new BufferedReader(new FileReader("data.txt"))){
      return br.readLine();
    }
  }
 3.3.1 1단계  : 동작 파라미터화를 기억하라.
