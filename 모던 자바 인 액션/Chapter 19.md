<h1>함수형 프로그래밍 기법</h1>

<h2>함수는 모든 곳에 존재한다.</h2>
함수형 프로그래밍이란 함수나 메서드가 수학적 함수처럼 동작함을, 즉 부작용 없이 동작함을 의미했다.<br/>
함수형 언어 프로그래머는 함수형 프로그래밍이라는 용어를 좀 더 폭넓게 사용한다.<br/>
함수를 마치 일반값처럼 사용해서 인수로 전달하거나, 결과로 반환하거나, 자교 구조에 저장할 수 있음을 의미한다.<br/>
일반값처럼 취급할 수 있는 함수를 일급 함수라고 한다.<br/>
자바 8에서는 :: 연산자로 메서드 참조를 만들거나 (int x) -> x+1 같은 람다 표현식으로 직접 함숫값을 표현해서 메서드를 함숫값으로 사용할 수 있다.<br/>

```
Function<String, Integer> strToInt = Integer::parseInt;
```

<h2>고차원 함수</h2>
지금까지 filterApples 에 함숫값으로 Apple::isGreenApple을 전달해서 동작 파라미터화를 달성하는 용도로만 사용했다.<br/>
이는 함숫값 활용의 일부에 불과하다. 다음 코드 그리고 아래 그림이 보여주는 것처럼 함수를 인수로 받아서 다른 함수로 반환하는 정적 메서드 Comparator.comparing도 있었다.<br/>

![191](https://user-images.githubusercontent.com/87962572/144861396-d3a6899f-8436-4372-924c-b250d40d12ef.PNG)

```
Comparator<Apple> c = comparing(Apple::getWeight);

//3장에서는 함수를 조립해서 연산을 파이프라인을 만들 때 위 코드와 비슷한 기능을 활용했다.
Function<String, String> transformationPipeline = addHeader.andThen(Letter::checkSpelling).andThen(Letter::addFooter);
```

함수형 프로그래밍 커뮤니케이션에 따르면 Comparator.comparing처럼 다음 중 하나 이상의 동작을 수행하는 함수를 고차원 함수라 부른다.
- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환

자바 8에서는 함수를 인수로 전달할 수 있을 뿐 아니라 결과를 반환하고, 지역 변수로 할당하거나, 구조체를 삽입할 수 있으므로 자바 8의 함수도 고차원 함수라고 할 수 있다.<br/>

스트림 연산으로 전달하는 함수는 부작용이 없어야 하며, 부작용을 포함하는 함수를 사용하면 문제가 발생한다는 사실을 설명했따.(부작용을 포함하는 함수를 사용하면 부정확한 결과가 발생하거나 레이스 컨디션 떄문에 예상치 못한 결과라 발생할 수 있다.) . <br/>
고차원 함수를 적용할 떄도 같은 규칙을 적용된다.<br/>
고차원 함수나 메서드를 구현할 때 어떤 인수가 전다될 지 알 수 없으므로 인수가 부작용을 포함한 가능성을 염두에 두어야 한다!<br/>
함수를 인수로 받아 사용하면서 코드가 정확히 어떤 작업을 수행학 프로그램의 상태를 어떻게 바꿀지 에측하기 어려워진다.<br/>
디버깅도 어려워진다.<br/>
따라서 인수로 전달된 함수가 어떤 부작용을 포함하게 될지 정확하게 문서화하는 것이 좋다.<br/>
물론 부작용을 포함하지 않을 수 있다면 가장 좋을 것이다!<br/>

<h3>커링</h3>
함수를 모듈화하고 코드를 재사용하는 데 도움을 주는 기법인 커링을 살펴보자.<br/>
커링이 무엇인지 살펴보기 앞서 예제를 확인하자.<br/>
대부분의 애플리케이션은 국제화를 지원해야 하는데 이때 단위 변환 문제가 발생할 수 있다.<br/>

보통 변환 요소와 기준치 조정 요소가 단위 변환 결과를 좌우한다.<br/>
예를 들어 다음은 섭씨를 화씨로 변환하는 공식이다.<br/>

CtoF(x) = x * 9 /5 +32

다음과 같은 패턴으로 단우를 표현할 수 있다.

1. 변환 요소를 곱함.
2. 기준치 조정 요소를 적용

다음과 같은 메서드로 변환 패텬을 적용할 수 있다.

```
static double converter(double x, double f, double b)}
  return x * f + b;
}
```

여기에서 x는 변환하려는 값이고, f는 변환 요소며, b는 기준치 조정 요소다.<br/>
세 개의 인수를 받는 converter라는 메서드를 만들어 문제를 해결하는 방법도 있지만, 인수에 변환 요소와 기준치를 넣는 일은 귀찮은 일이며 오타도 발생하기 쉽다.<br/>

각각을 변환하는 메서드를 따로 만드는 방법도 있지만 그러면 로직을 재활용하지 못한다는 단점이 있다.<br/>
기존 로직을 활용해서 변환기를 특정 상황에 적용할 수 있는 방법이 있다. 다음은 커링이라는 개념을 활용해서 한 개의 인수를 갖는 변환 함수를 생성하는 팩토리를 정의하는 코드다.<br/>

```
static DoubleUnaryOperator curriedConvertor(double f, double b){
  return (double x) -> x * f + b;
}
```

메서드에 변환 요소(f)와 기준치(b)만 넘겨주면 우리가 원하는 작업을 수행할 함수가 반환된다.<br/>
예를 들어 다음은 팩토리르 이용해서 원하는 변환기를 생성하는 코드다.<br/>

```
DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32);
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0);
DoubleUnaryOperator convertKmtoMi = curriedConverter(0.6214, 0);
```

DoubleUnaryOperator는 applyAsDouble이라는 메서드를 정의하므로 다음처럼 변환기를 사용할 수 있다.

```
double gbp = convertUSDtoGBP.applyAsDouble(1000);
```

결과적으로 기존의 변환 로직을 재활용하는 유연하 코드를 얻었다!<br/>
우리가 어떤 작업을 햇는지 다시 생각햅자. x, f, b라는 세 인수를 converter 메서드로 전달하지 않고 f,b 두 가지 인수로 함수를 요청했으며 반환된 함수를 인수 x를 이용해서<br/>
x * f + b라는 결과를 얻었다.<br/>
이런 방식으로 변환 로직을 재활용할 수 있으며 다양한 변환 요소로 다양한 함수를 만들 수 있다.<br/>

<h3>커링의 이론적 정의</h3>
커링은 x와 y라는 두 인수를 받는 함수 f를 함 개의 인수를 받는 g라는 함수로 대체하는 기법이다.<br/>
이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다.<br/>
함수 g와 원래 함수 f가 최종적으로 반환하는 값은 같다.<br/>
즉, f(x,y) = (g(x))(y) 가 성립한다.<br/>

