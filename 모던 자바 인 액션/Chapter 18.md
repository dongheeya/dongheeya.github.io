<h1>함수형 관점으로 생각하기</h1>

실제 경험해본 적 없는 대규모 소프트웨어 시스템 업그레이드 관리를 요청했다고 했을때, 개발자들은 흔히 'synchronized'라는 키워드가 있는지부터 살펴본다고 한다.<br/>
그 이유는 synchronized의 버그는 고치는게 정말 어렵기 때문이다. 지금까지 자바8에서 스트림을 이용하면 locking(잠금)문제를 신경쓰지 않을 수 있었다.<br/>

또한 쉽게 유지보수할 수 있으려면 프로그램의 시스템 구조를 이해하기 쉽게 클래스 계층으로 반영하는 것이 좋다고 한다.<br/>
시스템의 각 부분의 상호 의존성을 가리키는 결합성과 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 응집성이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.<br/>

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다. 그리고 이는 예상치못한 변수값의 변경으로 인해 생긴다.<br/>
이를 방지하기 위해 우리는 함수형 프로그래밍이 제공하는 "부작용 없음(no side effect)"와 "불변성(immutability)"이라는 개념이 이 문제를 해결하는데 도움을 준다.<br/>

<h2>공유된 가변 데이터</h2>
변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.<br/>

ex) 리스트를 참조하는 여러 크래스가 있다고 가정했을 때, 리스트 소유자도 불분명하고 이들 중 하나의 클래스가 리스트를 갱신하면 다른 클래스는 리스트가 갱신했는지 알기도 어렵다.<br/>
그리고 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 갱신 사실을 추적하기가 어렵다.<br/>

![18-1](https://user-images.githubusercontent.com/87962572/144698263-32e85c82-fb39-42fc-86a4-6a830c3293b4.PNG)

이와 반대로 어떤 자료구조도 바뀌지 않는 시스템이 있다고 가정하자. 예산하지 못하게 자료구조의 값이 바뀔일이 없으니 유지보수도 쉽다.<br/>
자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 부작용 없는 메서드라고 부른다.<br/>
이렇게 불변 객체를 이용하면 부작용을 없애는 방법도 있다. <br/>
불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다.<br/>
즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.<br/>
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀수 없으므로 스레드 안전성을 제공한다.<br/>

부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다.<br/>
또한 프로그램으 어떤 부분이 독립적인지 바로 이해할 수 있다.<br/>
이런 부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.<br/>
함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍부터 보자.<br/>

<h2>선언형 프로그래밍</h2>
프로그램으로 시스템을 구현하는 방식은 2가지가 있다.<br/>
1) "어떻게"(how) : 작업을 어떻게 수행할 것인지 집중하는 방식<br/>
- 이 일을 먼저하고 그 다음에는 저 값을 갱신하고 그 다음에.. 처럼 작업 수행방식에 대해 집중하는 방식 ( 고전적 객체 지향 프로그램밍에서 사용)<br/>
ex) 리스트에서 트랜잭션을 가져와서 가장 비싼 트랜잭션을 비교할때, 가져온 트랜잭션이 가장 비싼 트랜잭션보다 비싸다면 가져온 트랜잭션이 가장 비싼 트랜잭션이 된다.<br/>
리스트의 다음 트랜잭션으로 지금까지의 과정을 반복한다.<br/>

```
Transaction mostExpensive = transactions.get(0);
if(mostExpensive == null)
  throw new IllegalArgumentException("Empty list of transactions");
  
for(Transaction t: transactions.subList(1, transactions.size())){
 if(t.getValue() > mostExpensive.getValue()){
 mostExpensive = t;
 }
}
```

2) "무엇을" : 선언형 프로그래밍이라고 불리우며 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 규칙을 정한다.<br/>

```
// 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.
Optional<Transaction> mostExpensive = transactions.stream()
 .max(comparing(Transaction::getValue));
```

<h2>왜 함수형 프로그래밍인가?</h2>
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용 없는 계산을 지향한다.<br/>
선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.<br/>

<h2>함수형 프로그래밍이란 무엇인가?</h2>
여기에서 함수란 무엇인가?<br/>
ex) int와 double을 인수로 받아서 double을 반화하는 메서드가 있는데 이 메서드는 그림에서 보여눈 것처럼 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.<br/>

![18-2](https://user-images.githubusercontent.com/87962572/144698726-de03eb54-a51e-45a2-805d-15d1e83f12cf.PNG)

함수형 프로그래밍에서 함수란 수학적인 함수와 같이 0개 이상으 인수를 가지고 한 개 이상의 결과를 반환하지만 부작용이 없어야한다.<br/>
그래서 그림과 같이 여러 입력을 받아서 여러 출력을 생성하는 블랙박스와 같다.<br/>

![18-3](https://user-images.githubusercontent.com/87962572/144698750-fad347cf-ddb6-40d3-a14e-647a859e0988.PNG)

특히 인수가 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다.<br/>
그리고 함수형 프로그래밍은 호출자에 아무 영향을 미치지 않는다면 호출자는 내부적으로 부작용으 파악하거나 신경쓸 필요가 없다.<br/>

<h3>함수형 자바</h3>
"햠수형"프로그래밍을 구현할때 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형 달성할 수 있다.<br/>
ex) 부작용을 일으키지 않는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나갈때 필드의 값을 돌려놓는다고 가정하자.<br/>
단일 스레드로 실행되면 이 메서드가 아무 부작용도 일으키지 않으므로 "함수형"이라 간주할 수 있다.<br/>
하지만 다른 스레드가 필드의 값을 확인한다든가 아니면 동시에 이 메서드를 호출하는 상황이 발생하는 수 있으면 이 메서드는 함수형이 아니다.<br/>
이럴 때 이 메서드의 바디를 잠금함으로써 이 문제를 해결할 수 있으며, 이 메서드는 함수형이라고 할 수 있다.<br/>
즉, 멀티 코어 프로세서의 두 코어를 활용해서 메서드를 병렬로 호출할 수 없게 된다.<br/>

함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 그리고 이때 참조하는 객체는 불변 객체여야 한다.<br/>
즉, 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 참조해야 한다. <br/>

함수나 메서드가 어떤 예외도 일으키지 않아야 한다.<br/>
예외가 발생하면 이전에 설명할 것처럼 블랙박스 모델에서 return으로 결과를 반환할 수 없게 될 수 있기 때문이다.<br/>
어떤 입력값이 있을 때 이는 정확하게 하나의 결과로 도출되며 입력값이 undifiened라면 결과가 아에 안나오게 된다. <br/>
이처럼 비정상적인 입력값이 있을 때 자바에서 예외를 일으키는 것은 자연스러운 방식이지만, 블랙박스의 단순 모델이 깨지는 것이다.<br/>

![18-4](https://user-images.githubusercontent.com/87962572/144699342-03e9e294-0e95-4ede-af9e-5b5c08b25a8a.PNG)

이렇게 예외를 사요하지 않고 함수를 사용하려면 어떻게 해야될까?<br/>
바로 Optional< T >를 사용하면 이 문제를 해결 할 수 있고 예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못하엿는지 확인가능하다.<br/>
(하지만 그렇다고해서 모든 코드가 Optional을 반드시 사용하도록 고치라는 뜻은 아님)<br/>

마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.<br/>
즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.<br/>

<h3>참조 투명성</h3>
'부작용을 감춰야한다'라는 제역은 참조 튜명성 개념으로 귀결된다.<br/>
즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.<br/>
ex) "raoul".replace('r','R') 이라는 코드는 항상 같은 결과가 나오므로 STring.replace는 참조적으로 투명하다.<br/>

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.<br/>
따라서 Random.nextInt나 Scanner객체로 입력을 받는 것들은 참조 투명성을 위배한다.<br/>
하지만 두 개의 final int 변수를 더하는 연산에서는 두 변수를 바꿀수 없으므로 이 연산은 항상 같은 결과를 생성한다.<br/>

참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.<br/>

자바에서는 참조 투명성과 관련한 작은 문제가 있다.<br/>
ex) List를 반환하는 메서드를 두 번 호출한다고 가정하자.<br/>
두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.<br/>
결과 리스트를 순수값으로 사용할 것ㅇ라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.<br/>
일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.<br/>

<h3>함수형 실전 연습</h3>
{1,4,9}처럼 List< Integer > 가 주어졌을 때 이것의 모든 서브 집합의 멤버로 구성된 List< List< Integer > > 를 만드는 프로그램을 만든다고 가정하자.<br/>
예를 들어, {1,4,9}의 서브 집합은 {1,4,9},{1,4},{1,9},{4,9},{1},{4},{9},{} 다.<br/>
빈 집합 {}를 포함해서 총 8개의 서브집합이 존재하며 각 서브집합은 List< Integer > 형식으로 이루어져 있으므로 최종 정답의 형식은 List <List < Integer > >다.<br/>

보통 {1,4,9}의 서브집합 중 1을 포함하는 집합과 아닌 집합으로 구분해서 문제를 풀려 시도할 것이다.<br/>
1을 포함하지 않는 부분집합은 {4,9}의 부분집합이고, 1을 포함하는 부분집합은 {4,9}의 모든 부분집합에 1을 포함시켜 얻을 수 있다.<br/>
이와 같은 접근 방식은 가장 쉽고 자연스러운 함수형 자바 프로그래밍이다.<br/>

```
// subsets자체도 기존의 구조를 갱신하지 않으므로 함수형이다.
static List<List<Integer>> subsets(List<Integer> list) {
 if (list.isEmpty()) {     ▶ 입력리스트가 비어있다면 빈 리스트 자신이 서브 집합니다.
    List<List<Integer>> ans = new ArrayList<>();
     ans.add(Collections.emptyList());
     return ans;
 }
 
 Integer fst = list.get(0);
 List<Integer> rest = list.subList(1,list.size());
 List<List<Integer>> subAns = subsets(rest);           ▶ 빈 리스트가 아니면 먼저 하나의 욧를 꺼내고 나머지 요소의 모든 서브 집합을 찾아서 subsets로 전달한다.
 List<List<Integer>> subAns2 = insertAll(fst, subAns); ▶ subans, subans2를 연결하면 정답이 완성된다.
 
 return concat(subAns, subAns2); 
}

static List<List<Integer>> insertAll(Integer fst, List<List<Integer>> lists) {
 List<List<Integer>> result = new ArrayList<>();
 for (List<Integer> list : lists) {
     List<Integer> copyList = new ArrayList<>();  ▶ 리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 구조체가 가변이라도 저수준 구조를 복사하지 않는다.
     copyList.add(fst);
     copyList.addAll(list);
     result.add(copyList);
 }
 return result;
}

static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
 List<List<Integer>> r = new ArrayList<>(a);
 r.addAll(b);
 return r;
}

```
입력으로 {1,4,9}를 제공하면 결과로 {},{9},{4},{4,9},{1},{1,9},{1,4},{1,4,9}를 얻게된다. <br/>
그리고 subset는 함수내에서 또 subset를 호출하고 반환하는 형식으로 구현이 되어잇거 수학접 귀납법의 인수처럼 처리되고있다.<br/>

concat함수는 순수함수이다. 내부적으로 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며<br/>
인수의 정보를 변경하지 않는다.<br/>

<h2>재귀와 반복</h2>
순수 함수형 프로그래밍에서는 while,for 같은 반복문을 포함하지 않는다.<br/>
이러한 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다.<br/>
함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 설명했다.<br/>
즉, 지역 변수는 자유롭게 갱신할 수 있다.<br/>
자바의 Iterator로 for(Apple a : apples) { } 라는 for-each 루프를 표현한 코드이다.<br/>

```
Iterator<Apple> it = apples.iterator();
while(it.hasNext()){
  Apple apple = it.next();
  // ...
}
```

위 코드에서는 호출자는 변화를 확인할 수 없으므로 아무 문제가 없다.<br/>
즉 next로 Iterator의 상태를 변환했고, while 바디 내부에서 apple변수를 할당하는 동작을 할 수 있다.<br/>
하지만 다음 코드처럼 for-each 루프를 사용하는 검색 알고리즘은 문제가 될 수 있다.<br/>

```
public void searchForGold(List<String> l, Stats stats){
 for(String s: l){
     if("gold".equals(s))
        stats.incrementFor("gold");   ◀ 루프 내부에서 stats 상태 변화시킴
     }
 }
}
```

루프의 바디에서 함수형과 상충하는 부작용이 발생하는데, 루프 내부에서 프로그램의 다른 부분과 공유되는 stats 객체의 상태를 변화시킨다.<br/>

이러한 부작용 연산을 원천적으로 제거하기 위해서는<br/>
이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구혀할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다.<br/>
재귀를 이용하면 로프 단계마다 갱신되는 반복 변수를 제거할 수 있다.<br/>


다음은 팩토리얼 함수로, 반복과 재귀 방식으로 해결할 수 있는 고전적 학교 문제다<br/>
여기에서 입력은 1보다 크다고 가정하자.<br/>

```
// 반복 방식의 팩토리얼
static long factorialIterative(long n) {
 long r = 1;
 for (int i = 1; i <= n; i++) {
    r *= i;
 }
 
 return r;
}
// factorialIterative(3) 
// 1*1 = 1
// 1*2 = 2
// 2*3 = 6

//재귀 방식의 팩토리얼
static long factorialRecursive(long n) {
 return n == 1 ? 1 : n * factorialRecursive(n-1);
}
//factorialRecursive(3)
// 3 * factorialRecursive(2)
// 3 * 2 * factorialRecursive(1)
// 3 * 2 * 1
// 6
```

첫 번째 예제는 일반적인 로프를 사용한 코드로 매 반복마다 변수 r과 i가 갱신된다.<br/>
두번째 재귀 방식의 코드는 좀 더 수학적인 형식으로 문제를 해결한다.<br/>

```
// 스트림 팩토리얼 
static long factorialStreams(long n){
 return LongStream.rangeClosed(1, n).reduce(1, (long a, long b) -> a * b);
}
```

스트림으로 만든 팩토리얼의 효율성 측면을 살펴보자.<br/>
함수형 프로그래밍의 장점이 분명히 있지만 무조건 반복보다는 재귀가 좋다고 주장하는 주장에는 주의해야한다.<br/>
일반적으로 반복보다는 재귀 코드가 더 비씨기 떄문이다.<br/>
factorialRecursive 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어기 떄문이다.<br/>
따라서 입력값이 크게 된다면 다음처럼 stackOverFlowError가 발생하다.<br/>

```
Exception in thread "main" java.lang.StackOverflowError
```

함수형 언어에서는 꼬리 호출 최적화라는 해결책을 제공한다.

```
static long factorialTailRecursive(long n) {
 return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
 return n == 1 ? acc : factorialHelper(acc * n, n-1);
}

// factorialTailRecursive(3)
// factorialHelper(1,3) -> factorialHelper(3,2) -> factorialHelper(6,1) -> 6
```

factorialHelper에서 재귀 호출이 가장 마지막에서 이루어지므로 꼬리 재귀이다.<br/>
factorialTailRecursive에서 마지막으로 수행한 연산운 n과 재귀 호출의 결과값의 곱셈이다.

그래서 중간 결과를 각각의 스택 프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다.
사실 factorialHealper의 정의에서는 중간 결과를 함수의 인수로 직접 전달한다.

위의 그림은 재귀 정의이고 아래는 꼬리 재귀 정의의 차이를 보여준다.
![18-5](https://user-images.githubusercontent.com/87962572/144859543-d54da800-2c2a-4ada-88c5-0faffbbfbccc.PNG)

자바에서는 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 적용하는 것이 좋다.

결론적으로 자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다. 또한 반복을 재귀로 바꾸면 더 간결하고 부작용이 없는 알고리즘을 만들 수 있다.
실제로 재귀를 이용하면 좀 더 쉽게 읽고, 쓰고, 이해할 수 있는 예제를 만들 수 있다.

<h2>핵심 정리</h2>
1. 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는 데 도움이 된다.
2. 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다.
3. 함수형 메서드는 입력 인수와 출력 결과만 갖는다.
4. 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. while 루프 같은 반복문은 재귀로 대체할 수 있다.
5. 자바에서는 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러의 최적화를 기대할 수 있다.
