<h1>함수형 관점으로 생각하기</h1>

실제 경험해본 적 없는 대규모 소프트웨어 시스템 업그레이드 관리를 요청했다고 했을때, 개발자들은 흔히 'synchronized'라는 키워드가 있는지부터 살펴본다고 한다.<br/>
그 이유는 synchronized의 버그는 고치는게 정말 어렵기 때문이다. 지금까지 자바8에서 스트림을 이용하면 locking(잠금)문제를 신경쓰지 않을 수 있었다.<br/>

또한 쉽게 유지보수할 수 있으려면 프로그램의 시스템 구조를 이해하기 쉽게 클래스 계층으로 반영하는 것이 좋다고 한다.<br/>
시스템의 각 부분의 상호 의존성을 가리키는 결합성과 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 응집성이라는 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.<br/>

그러나 실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다. 그리고 이는 예상치못한 변수값의 변경으로 인해 생긴다.<br/>
이를 방지하기 위해 우리는 함수형 프로그래밍이 제공하는 "부작용 없음(no side effect)"와 "불변성(immutability)"이라는 개념이 이 문제를 해결하는데 도움을 준다.<br/>

<h2>공유된 가변 데이터</h2>
변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.<br/>

ex) 리스트를 참조하는 여러 크래스가 있다고 가정했을 때, 리스트 소유자도 불분명하고 이들 중 하나의 클래스가 리스트를 갱신하면 다른 클래스는 리스트가 갱신했는지 알기도 어렵다.<br/>
그리고 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 갱신 사실을 추적하기가 어렵다.<br/>

![18-1](https://user-images.githubusercontent.com/87962572/144698263-32e85c82-fb39-42fc-86a4-6a830c3293b4.PNG)

이와 반대로 어떤 자료구조도 바뀌지 않는 시스템이 있다고 가정하자. 예산하지 못하게 자료구조의 값이 바뀔일이 없으니 유지보수도 쉽다.<br/>
자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 순수 메서드 또는 부작용 없는 메서드라고 부른다.<br/>
이렇게 불변 객체를 이용하면 부작용을 없애는 방법도 있다. <br/>
불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않는다.<br/>
즉, 인스턴스화한 불변 객체의 상태는 결코 예상하지 못한 상태로 바뀌지 않는다.<br/>
따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 객체의 상태를 바꿀수 없으므로 스레드 안전성을 제공한다.<br/>

부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다.<br/>
또한 프로그램으 어떤 부분이 독립적인지 바로 이해할 수 있다.<br/>
이런 부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래되었다.<br/>
함수형 프로그래밍의 기반을 이루는 개념인 선언형 프로그래밍부터 보자.<br/>

<h2>선언형 프로그래밍</h2>
프로그램으로 시스템을 구현하는 방식은 2가지가 있다.<br/>
1) "어떻게"(how) : 작업을 어떻게 수행할 것인지 집중하는 방식<br/>
- 이 일을 먼저하고 그 다음에는 저 값을 갱신하고 그 다음에.. 처럼 작업 수행방식에 대해 집중하는 방식 ( 고전적 객체 지향 프로그램밍에서 사용)<br/>
ex) 리스트에서 트랜잭션을 가져와서 가장 비싼 트랜잭션을 비교할때, 가져온 트랜잭션이 가장 비싼 트랜잭션보다 비싸다면 가져온 트랜잭션이 가장 비싼 트랜잭션이 된다.<br/>
리스트의 다음 트랜잭션으로 지금까지의 과정을 반복한다.<br/>

```
Transaction mostExpensive = transactions.get(0);
if(mostExpensive == null)
  throw new IllegalArgumentException("Empty list of transactions");
  
for(Transaction t: transactions.subList(1, transactions.size())){
 if(t.getValue() > mostExpensive.getValue()){
 mostExpensive = t;
 }
}
```

2) "무엇을" : 선언형 프로그래밍이라고 불리우며 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 규칙을 정한다.<br/>

```
// 질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 장점이다.
Optional<Transaction> mostExpensive = transactions.stream()
 .max(comparing(Transaction::getValue));
```

<h2>왜 함수형 프로그래밍인가?</h2>
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용 없는 계산을 지향한다.<br/>
선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.<br/>

<h2>함수형 프로그래밍이란 무엇인가?</h2>
여기에서 함수란 무엇인가?<br/>
ex) int와 double을 인수로 받아서 double을 반화하는 메서드가 있는데 이 메서드는 그림에서 보여눈 것처럼 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.<br/>

![18-2](https://user-images.githubusercontent.com/87962572/144698726-de03eb54-a51e-45a2-805d-15d1e83f12cf.PNG)

함수형 프로그래밍에서 함수란 수학적인 함수와 같이 0개 이상으 인수를 가지고 한 개 이상의 결과를 반환하지만 부작용이 없어야한다.<br/>
그래서 그림과 같이 여러 입력을 받아서 여러 출력을 생성하는 블랙박스와 같다.<br/>

![18-3](https://user-images.githubusercontent.com/87962572/144698750-fad347cf-ddb6-40d3-a14e-647a859e0988.PNG)

특히 인수가 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다.<br/>
그리고 함수형 프로그래밍은 호출자에 아무 영향을 미치지 않는다면 호출자는 내부적으로 부작용으 파악하거나 신경쓸 필요가 없다.<br/>

<h3>함수형 자바</h3>
"햠수형"프로그래밍을 구현할때 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형 달성할 수 있다.<br/>
ex) 부작용을 일으키지 않는 어떤 함수나 메서드가 있는데, 다만 진입할 때 어떤 필드의 값을 증가시켰다가 빠져나갈때 필드의 값을 돌려놓는다고 가정하자.<br/>
단일 스레드로 실행되면 이 메서드가 아무 부작용도 일으키지 않으므로 "함수형"이라 간주할 수 있다.<br/>
하지만 다른 스레드가 필드의 값을 확인한다든가 아니면 동시에 이 메서드를 호출하는 상황이 발생하는 수 있으면 이 메서드는 함수형이 아니다.<br/>
이럴 때 이 메서드의 바디를 잠금함으로써 이 문제를 해결할 수 있으며, 이 메서드는 함수형이라고 할 수 있다.<br/>
즉, 멀티 코어 프로세서의 두 코어를 활용해서 메서드를 병렬로 호출할 수 없게 된다.<br/>

함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 그리고 이때 참조하는 객체는 불변 객체여야 한다.<br/>
즉, 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 참조해야 한다. <br/>

함수나 메서드가 어떤 예외도 일으키지 않아야 한다.<br/>
예외가 발생하면 이전에 설명할 것처럼 블랙박스 모델에서 return으로 결과를 반환할 수 없게 될 수 있기 때문이다.<br/>
어떤 입력값이 있을 때 이는 정확하게 하나의 결과로 도출되며 입력값이 undifiened라면 결과가 아에 안나오게 된다. <br/>
이처럼 비정상적인 입력값이 있을 때 자바에서 예외를 일으키는 것은 자연스러운 방식이지만, 블랙박스의 단순 모델이 깨지는 것이다.<br/>

![18-4](https://user-images.githubusercontent.com/87962572/144699342-03e9e294-0e95-4ede-af9e-5b5c08b25a8a.PNG)

이렇게 예외를 사요하지 않고 함수를 사용하려면 어떻게 해야될까?<br/>
바로 Optional< T >를 사용하면 이 문제를 해결 할 수 있고 예외 없이도 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못하엿는지 확인가능하다.<br/>
(하지만 그렇다고해서 모든 코드가 Optional을 반드시 사용하도록 고치라는 뜻은 아님)<br/>

마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.<br/>
즉, 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.<br/>

<h3>참조 투명성</h3>
'부작용을 감춰야한다'라는 제역은 참조 튜명성 개념으로 귀결된다.<br/>
즉, 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.<br/>
ex) "raoul".replace('r','R') 이라는 코드는 항상 같은 결과가 나오므로 STring.replace는 참조적으로 투명하다.<br/>

다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다.<br/>
따라서 Random.nextInt나 Scanner객체로 입력을 받는 것들은 참조 투명성을 위배한다.<br/>
하지만 두 개의 final int 변수를 더하는 연산에서는 두 변수를 바꿀수 없으므로 이 연산은 항상 같은 결과를 생성한다.<br/>

참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기억화 또는 캐싱을 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.<br/>

자바에서는 참조 투명성과 관련한 작은 문제가 있다.<br/>
ex) List를 반환하는 메서드를 두 번 호출한다고 가정하자.<br/>
두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조할 것이다.<br/>
결과 리스트를 순수값으로 사용할 것ㅇ라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주할 수 있다.
일반적으로 함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.

<h3>함수형 실전 연습</h3>
{1,4,9}처럼 List< Integer > 가 주어졌을 때 이것의 모든 서브 집합의 멤버로 구성된 List< List< Integer > > 를 만드는 프로그램을 만든다고 가정하자.
예를 들어, {1,4,9}의 서브 집합은 {1,4,9},{1,4},{1,9},{4,9},{1},{4},{9},{} 다.
빈 집합 {}를 포함해서 총 8개의 서브집합이 존재하며 각 서브집합은 List< Integer > 형식으로 이루어져 있으므로 최종 정답의 형식은 List <List < Integer > >다.

보통 {1,4,9}의 서브집합 중 1을 포함하는 집합과 아닌 집합으로 구분해서 문제를 풀려 시도할 것이다.
1을 포함하지 않는 부분집합은 {4,9}의 부분집합이고, 1을 포함하는 부분집합은 {4,9}의 모든 부분집합에 1을 포함시켜 얻을 수 있다.
이와 같은 접근 방식은 가장 쉽고 자연스러운 함수형 자바 프로그래밍이다.

```
// subsets자체도 기존의 구조를 갱신하지 않으므로 함수형이다.
static List<List<Integer>> subsets(List<Integer> list) {
 if (list.isEmpty()) {     ▶ 입력리스트가 비어있다면 빈 리스트 자신이 서브 집합니다.
    List<List<Integer>> ans = new ArrayList<>();
     ans.add(Collections.emptyList());
     return ans;
 }
 
 Integer fst = list.get(0);
 List<Integer> rest = list.subList(1,list.size());
 List<List<Integer>> subAns = subsets(rest);  ▶ 빈 리스트가 아니면 먼저 하나의 욧를 꺼내고 나머지 요소의 모든 서브 집합을 찾아서 subsets로 전달한다.
 List<List<Integer>> subAns2 = insertAll(fst, subAns); ▶ subans, subans2를 연결하면 정답이 완성된다.
 
 return concat(subAns, subAns2); 
}

static List<List<Integer>> insertAll(Integer fst, List<List<Integer>> lists) {
 List<List<Integer>> result = new ArrayList<>();
 for (List<Integer> list : lists) {
     List<Integer> copyList = new ArrayList<>();  ▶ 리스트를 복사한 다음에 복사한 리스트에 요소를 추가한다. 구조체가 가변이라도 저수준 구조를 복사하지 않는다.
     copyList.add(fst);
     copyList.addAll(list);
     result.add(copyList);
 }
 return result;
}

static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b) {
 List<List<Integer>> r = new ArrayList<>(a);
 r.addAll(b);
 return r;
}

```
입력으로 {1,4,9}를 제공하면 결과로 {},{9},{4},{4,9},{1},{1,9},{1,4},{1,4,9}를 얻게된다.
그리고 subset는 함수내에서 또 subset를 호출하고 반환하는 형식으로 구현이 되어잇거 수학접 귀납법의 인수처럼 처리되고있다.

concat함수는 순수함수이다. 내부적으로 리스트 r에 요소를 추가하는 변화가 발생하지만 반환 결과는 오로지 인수에 의해 이루어지며
인수의 정보를 변경하지 않는다.

<h2>재귀와 반복</h2>















