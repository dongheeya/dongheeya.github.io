Chapter 6. 스트림으로 데이터 수집

 자바 8의 스티림은 데이터 집합을 멋지게 처리하는 게으른 반복자라고 설명할 수 잇다.
 스트림의 연산은 filter 또는 map같은 중간 연산과 count, findFirst, forEach, reduce 등의 최종 연산으로 구분할 수 있다.
 중간 연산은 한 스트림을 다른 스트림으로 변환하는 연산으로서, 
 여러 연산을 연결할 수 있다.
 
 중간 연산은 스트림 파이프라인을 구성하며, 스트림의 요소를 소비하지 않는다.
 반면에 최종 연산은 스트림의 요소를 소비해서 최종 결과를 도출한다.
 최종 연산은 스트림 파이프라인을 최적화하면서 게산 과정을 짧게 생략하기도 한다.
 
 이 chapter에서는 collet역시 다양한 요소 누적 방식을 인수로 받아서 스트림을 최종 결과로 도출하는 리듀싱 연산을 수행할 수 있음을 설명한다.
 
 6.1 컬렉터란 무엇인가?
  - 함수형 프로그래밍에서는 무엇을 원하는 지 직접 명시할 수 있어서 어떤 방법으로 이를 얻을지는 신경 쓸 필요가 없다.
  - groupingBy를 이용해서 각 키 버킷 그리고 각 키 버킷에 대응하는 요소 리스트를 값으로 표현하는 맵을 만들라.는 동작을 수행한다.
  
  6.1.1 고급 리듀싱 기능을 구행하는 컬렉터.
  - collect는 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는 점이 최대 강점이다.
  - 구체적으로 설명해서 스트림에 collect를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다.
  - 내부적으로 리듀싱 연산이 일어나는 모습을 보여준다.
  명령형 프로그래밍에서는 우리가 직접 구현해야 했던 작업이 자동적으로 수행된다.
  - collect에서는 리듀싱 연산을 이용해서 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다.
  - 보통 함수를 요소로 변환할 떄는 컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다.
  
  6.1.2 미리 정의된 컬렉터
  - Collectors에서 제공하는 메서드의 기능은 크게 3가지로 구분할 수 있다.
  1) 스트림 요소를 하나의 값으로 리듀스하고 요약
  2) 요소 그룹화
  3) 요소 분할
  
 6.2 리듀싱과 요약
  - 메뉴 예제를 활용해서 Colleector 팩토리 클래스로 만든 컬렉터 인스턴스로 어떤 일을 할 수 잇는지 살펴본다!
  ex1) counting()이라는 팩토리 메서드가 변환하는 컬렉터로 메뉴에서 요리 수 를 계산한다.
   long howManyDishes = menu.stream().collect(Collectors.counting());
   long howManyDishes = menu.stream().count();
   
  6.2.1 스트립값에서 최댓값과 최솟값 검색
  메뉴에서 칼로리가 가장 높은 요리를 찾는다고 가정하자.
  Collectors.maxBy, Collectors.minBy 두 개의 메서드를 이용해서 스트림의 최댓값과 최솟값을 계산할 수 있다.
  두 컬렉터는 스트림의 요소를 비교하는데 사용할 Comparator를 인수로 받는다.
  다음은 칼로리로 요리를 비교하는 Comparator를 구현한 다음에 Collectors.maxBy로 전달하는 코드이다.
  
  Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
  Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));
  
  Optional<Dish>는 만약에 menu가 비어있다면 어떤 요리도 반환하지 않을 것이다.
  스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱이 자주 사용된다.
  이러한 연산을 요약연산이라고 부른다.
  
  6.2.2 요약 연산
  Collectors 클래스는 Collectors.summingInt라는 특별한 요약 팩토리 메서드를 제공한다.
  summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다.
  summingInt의 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환한다.
  그리고 summingInt가 collect메서드로 전달하면 요약 작업을 수행한다.
  다음은 메뉴 리스트의 총 칼로리를 계산하는 코드이다.
  
  int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
  
  Collectors.summingLong과 Collectors.summingDouble 메서드는 같은 방식으로 동작하며 각각 long또는 double 형식으로 요약한다는 점만 다르다.
  이러한 단순 합계 외에 평균값 계산 등의 연산도 요약 기능을 제공한다.
  Collectors.averagingInt, averagingLong, averageDouble등으로 다양한 형식으로 이루어진 숫자 집합의 평균을 계산할 수 있다.
  
  double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));
  
  지금까지 컬렉터로 스트림의 요소 수를 계산하고, 최댓값 최솟값을 찾고, 합계와 평균을 계산하는 방법을 살펴봤다.
  종종 이들 중 2개 이상의 연산을 한번에 수행해야될 때도 있다.
  
  IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
  
  위 코드를 실행하면 IntSummaryStatistics 클래스로 모든 정보가 수집된다.
  IntSummaryStatistics{count=9. sum=4300, min=120, avarage=477.77, max=800}
  
 
 6.2.3 문자열 연결
  컬렉터에 joining 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
  
  ex) 메뉴의 모든 요리명을 연결하는 코드이다.
  String shortMenu = menu.stream().map(Dish::getName).collect(joining());
  
  joining 메서드는 내부적으로 StringBuilder를 이용해서 문자열을 하나로 만든다.
  Disth클래스가 요리명을 반환하는 toSting 메서드를 포함하고 있다면 다음 코드에서 보여주는 것처럼 map부분을 생략할 수 있다.
  
  String shortMenu = menu.stream().collect(joining());
  
  문자열 간에 구분 문자열을 넣고 싶다면 
  String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
  
 6.2.4 범용 리듀싱 요약 연산
 Collectors.reducing으로 모든 컬렉터를 정의할 수 있다.
 예를들어 모든 메뉴의 칼로리를 합계한다면,
 int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i,j) -> i+j));
 
 reducing은 3개의 인수를 받는다.
 첫번째 인수는 리듀싱 연산의 시작값이거나 스트림에 인수가 없을때 반환하는 값이다.( 숫자 합계에서는 인수가 없을때 반환값으로 0이 적합하다.)
 
 두번째 인수는 요리를 칼로리 정수로 변환할 때 사용한 변환함수이다.
 세번쨰 인수는 같은 종류의 두 항목을 하나의 갓으로 더하는 BinaryOperator다. 예제에서는 두 개의 int가 사용되엇다.
 
 Optional<Dish> mostCalorieDish = menu.stream().collect(reducing((d1,d2) -> d1.getCaloreis() > d2.getCalories()? d1 : d2));
 
 한개의 
