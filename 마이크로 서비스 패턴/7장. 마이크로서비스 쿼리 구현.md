<h1>7장. 마이크로서비스 쿼리 구현</h1>

기존에 모놀리식 애플리케이션에서는 비교적 쉽게 쿼리를 구현하였다.<BR/>
개발자가 할 일은 SELECT문을 작성하고 필요한 인덱스를 정의하는 작업 정도였다.<BR/>
하지만 마이크로서비스 아키텍처에서는 의외로 쿼리를 작성하기가 어렵다.<BR/>
여러 서비스, 여러 DB에 분산된 데이터를 조회해야 하는데, 기존 분산 쿼리 메커니즘은 기술적으로 가능하다 해도 캡슐화에 위배되기 떄문에 사용할수가 없기 떄문이다.<BR/>

마이크로서비스 아키텍처에서는 2가지 패턴으로 쿼리를 구현한다.<BR/>
- API 조합 패턴: 서비스클라이언트가 데이터를 가진 여러 서비스를 직접 호풀하여 그 결과를 조합하는 패턴이다. 가장 단순한 방법이며, 가급적 이 패턴을 쓰는 것이 좋다.<BR/>
- CQRS (커맨트 쿼리 책임 분산) 패턴 : 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴이다. API 조합 패턴보다 강력한 만큼 구현하기는 더 복잡하다.<BR/>

<h2>7.1 API 조합 패턴 응용 쿼리</h2>


![7-1](https://user-images.githubusercontent.com/87962572/162004002-23387076-3a84-4ada-9b8c-4a711fff6b58.PNG)

위에 그림과 같이 마이크로서비스 아키텍처로 전환하게 되면 데이터가 주문/주방/배달/회계 서비스 영역으로 뿔뿔이 흩어지게 됩니다.<BR/>
그래서 클라이언트가 기존에 하나의 SELECT로 조인을 해왔던 것을 마이크로버시브에서는 모든 서비스에 데이터를 요청해야 하는 형태가 됩니다.<BR/>


![7-2](https://user-images.githubusercontent.com/87962572/162004387-80d3e6af-332e-4e1d-97bc-e0750beedcc3.PNG)

API 조합 패턴은 데이터를 가진 서비스를 호출한 후 그 반환 결과를 조합해서 가져옵니다.<BR/>
- API 조합기 : 프로바이더(provider) 서비스를 쿼리하여 데이터를 조회합니다.<BR/>
- 프로바이더 서비스 : 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스입니다.<BR/>

즉. api 조합기는 각 A, B, C라는 세 프로바이더 서비스에서 데이터를 조회한 후 그 결과를 조합합니다.<BR/>
이 패턴은 특정 쿼리 작업을 구현할 수 있을지 여부는 데이터가 어떻게 분할되었는지, 데이터를 가진 서비스기 어떤 API기능을 표출하는지, 사용 중인 DB는 어떤 기능을 제공하는 지 다양한 
요인에 따라 가변적입니다.<BR/>

<H3>API 조합 패턴으로 쿼리 구현</H3>

![7-3](https://user-images.githubusercontent.com/87962572/162005335-c1d15944-1279-4e60-acfa-620679a4f92b.PNG)

API 조합기는 쿼리를 REST 끝점으로 표출한 서비스이고, 위에 예에서는 orderId로 필요한 데이터를 가져올 수 있는 api끝점으로 조합 패턴을 구현하고 있습니다.<BR/>

API 조합 설계를 할때, 어느 컴포넌트를 쿼리 작업 API 조합기로 선정할지 <BR/>
그리고 어떻게 해야 효율적으로 취합 로직을 작성할 것인지 고려해야됩니다.<BR/>


이때 조합기를 선택할 때에 클라이언트가 외부에 있고 서비스가 위치한 네트워크가 느리다면 "API게이트웨이를 API조합기"만드는 것이 제격입니다.<BR/>
모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문입니다.<BR/>

![7-5](https://user-images.githubusercontent.com/87962572/162006352-2564adb9-1e6d-49d9-947d-55704064f48b.PNG)


또한, 쿼리 작업 반응 시간을 최대한 줄이려면 가능한 API조합기가 프로바이더 서비스를 병렬 호출해야 합니다.<BR/>
그렇다고 순차/병렬 서비스 호출이 뒤섞이면 실행 로직이 복잡해질 수 있으므로 리액티브 설계 기법을 동원해야 됩니다.(8장)<BR/>

<H3>API 조합 패턴의 장단점</H3><BR/>
- 오버헤드가 증가한다.<BR/>
- 가용성이 저하될 우려가 있다.<BR/>
- 데이터 일관성이 결여된다.<BR/>


<H2>CQRS 패턴</H2>
CQRS는 하나 이상의 쿼리가 구현된 하나 이상의 뷰 DB를 유지하는 기법입니다.<BR/>
CQRS는 API 조합 패턴으로 효율적으로 구현하기 어려운 쿼리 때문에 각광받기 시작했습니다.<BR/>

CQRS는 관심사의 분리/구분에 관한 패턴입니다.<BR/>
영속적 데이터 모델과 그것을 사용하는 모듀을 커맨드와 쿼리, 두 편으로 가릅니다.<BR/>
조회(R) 기능은 쿼리 쪽 모듈 및 데이터 모델에 생성/수정/삭제 기능은 커맨트 쪽 모듈 및 데이터 모델에 구현하는 것입니다.<BR/>


![7-8](https://user-images.githubusercontent.com/87962572/162007818-05d853fa-5322-4029-90b8-fb8e063e61aa.PNG)

CQRS는 서비스에서 커멘트 쪽 도메인 모델은 CRUD 작업을 처리하고 자체 DB에 매핑합니다.<BR/>
그리고 커맨트 쪽은 데이터가 바뀔 때마다 도메인 이벤트를 발행합니다.<BR/>
쿼리쪽은 반드시 지원해야 하는 쿼리에 대해서는 모든 종류의 DB를 지원합니다.<BR/>


![7-9](https://user-images.githubusercontent.com/87962572/162008928-38dbc1af-1ae1-41f0-936d-3c434d4cb8b2.PNG)

쿼리 서비스에는 커맨드 작업이 전혀 없는 오직 쿼리 작업만드로 구성되어있고, 하나 이상의 서비스가 발행한 이벤트를 구독해서<BR/>
항상 최신 상태로 유지되는 DB를 쿼리하는 로직으로 구현됩니다.<BR/>

따라서 CQRS 쿼리 쪽은 이벤트를 구독해서 거의 실시간으로 업데이트합니다.

<H3>CQRS의 단점</H3>
-아키텍처가 복잡하다.<BR/>
-복제 시차를 신경 써야 한다.<BR/>

커맨트/쿼리 양쪽 API가 클라이언트에 버전 정보를 전달하여 김빠진 데이터를 분간할 수 있게 만드는 것이 단점을 보완할 한가지 방법이다.<BR/>

<H3>SQL VS NoSQL DB</H3>
NoSQL DB는 대부분 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력은 없지만, 어떤 유스 케이스는 유연한 데이터 모델, 우수한 성능/확장성 등 sql 기반 db보다 낫습니다.
