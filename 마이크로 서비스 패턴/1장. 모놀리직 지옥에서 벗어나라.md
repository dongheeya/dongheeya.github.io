<h1>1장. 모놀리직 지옥에서 벗어나라.</h1>

<h2>1.1 서서히 모놀리식 지옥에 빠져들다.</h2>

<h3>모놀리식 아키텍처의 장점</h3>
- 개발이 간단하다. : 단일 애플리케이션 구축에 초점이 맞춰져 있다.<br/>
- 애플리케이션을 쉽게 변경할 수 있다. : 코드, DB 스키마를 변경해서 빌드/배포하기 용이합니다.<br/>
- 테스트하기 쉽다. : 개발자가 애플리케이션을 띄우고, REST API를 호출하고, 셀레늄으로 UI를 시험하는 종단 간 테스트를 작헝한다.<br/>
- 배포하기 쉽다 : 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사하면 그만이다.<br/>
- 확장하기 쉽다 : 부하 분산기 뒷면에 애플리케이션 인스턴스를 여러 개 실행한다.<br/>

<h3>모놀리식 지옥의 실상</h3>
추가 구현할 스토리가 늘어났고 그만큼 코드베이스와 관리 오버헤드 역시 증가했다.<br/>
아키텍처가 커질수록 모놀리식 지옥에 빠져 애자일식 개발/배포가 불가능하다.<br/>
어느 개발자도 내용이 방대해서 버그를 고치고 새기능을 정확하게 구현하기가 힘들고 시간이 오래걸리다.<br/>

개발자가 일상적인 개발 업무도 더디게 진행되게되고 개발자 IDE의 실행 속도도 느려지고, 자연스럽게 빌드 시간도 오래걸릳나.<br/>

지속적인 배포가 불가능하고 소스 병합도 어렵고 배포전에 서버에 전체 테스트 스위트를 한번씩 돌려봐야하는 상황이 발생한다.<br/>

각기 다른 모듈마다 리소스 요건이 맞지 않아 확장하기 어렵다.<br/>

애플리케이션 자체가 워낙 덩치가 커서 철저하게 테스트하기 어렵고 그래서 버그가 발생하기 쉽고, 신뢰성이 부족하게 된다.<br/>

새로운 프로그래밍 언어를 받아들이기 어렵다.<br/>

<h2>1.4 마이크로서비스 아키텍처가 답이다.</h2>

![1-3](https://user-images.githubusercontent.com/87962572/153189454-32cfef02-c5b1-4463-ac87-8fb5f2618090.PNG)

X축 확장 : 다중 인스턴스에 고루 요청 분산

X축 확장 : 일반적인 모놀리식 애플리케이션의 확장 수단이다.<br/>
부하 분산기 뒷면에 애플리케이션 인스턴스를 N개 띄어놓고 부하 분사기를 들어오는 요청을 이들 인스턴스에 고루 분배한다.<br/>

Z축 확장 : 요청 속성별 라우팅<br/>
X축 확장에서 인스턴스 단위로 부하를 분산시켰지만, 분산 이전에 라우터를 통해서 지정된 인스턴스별로도 요청을 나눔으로써, 트랜잭션이나 데이터볼륨을 처리하기 위한 확장방안으로 볼 수 있다.<br/>

Y축 확장 : 기능에 따라 애플리케이션을 서비스로 분해<br/>
X축과 Z축은 어플리케이션의 가용성을 높였지만 복잡성은 해결시킬 수 없다. Y축확장은 모놀리식 어플리케이션을 여러 서비스로 나누는것을 의미한다.<br/>

![1-6](https://user-images.githubusercontent.com/87962572/153189875-46b72936-1b18-440f-a3d2-71b95ce37265.PNG)

마이크로서비스는 여러 사람이 이해하고 개발할 수 있게 애플리케이션을 여러 모듈로 분해한다.<br/>
그래서 독립적으로 배포/확장할 수 있는 부가적인 장점이 있다.<br/>

서비스별로 DB가 따로 있어 개발자 본인이 담당한 서비스 스키마를 다른 서비스 담당자와 협의하지않고 변경할 수 있다.<br/>

![1-7](https://user-images.githubusercontent.com/87962572/153190145-be09cdf4-e2dc-479f-845e-0b969d6d9823.PNG)

따라서 각 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있고, 개발자가 타 서비스의 API를 우회하거나 그 내부 요소에 직접 접근할 수 없기 때문에 모듈성 유지 차원에서도
적합하다.

<h2>마이크로서비스의 장단점</h2>

<h3>단점</h3>
- 딱 맞는 서비스를 찾기가 쉽지 않다.<br/>
- 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어렵다.(서비스마다 DB가 따로있으므로 다중 DB에 접속하여 조회하고 트랜잭션을 구하기가 어렵다.)<br/>
- 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야 한다.<br/>
- 마이크로서비스 아키텍처 도입 시점을 결정하기가 어렵다.<br/>

<h2>마이크로서비스 아키텍처 패턴 언어</h2>
애플리케이션에 모놀리식 아키텍처가 잘 맞을지, 마이크로서비스 아키텍처가 잘 맞을지 결정하려면 수많은 트레이드오프를 검토해야 한다.<br/>

<h3>패턴 및 패턴 언어</h3>
패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법이다.<br/>
패턴 언어는 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합이다.<br/>

패텬은 자신의 적용되는 맥락을 반드시 기술해야 한다는 점에서 가치가 크다.<br/>
패턴이 제시한 솔루션이 어떤 맥락에서는 통하지만 또 다른 맥락에서는 전혀 통하지 않을 수 있다는 생각 덕분에 더 나은 방법으로 기술을 논의할 수 있게 되었다.<br/>

- 강제 조항<br/>
- 결과 맥락<br/>
- 연관 패턴<br/>

<h4>강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈</h4>
주어진 맥락에서 문제를 해결하고자 할 떄 반드시 처리해야 할 강제 조항<br/>
상충하는 강제 조항이 있기 때문에 모든 조항을 전부 충족할 수 없고, 어느 조항이 더 중요한지는 맥락에 따라 다르므로 우선순위를 정해야 한다.<br/>

<h4>결과 맥락: 패턴 적용 결과</h4>
결과 맥락은 솔루션을 편견에 치우치지 않은, 좀 더 완전한 시야로 바라보게 한다.<br/>
그래서 더 나은 설계 결정을 내릴 수 있다.<br/>

- 장점 : 해결된 강제 조항 등 패턴의 좋은 점<br/>
- 단점 : 해결된 강제 조항 등 패턴의 나쁜 점<br/>
- 이슈 : 패턴 적용 시 발생한 새로운 문제점<br/>

<h4>연관 패턴 : 다섯 가지 관계 유형</h4>
한 패턴과 다른 패턴의 관계를 기술하는 영역<br/>
- 선행자 : 이 패턴을 필요하게 만든 선행 패턴.<br/>
- 후행자 : 이 패턴으로 야기된 이슈를 해결하는 패턴.<br/>
- 대안 : 이 패턴의 대체 솔루션을 제공하는 패턴 둘 중 하나를 선택해야함.<br/>
- 일반화 : 문제를 해결하는 일반적인 솔루션에 해당하는 패턴<br/>
- 세분화 : 특정 패턴을 더 세부적으로 나타낸 형태<br/>


<h3>마이크로서비스 아키텍처 패턴 언어 개요</h3>
패턴 언어는 모놀리식 아키텍처 및 마이크로서비스 아키텍처의 구조와 장단점을 기술하기 때문에 무엇보다 마이크로서비스 아키텍처를 사용하는 것이 옳은 일인지 결정할 때 요긴하다.<br/>
이렇게 검토한 결과, 마이크로서비스 아키텍처가 앺를리케이션에 적합한 것으로 판단되면 패턴 언어를 이용하여 다양한 아키텍처/설계 잇ㅍ를 해결하고 효과적으로 활요할 수 있다.<br/>

패턴은 3가지 계층으로 분류된다.<br/>
- 인프라 패턴 : 주로 개발 영역 밖의 인프라 문제를 해결합니다.<br/>
- 애플리케이션 인프라 : 개발에도 영향을 미치는 인프라 문제를 해결합니다<br/>
- 애플리케이션 패턴 : 개발자가 맞닥뜨리는 문제를 해결합니다.<br/>

<h4>통신 패턴</h4>
서비스 상호 간, 그리고 외부 세계와 어떻게 통신하면 좋을지 아키텍처/설계 관점에서 다양한 의사 결정을 해야한다.<br/>
통신 패턴은 크게 5가지 그룹으로 정리할 수 있다.<br/>

- 통신 스타일 : 어떤 종류의 IPC를 사용하는가?<br/>
- 디스커버리 : 서비스 클라이언트는 서비스 인스턴스의 IP 주소를 어떻게 가져오는가?<br/>
- 신뢰성 : 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장하는가?<br/>
- 트랜잭셔널 메시징 : 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메세지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?<br/>
- 외부 API : 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?<br/>

<h4>트랜잭션 관리를 위한 데이터 일관성 패턴</h4>
마이크로서비스는 각자 DB를 갖고 서로 느슨하게 결합한다. <br/>
사가 패턴에 따라 데이터 일관성을 유지해야 한다. (4~6장)<br/>

<h4>데이터 쿼리 패턴</h4>
서비스 데이터는 오직 그 서비스의 API를 통해서만 접근할 수 없기 때문에 DB에 분산 쿼리를 사용할 수 없다.<br/>
- API 조합 패턴은 하나 이상의 서비스를 호출해서 그 결과를 조합<br/>
- CQRS 는 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리하는 방식<br/>

<H4>서비스 배포 패턴</H4>
개발자가 단순한 UI로 서비스를 배포/관리하고, 가상 머신, 컨테이서, 서버리스 기술을 응용한 배포 플랫폼이 바람직하다.

<H4>관측성 패턴: 애플리케이션 동작 파악</H4>
마이크로서비스 아키텍처는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파일 하나만으로는 원인을 파악할 수 없고,<br/>
문제의 원인을 찾고 진단하기가 매우 복잡합니다.<br/>
지연 시간도 짚어 보아야 할 대상이 많아 원인을 특정하기가 까다롭습니다.<br/>

- 헬스 체크 API : 서비스 헬스를 반환하는 끝점을 표출합니다.<br/>
- 로그 수집 : 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공합니다.<br/>
- 분산 추적 : 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적합니다.<br/>
- 예외 추적 : 예외가 발생하면 예외 추적 서비스에 보고합니다.<br/>
- 애플리케이션 지표 : 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출합니다.<br/>

<H4>서비스 테스트 자동화 패턴</H4>
단위 서비스 크기가 비교적 작아서 테스트하기 쉽지만, 서로 다른 여러 서비스가 조화롭게 잘 작동되는지 테스트하는 일이 중요합니다.<br/>
서비스를 따로 분리해서 테스트하는 테스트 단순화 패턴이 필요합니다.<br/>
- 컨슈머 주도 계약 테스트<br/>
- 컨슈머 쪽 계약 테스트<br/>
- 서비스 컴포넌트 테스트<br/>

<H4>횡단 관심사 처리 패턴</H4>
마이크로서비스 섀시 패턴을 적용하여 서비스를 구축하는 편이 바람직하다.(11장)<br/>

<H4>보안 패턴</H4>
일반적으로 마이크로서비스 아키텍처에서는 API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달합니다.

<H2>1.7 마이크로서비스 너머 : 프로세스와 조직</H2>
크기가 N인 팀의 소통 오버헤드는 N^2으로 증가한다.<br/>
팀이 너무 커지면 소통 오버헤드가 급격히 증가하여 운영 효율성이 떨어진다.<br/>

규모가 큰 팀을 여러 팀으로 나누는 것이 좋다.(8~12명)<br/>
비스니스 곤점에서 팀의 목표를 정하고 비즈니스 능력이 구현된 하나 이상의 서비스를 개발/운영하는 것이다.<br/>
범기능팀을 구성하면 다른 팀과 매번 소통할 필요도 없고, 서비스를 독자적으로 개발,테스트,배포할 수 있다.<br/>

개발 조직도 확장성이 좋아진다.<br/>
팀을 늘려 조직을 키울 수 있고, 어떤 팀 하날가 너무 커지면 연관된 서비스 단위로 다시 팀을 나누면 된다.<br/>

지속적 전달의 핵심은 소프트웨어를 언제라도 릴리스할 수 있는 능력이다.<br/>
따라서 자동화 테스트 등 높은 수준의 자동화는 필수입니다.<br/>
지속적 배포는 이보다 한 발 더 나아가 릴리스 가능한 코드를 프로덕션에 자동 배포하는 것이다.<br/>

