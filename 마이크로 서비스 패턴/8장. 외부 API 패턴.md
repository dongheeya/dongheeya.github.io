<H1>8장. 외부 API 패턴</H1>

배경 : 모놀리식 애플리케이션은 그 자체의 API가 클라이언트에 표출되지만, 마이크로서비스로 배포하며 서비스마다 API를 갖고 있기 때문에 어떤 종류의 <BR/>
API를 클라이언트에 표출해야 할지 결정해야 합니다.<BR/>

애플리케이션의 외부 API는 클라이언트 종류가 다양한 만큼 설계하기가 어렵습니다.<BR/>
성격이 다른 클라이언트마다 다른 데이터를 요구하기 때문입니다.<BR/>

그래서 이때에 어떤 외부 API 설계 이슈가 있는지 그리고 외부 API 패텬(API 게이트웨이, BFF) 및  설계/구현 방법을 설명합니다.<BR/>

<H2>8.1 외부 API 설계 이슈</H2>
윕 애플리케이션은 방화벽 내부에서 실행되기 떄문에 대역폭이 높고 지연시간이 짧은 LAN을 통해서 서비스를 접속하지만.<BR/>
다른 클라이언트는 방화벽 외부에 있으므로 상대적으로 대역폭이 낮고 지연이 높은 인터넷 혹은 모바일 네트워크 환경에서 서비스에 접근합니다.<BR/>

![8-1](https://user-images.githubusercontent.com/87962572/163191474-f7c1bc4f-9f3d-47f9-9558-5aeeb072bae9.PNG)

마이크로서비스 아키텍처는 클라이언트가 직접 호출하도록 API를 설계하지 않습니다.<BR/>
이유는 <BR/>
1. 서비스 API가 잘게 나뉘어져 있어 클라이어트가 필요한 데이터를 가져오려면 여러번 요청해야 합니다. 효율 ↓<BR/>
2. 클라이언트가 서비스 및 API를 알아야해서 캡슐화 X , 아키텍처와 API구조를 바꾸기 어려워짐<BR/>
3. 사용성의 저하와 실용적이지 않음<BR/>

따라서 마이크로서비스에서는 아래와 같이 설계합니다.

![8-2](https://user-images.githubusercontent.com/87962572/163192035-4d930fd5-7201-4f81-aee5-3ad59d420966.PNG)

모바일 앱이 여러 서비스를 호출해서 그 결과를 조합하는 API 조합기 역하을 맡은 것이고 이렇게 하는 것도 나쁘지 않지만<BR/>
문제점이 발생합니다.<BR/>

1. 여전히 클라이언트가 여러번 전송한다.<BR/>
2. 캡슐화가 안됨<BR/>
3. 클라이언트가 소비하기 어려운 프로코롤을 사용하는 서비스인경우가 발생<BR/>


<H2>8.2 API 게이트웨이 패턴</H2>

![8-3](https://user-images.githubusercontent.com/87962572/163192518-f8b0345b-4167-44b0-84ae-4f3a75b4e270.PNG)

API 게이트웨이는 방화벽 외부의 클라이언트가 애플리케이션에 API 요청을 하는 단일 창구 여갈을 하는 서비스입니다.<BR/>
그래서 내부 애플리케이션 아키텍처를 캡슐화하고 자신의 클라이언트에는 API를 제공합니다.<BR/>
또한 인증, 모니터링, 사용량 제한 등 부수적인 일도 담당합니다.<BR/>

API 게이트웨이는 "요청 라우팅", "API 조합", "프로토콜 변환"을 관장합니다.<BR/>
외부 클라이언트의 API 요청은 모두 API 게이트웨이로 향하고, API 게이트웨이는 적절한 서비스로 요청을 보냅니다.<BR/>

1.요청 라우팅 : 요청이 들어오면 게이트웨이가 라우팅 맵을 찾아보고 어느 서비스로 요청을 보낼지 결정합니다.<BR/>
2. API조합 : API 게이트웨이는 모바일 앱이 요청을 한 번 하면 여러 서비스에서 주문 내역의 데이터를 조회합니다.<BR/>

![8-4](https://user-images.githubusercontent.com/87962572/163193238-dfbe43e0-a92a-4a41-a852-fa3ea14e5c65.PNG)

3. API 게이트웨이는 클라이언트마다 적합한 API를 제공한다.<BR/>
4. 엣지 기능 구현 (= 주변 기능 구현) : 인증. 인가, 캐싱, 사용량 제한 지표 수집, 요청 로깅등의 역할을 합니다.<BR/>
- 엣지 기능 구현된 곳은 3곳입니다.<BR/>
- A. 벡엔드 서비스 : 캐싱, 지표 수집, 인증과 같은 기능은 사실상 "요청이 서비스에 도달하기 전에 미리 애플리케이션이 요청을 인증"합니다.<BR/>
- B. API 게이트웨이 상류 : 요청이 들어오기 전에 처리합니다.<BR/>
- C. 전용 엣지 서비스<BR/>


![8-5](https://user-images.githubusercontent.com/87962572/163194249-7a4d9d81-8276-48e4-84e2-59422689d6f8.PNG)

API계층에서는 독립적인 API모듈이 있고, 각 API모듈에서는 특정 클라이언트용 API가 구현되어있고 공통계층에서는 엣지 기능등 공통 기능을 구현합니다.

<H3>BFF패턴</H3>

각 클라이언트 종류마다 책임소재를 명확하게 하기 위해서 API게이트웨이를 따로 구현합니다.

![8-6](https://user-images.githubusercontent.com/87962572/163194728-bf8c062b-db66-442c-aca2-478e56783858.PNG)

![8-7](https://user-images.githubusercontent.com/87962572/163194785-df2f5b99-d989-4f76-9a11-7adb0f00a3b4.PNG)


<H3>API 게이트퉤이으 장단점</H3>
장점 : 애플리케이션의 내부 구조를 캡슐화한다는 것입니다.
특정 서비스 호출할 필요 없이 무조건 게이트웨이에 이야기를 하면됩니다.

단점 : 고가용 컴포넌트가 하나 더 늘어나는 부담을 감수해야 됩니다.
API 게이트웨이가 개발 병목 지점이 될 우려도 있습니다.




