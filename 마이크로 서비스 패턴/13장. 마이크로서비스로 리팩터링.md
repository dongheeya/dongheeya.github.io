<h1>13장. 마이크로서비스로 리팩터링</h1>

<h2>13.1 마이크로서비스 리팩터링 개요</h2>

마이크로서비스로의 리팩터링을 고민해야되는 이유를 우선 따져보자.

<h3>13.1.1 모놀리스를 왜 리팩터링하는가?</h2>
마이크로서비스 아키텍처는 여러모로 장점이 많습니다.<br/>
유지보수성, 테스트성, 배포성이 우수하고 개발을 빨리 할 수 있으며, 확장성도 우수하고 오류 격리도 잘 됩니다.<br/>
그래서 기술 스택을 발전시키기오 휠씬 쉽습니다.<br/>

하지만 모놀리스를 마이크로서비스로 리팩터링하는 작업은 매우 고됩니다.<br/>
무엇보다 새 기능 개발에 필요한 리소스를 분산됩니다.<br/>

필요한 이유?<br/>
- 느린 전달 : 애플리케이션을 이해, 관리, 테스트하기가 어려워서 개발자의 생산성이 떨어집니다.<br/>
- 버그 투성이 소프트웨어 릴리스 : 테스트의 결여는 곧 소프트웨어 릴리스가 버그 투성일 떄가 많다는 뜻이고 이는 회사의 타격이며 고객에게는 서비스의 불만족으로 귀결됩니다.<br/>
- 나쁜 확장성 : 모놀리식 애플리케이션은 리소스 요건이 전혀 다른 모듈을 하나의 실행 가능한 컴포넌트로 조합되기 때문에 확장이 어렵습니다. 그리고 비용이 많이 듭니다.<br/>

<h3>13.1.2 모놀리스 옥죄기</h3>
애플리케이션 아키텍처를 모놀리식에서 마이크로서비스로 전환하는 프로세스는 애플리케이션 현대화의 한 가지 형태입니다.<br/>
지난 수십 년간 많은 개발자가 실시한 애플리케이션 현대화는 레거시 애플리케이션을 현대 아키텍처와 최신 기술 스택이 접목된 애플리케이션으로 바구는 과정입니다.<br/>

이때 "완전히 뜯어고치기"를 삼가라고합니다.<br/>

즉, 새로은 아키텍처의 애플리케이션을 개발한답시고 기존 애플리케이션을 완전히 뜯어고치는 일은 하지 말라는 것입니다.<br/>
이는 매우 리스크가 크고 결국 실패하는 프로젝트가 될 가능성이 높습니다.<br/>

따라서, "단계적"으로 리팩터링을 하는 것이 좋습니다.<br/>

<img width="374" alt="13-1" src="https://user-images.githubusercontent.com/87962572/164979705-624eaa5a-2ad9-4ebc-9a63-cd7ba0f74a51.png">

<h4>스트랭글러 애플리케이션 패턴</h4>
기존 애플리케이션과 함께 실행되면서 새로운 마이크로서비스 애플리케이션을 조금씩 빌드한 스트랭글러 애플리케이션을 개발하는 것입니다.<br/>
시간이 지날수로 모놀리식에 구현된 기능은 점점 가짓수가 줄어 완전히 없어지거나 또 다른 마이크로서비스가 됩니다.<br/>

모놀리스를 쪼개는 것보다 영업 이익 산출 등 더 중요한 작업이 많은 경우 이러한 과정은 네버엔딩이 될 수 있고 모놀리스가 특별히 걸림돌이 되지 않는다면 그냥 냅둬도 된다.<br/>

<h4>값을 조기에 자주 검증</h4>
모놀리스를 조금식 리팩터링하면서 새로운 기술 스택과 고속의 최신 데브옵스 스타일로 신규 서비스를 각각 개발/전달하는 것입니다.<br/>
덕분에 팀의 전달 속도는 점점 늘어날 것입니다.<br/>

"애플리케이션에서 가치가 큰 부분을 먼저 마이크로서비스로 이전하는 것도 방법이다."<br/>
그러면 그만큼 독립적인 개발 속도가 빨라지고 새로운 알고리즘을 더 자주 배포해서 효용성을 평가해 볼 수도 있습니다.<br/>

<h4>모놀리스 변경 최소화</h4>
- 추출된 서비스에 있는 데이터를 모놀리스 DB로 복제하거나(13.2.3절)<br/>
- 서비스 추출순서를 잘 조정하는 방법이 있다.(13.3.2절)<br/>

<h4>기술 배포 인프라:모든 것이 다 필요한 것이 아니다.</h4>
인프라 개발에 필요한 선행 투자를 최소화하고 반드시 있어야 할 것은 테스트 자동화 배포 파이프라인이 유일합니다.<br/>
정교한 배포 인프라와 관측성 인프라는 당장 없어도 되며 실제로 새로운 아키텍처를 경험해보기 전에 막대한 투자가 필요한 기술은 나중으로 미루는 것이 좋다.<br/>


<h2>13.2 모놀리스 -> 마이크로서비스 리팩터링 전략</h2>

마이크로서비스로 교체하는 3가지 전략<br/>
1. 새 기능을 서비스로 구현합니다.<br/>
2. 표현 계층과 백엔드를 분리합니다.<br/>
3. 기능을 여러 서비스로 추출해서 모놀리스를 분해합니다.<br/>

1번은 모놀리스 성장을 중단하기 위한 전력이다.<br/>
2~3번은 모놀리스 분해에 관한 전략입니다.<br/>

기능을 모놀리스에서 스트랭글러 애플리케이션으로 전환하는 3번 전략은 반드시 필요하다.<br/>

<h3>13.2.1 새 기능을 서비스로 구현한다.</h3>
이미 거대하고 복잡해진 모놀리식 애플리케이션에 새 기능이 구현된 코드는 더 이상 추가하지 마세요.

모놀리식을 마이크로 서비스로 전환할 때에는 새 기능을 서비스로 구현하는 작업부터 실천하는 것이 좋습니다.

<h4>새 서비스를 모놀리스에 연계</h4>
- API 게이트웨이 : 기존 요청은 모놀리스로 각각 라우팅합니다.<BR/>
- 통합 글루 코드 : 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합니다.<BR/>

<H4>새 기능을 서비스로 구현하는 시점</H4>
모두다 스트랭글러 애플리케이션에 구현할 수 있는것은 이상적이지만 새 서비스부터 구현하는 것이 현실적이다.<BR/>

<img width="383" alt="13-2" src="https://user-images.githubusercontent.com/87962572/164980323-907d0093-7974-4ca7-8a0d-ff084099fae1.png">

마이크로서비스는 본직적으로 비즈니스 능력 위주로 구성된 '느슨하게 결합된 서비스'입니다.<BR/>

데이터를 일관성을 유지하는 것도 문제입니다.<BR/>
새 기능을 서비스로 구현할 수 없다면, 일단 모놀리스에 새로운 기능을 구현합니다. 나중에 다른 관련 기능과 함께 해당 기능을 자체 서비스로 추출할 수 있습니다.<BR/>

새 기능을 서비스로 구현하면 개발 속도가 향상되고 모놀리스를 수평적으로 쪼개도 개발 속도를 높이는 데 도움이 됩니다.<BR/>

<H3>13.2.2 표현 계층과 백엔드를 분리한다.</H3>
표현 계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면 모놀리식 애플리케이션의 덩치를 줄일 수 있습니다.

- 표현 계층 : HTTP 요청을 처리해서 웹 UI에 전달한 HTML 페이지를 생성하는 모듈로 구성되며 사용자 인터페이스가 정요한 애플리케이션은 표현 계층 코드가 대부분이다.<BR/>
- 비즈니스 계층 :엔터프라이즈 애플리케이션 특성상 복잡한 비즈니스 규칙이 구현된 모듈로 구성됩니다.<BR/>
- 데이터 접근 로직 : DB, 메시지 브로커 등 인프라 서비스에 접근하는 모듈로 구성됩니다.<BR/>

<img width="433" alt="13-3" src="https://user-images.githubusercontent.com/87962572/164980523-1d88f998-0b34-4fda-9bd6-492775ed1577.png">

벡엔드, 프론트엔드를 분리하면 독립적으로 배포할 수 있고 서비스가 호출하는 API가 표출된다.<BR/>
표현계층(A)와 비즈니스/데이터 접근 로직(B)로 나눠서 분리한 후에는 A가 B를 원격 호출합니다.<BR/>

<H4>장점</H4>
1. A/B애플리케이션을 서로 독립적으로 배포/개발/확장할 수 있습니다.<BR/>
2. 나중에 개발할 마이크로서비스가 호출할 수 있는 원격 API가 표출됩니다.<BR/>

하지만 이또한 완전한 해결책은 아니다.  -> 3번 전략이 필요하다.<BR/>

<H3>13.2.3 기능을 여러 서비스로 추출한다.</H3>
새 기능을 서비스로 구현하고 백엔드에서 프런트엔드 웹 애플리케이션을 떼어 내는 것만으로는 한계가 있다.<BR/>
-> 모놀리스가 가진 비즈니스 능력을 하나씩 서비스로 옮기는 분해 전략을 구사하자.<BR/>

모놀리스를 나누는 기능은 다음과 같다.<BR/>
- API 끝점이 구현된 인바운드 어댑터<BR/>
- 도메인 로직<BR/>
- DB 접근 로직 등이 구현된 아웃바운드 어댑터<BR/>
- 모놀리스의 DB 스키마<BR/>

<img width="433" alt="13-4" src="https://user-images.githubusercontent.com/87962572/164980803-3a488020-7abc-4ae2-9a0f-4ac55f5fe866.png">

서비스를 추출해서 모놀리스를 쪼갠다.<BR/>
비즈니스 로직과 어댑터로 구성된 기능 덩이를 찾아내 서비스 추출(즉, 코드 서비스 내부로 이전)하다.<BR/>
새로 추출된 서비스와 모놀리스는 통합 글루가 제공한 API를 통해 협동한다.<BR/>

<H4>도메인 모델 분리</H4>
서비스를 추출하기 위해 먼저 모놀리스 모델에서 서비스의 도메인 모델을 추출합니다.<BR/>
서비스 인스턴스는 보통 하나의 프로세스 이기 때문에 서비스 경계를 넘나드는 객체 레퍼런스가 있을 수 없습니다.<BR/>

<img width="367" alt="13-5" src="https://user-images.githubusercontent.com/87962572/164980944-df0d2dfc-e4fb-4282-a09c-d2ab126a7c59.png">

<img width="379" alt="13-6" src="https://user-images.githubusercontent.com/87962572/164980948-a3e7e4e7-b644-42ab-b991-3ae919e2b001.png">

서비스를 넘나드는 객체 레퍼런스를 제거하고 독립시킨 다음에 기본키로 대체하자.<BR/>
이러한 변경사항은 사소하다고 할수도있지만, 객체 레퍼런스를 참조하는 클라이언트에는 큰 영향을 미칠 수도 있다.<BR/>
따라서, "서비스와 모놀리스 간에 데이터를 복제"하면 변경 범위를 줄일 수 있다.<BR/>


<H4>DB 리팩터링</H4>
도메인 모델은 단순히 코드만 변경한다고 나누어지는 것이 아닙니다.<BR/>
따라서 모놀리스에서 서비스를 추출하는 것은 데이터도 함께 이전한다를 의미하며, 모놀리스에 있던 DB 테이블도 서비스 DB로 옮겨야 합니다.<BR/>

또 엔터티를 나누려면 해당 DB 테이블도 분리해서 서비스로 이전해야 합니다.<BR/>

<H4>변경 범위를 줄이기 위해 데이터 복제</H4>
모놀리스에서 예를들어 Order 엔티티를 분리해서 Delivery 엔티티를 추출하는 작업만 해도 새로 이전한 필드를 참조하는 코드를 모조리 찾아 고쳐햐 합니다.<BR/>

DB리팩터링에서 가장 큰 장애물은 전체 DB클라이언트가 새 스키마를 사용하도록 바꾸는 일입니다.<BR/>
그래서 해결책은 전이 기간 동안에는 원본 스키마를 유지하되, "원본 스키마와 신규 스키마를 동기화하는 트리거"를 사용하는 것입니다.<BR/>

<img width="429" alt="13-7" src="https://user-images.githubusercontent.com/87962572/164981229-85747475-3d07-4f81-b6c1-7db74b1138bc.png">


<H4>어떤 서비스를 언제 추출하나</H4>
일단 추출시 가장 큰 혜택이 큰 서비스에 집중해야되며<BR/>
마이크로서비스 전환이라는 긴 여행은 시간별로 구획된 아키텍처 정의부터 시작하는 것이 중요합니다.<BR/>

<H5>전략</H5>
1. 모놀리스 개발 동결하고 요건이 있을 때마다 서비스를 추출해라.<BR/>
2. 좀 더 계획적인 접근 방식으로 서비스 추출 시 기대되느 혜택을 애플리케이션 모듈별로 순위를 매겨 서비스로 추출합니다.<BR/>

<H2>13.3 서비스와 모놀리스 간 협동 설계</H2>
모놀리스에서 서비스를 추출하면 원래 ACID 트랜잭션에 묶여 있던 코드로 함께 분리되는데, 데이터 일관성이 그대로 계속 유지되도록 잘 살펴야 합니다.<BR/>

"통합 글루 코드"가 서비스와 모놀리스 상호 작용을 관장합니다.<BR/>
요건에 따라 서비스와 모놀리스 REST 또는 메시징으로 상호 작용하며, 그 밖에 다른 IPC로 통신할 수 있습니다.<BR/>

<img width="427" alt="13-9" src="https://user-images.githubusercontent.com/87962572/164981641-e9a60dac-0bfb-45f9-87a2-78ae2530fc17.png">


<H3>13.3.1 통합 글루 설계</H3>
추출된 서비스와 모놀리스가 협동할 수 있게 통합 글루도 개발해야 합니다.<BR/>
통합 글루는 특정 IPC를 이용하는 코드를 서비스 및 모놀리스 양쪽에 구성합니다.<BR/>

<img width="436" alt="13-8" src="https://user-images.githubusercontent.com/87962572/165521382-efb8a6c2-a626-472e-8e64-b571db44fb47.png">

서비스와 모놀리스 사이의 데이터 일관성을 유지하기 위해 경우에 따라 시가로 데이터 일관성을 맞추어야 할 경우도 있습니다.<BR/>

서비스와 모놀리스 상호 작용은 "통합 글루 코드"를 권장하고 있으며 IPC로 통신하는 어댑터로 구성된 통합글루입니다.<BR/>

<H4>13.3.1 통합 글루 설계</H4>
통합 글루는 특정 IPC를 이용하는 코드를 서비스 및 모놀리스 양쪽에 구성하고 사용하는 IPC 종류마다 구조가 다릅니다.<BR/>

<H5>통합 글루 API 설계</H5>
통합 글루를 설계하려면 우선 도메인 로직에 어떤 API를 제공할지 결정해야 합니다. (이에 따라 스타일이 달라짐)<BR/>
그리고 서비스의 비즈니스 로직은 통합 글루가 어떤 IPC로 정보를 조회할지 알 필요가 없으니 캡슐화를 사용하는 것이 좋습니다.<BR/>

<H5>상호 작용 스타일과 IPC 선택</H5>
어느 한쪽이 상대방의 데이터를 조회해야 한다면 몇 가지 옵션이 있습니다.<BR/>

1. 리포지터리 인터페이스를 구현한 어뎁터로 데이터 프로바이더의 API를 호출하는 것입니다.<BR/>

<img width="424" alt="13-9" src="https://user-images.githubusercontent.com/87962572/165523087-50f0d997-11f5-49d9-a106-de1d1e887fb6.png">

조회 API를 호출해서 데이터를 조회하는 것은 단순해서 좋지만 요청 개수가 많아지면 효율이 안좋아진다.<br/>

따라서, 데이터 컨슈머가 데이터 레플리카를 유지하는 방법이 낫다.<br/>
데이터 컨슈머는 데이터 프로바이더가 발행한 도메인 이벤트를 구독해서 이 레플리카를 항상 최신 상태로 유지합니다.<br/>

<img width="424" alt="13-10" src="https://user-images.githubusercontent.com/87962572/165523370-c01f760f-6d1a-4b85-8889-32153df4be2d.png">

통합 글루는 모놀리스 데이터를 서비스로 복제하여 서비스에 구현된 이벤트 핸들러는 이벤트를 받아 서비스 db를 업데이트합니다.<br/>

이러한 방식인 레플리카는 조회시에 데이터 프로바이더를 반복적으로 쿼리하는 오버헤드가 준다는 장점이 있습니다.<br/>
그리고 업데이트시에는 서비스와 모놀리스가 이벤츠에이트 트램 같은 프레임워크에 구현된 트랜잭셔널 메시징을 통신하면 됩니다.<br/>
단순한 경우에는 트리거하는 이벤트를 발행하고 복잡하면 시가를 이용하여 데이터의 일관성을 유지합니다.<br/>

2. 부패-방지 계층 구현(ACL)

<H5>ACL이 필요한 이유?</H5>
새로운 기능을 완전히 새로운 서비스로 구현한다고 가정했을 때 새로운 서비스에 새로운 도메인 모델을 개발할때 사용하고 있던 Delivery 서비스나, Order 서비스를 사용한다고 하자.<BR/>
이때 Delivery와 Order 객체 속성이 매우 달라서 서비스와 모놀리스가 서로 소통하려면 ACL방식을 구현해야 합니다.<BR/>

<H5>ACL 목표</H5>
레거시 모놀리스의 도메인 모델이 서비스 도메인 모델을 더럽히지 못하게 만드는 것입니다.

<img width="433" alt="13-11" src="https://user-images.githubusercontent.com/87962572/165524689-48f890a8-3de9-445b-b187-2752f64d9ccb.png">

위의 그림처럼 서로 다른 영역 도메인을 사용하기 위해 FTGO 모놀리스 공용언어 사이의 "변환"을 해주는 과정이 필요합니다.

<img width="434" alt="13-12" src="https://user-images.githubusercontent.com/87962572/165525116-9559d529-b484-4d00-9f7c-6795642b72e8.png">

그리고 이벤트 핸들러는 도메인이라는 이벤트를 모놀리스 도메인 언어에서 배달 서비스의 언어로 변환해야 합니다. <BR/>
(클래스, 속성명, 속성값 등)
<BR/>
3. 모놀리스가 도메인 이벤트를 발행/구독하는 방법

도메인 이벤트는 중요한 협동장치이며 모놀리스가 도메인이벤트를 발행하는 방법은 다음과 같습니다.
1) 서비스가 사용하는 것과 동일한 이벤트 발행 장치를 적용하는 방법.
 - 특정 엔티티를 변경하는 코드를 모조리 찾아내 이벤트를 발행 API를 호출하는 코드를 끼워 넣는 것.
2) DB 수준에서 도메인 이벤트를 발행하는 방법
 - 이는 모놀리스 변경할 필요가 없다는 장점이 있음
 - 고수준의 비즈니스 이벤트를 발행하기 어렵다는 단점이 있음.



<H3>13.3.2 서비스와 모놀리스에 걸쳐 데이터 일관성 유지</H3>

```
(시가(sega) : 비동시 메시징을 통해 편성되는 일련의 로컬 트랜잭션)
```

시가가 구현하기 어렵지 않고 모놀리스 트랜잭션을 보상 처리할 필요가 없으므로 서비스 추출 순서를 잘 조정하면 단순히 구현가능합니다.

<h4>보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다.</h4>

```
1. 모놀리스
 - 주문을 APPROVAL_PENDING 상태로 생성합니다.
 - 주문 가능한 소비자인지 확인합니다.
2. 주방 서비스
 - 주방 내역을 확인합니다.
 - 티켓을 CREATE_PENDING 상태로 생성합니다.
3. 모놀리스 
 - 소비자 신용카드를 승인합니다.
 - 주문 상태를 APPROVED로 변경합니다.
4. 주방 서비스
 - 티켓 상태를 AWATING_ACCEPTANCE상태로 변경합니다.
```

주문을 생성하는 첫번째 트랜잭션을 보상 가능 트랜잭션으로 만들기 어렵다.
WHY? 주방 서비스에서 발행하는 두 번째 로컬 트랜잭션이 실패할 경우 첫 번째 로컬 트랜잭션이 수행한 업데이트를 모놀리스가 언두해야 하기 때문입니다.

<H4>서비스 추출 순서를 조정하면 보상 트랜잭션을 모놀리스에 구현하지 않아도 된다.</H4>

```
1. 주문 서비스 : 주문을 APPROVAL_PENDING 상태로 생성합니다.
2. 소비자 서비스 : 주문 가능한 소비자인지 확인합니다.
3. 모놀리스 
  - 주문 내역을 확인하고 티켓을 생성합니다.
  - 소비스 신용카드를 승인합니다.
4. 주문 서비스 : 주문 상태를 APPROVED로 변경합니다.
```



