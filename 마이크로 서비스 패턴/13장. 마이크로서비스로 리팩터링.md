<h1>13장. 마이크로서비스로 리팩터링</h1>

<h2>13.1 마이크로서비스 리팩터링 개요</h2>

마이크로서비스로의 리팩터링을 고민해야되는 이유를 우선 따져보자.

<h3>13.1.1 모놀리스를 왜 리팩터링하는가?</h2>
마이크로서비스 아키텍처는 여러모로 장점이 많습니다.<br/>
유지보수성, 테스트성, 배포성이 우수하고 개발을 빨리 할 수 있으며, 확장성도 우수하고 오류 격리도 잘 됩니다.<br/>
그래서 기술 스택을 발전시키기오 휠씬 쉽습니다.<br/>

하지만 모놀리스를 마이크로서비스로 리팩터링하는 작업은 매우 고됩니다.<br/>
무엇보다 새 기능 개발에 필요한 리소스를 분산됩니다.<br/>

필요한 이유?<br/>
- 느린 전달 : 애플리케이션을 이해, 관리, 테스트하기가 어려워서 개발자의 생산성이 떨어집니다.<br/>
- 버그 투성이 소프트웨어 릴리스 : 테스트의 결여는 곧 소프트웨어 릴리스가 버그 투성일 떄가 많다는 뜻이고 이는 회사의 타격이며 고객에게는 서비스의 불만족으로 귀결됩니다.<br/>
- 나쁜 확장성 : 모놀리식 애플리케이션은 리소스 요건이 전혀 다른 모듈을 하나의 실행 가능한 컴포넌트로 조합되기 때문에 확장이 어렵습니다. 그리고 비용이 많이 듭니다.<br/>

<h3>13.1.2 모놀리스 옥죄기</h3>
애플리케이션 아키텍처를 모놀리식에서 마이크로서비스로 전환하는 프로세스는 애플리케이션 현대화의 한 가지 형태입니다.<br/>
지난 수십 년간 많은 개발자가 실시한 애플리케이션 현대화는 레거시 애플리케이션을 현대 아키텍처와 최신 기술 스택이 접목된 애플리케이션으로 바구는 과정입니다.<br/>

이때 "완전히 뜯어고치기"를 삼가라고합니다.<br/>

즉, 새로은 아키텍처의 애플리케이션을 개발한답시고 기존 애플리케이션을 완전히 뜯어고치는 일은 하지 말라는 것입니다.<br/>
이는 매우 리스크가 크고 결국 실패하는 프로젝트가 될 가능성이 높습니다.<br/>

따라서, "단계적"으로 리팩터링을 하는 것이 좋습니다.<br/>

<img width="374" alt="13-1" src="https://user-images.githubusercontent.com/87962572/164979705-624eaa5a-2ad9-4ebc-9a63-cd7ba0f74a51.png">

<h4>스트랭글러 애플리케이션 패턴</h4>
기존 애플리케이션과 함께 실행되면서 새로운 마이크로서비스 애플리케이션을 조금씩 빌드한 스트랭글러 애플리케이션을 개발하는 것입니다.<br/>
시간이 지날수로 모놀리식에 구현된 기능은 점점 가짓수가 줄어 완전히 없어지거나 또 다른 마이크로서비스가 됩니다.<br/>

모놀리스를 쪼개는 것보다 영업 이익 산출 등 더 중요한 작업이 많은 경우 이러한 과정은 네버엔딩이 될 수 있고 모놀리스가 특별히 걸림돌이 되지 않는다면 그냥 냅둬도 된다.<br/>

<h4>값을 조기에 자주 검증</h4>
모놀리스를 조금식 리팩터링하면서 새로운 기술 스택과 고속의 최신 데브옵스 스타일로 신규 서비스를 각각 개발/전달하는 것입니다.<br/>
덕분에 팀의 전달 속도는 점점 늘어날 것입니다.<br/>

"애플리케이션에서 가치가 큰 부분을 먼저 마이크로서비스로 이전하는 것도 방법이다."<br/>
그러면 그만큼 독립적인 개발 속도가 빨라지고 새로운 알고리즘을 더 자주 배포해서 효용성을 평가해 볼 수도 있습니다.<br/>

<h4>모놀리스 변경 최소화</h4>
- 추출된 서비스에 있는 데이터를 모놀리스 DB로 복제하거나(13.2.3절)<br/>
- 서비스 추출순서를 잘 조정하는 방법이 있다.(13.3.2절)<br/>

<h4>기술 배포 인프라:모든 것이 다 필요한 것이 아니다.</h4>
인프라 개발에 필요한 선행 투자를 최소화하고 반드시 있어야 할 것은 테스트 자동화 배포 파이프라인이 유일합니다.<br/>
정교한 배포 인프라와 관측성 인프라는 당장 없어도 되며 실제로 새로운 아키텍처를 경험해보기 전에 막대한 투자가 필요한 기술은 나중으로 미루는 것이 좋다.<br/>


<h2>13.2 모놀리스 -> 마이크로서비스 리팩터링 전략</h2>

마이크로서비스로 교체하는 3가지 전략<br/>
1. 새 기능을 서비스로 구현합니다.<br/>
2. 표현 계층과 백엔드를 분리합니다.<br/>
3. 기능을 여러 서비스로 추출해서 모놀리스를 분해합니다.<br/>

1번은 모놀리스 성장을 중단하기 위한 전력이다.<br/>
2~3번은 모놀리스 분해에 관한 전략입니다.<br/>

기능을 모놀리스에서 스트랭글러 애플리케이션으로 전환하는 3번 전략은 반드시 필요하다.<br/>

<h3>13.2.1 새 기능을 서비스로 구현한다.</h3>
이미 거대하고 복잡해진 모놀리식 애플리케이션에 새 기능이 구현된 코드는 더 이상 추가하지 마세요.

모놀리식을 마이크로 서비스로 전환할 때에는 새 기능을 서비스로 구현하는 작업부터 실천하는 것이 좋습니다.

<h4>새 서비스를 모놀리스에 연계</h4>
- API 게이트웨이 : 기존 요청은 모놀리스로 각각 라우팅합니다.<BR/>
- 통합 글루 코드 : 서비스가 모놀리스 데이터에 접근하고 모놀리스에 구현된 기능을 호출할 수 있게 서비스를 모놀리스에 통합니다.<BR/>

<H4>새 기능을 서비스로 구현하는 시점</H4>
모두다 스트랭글러 애플리케이션에 구현할 수 있는것은 이상적이지만 새 서비스부터 구현하는 것이 현실적이다.<BR/>

<img width="383" alt="13-2" src="https://user-images.githubusercontent.com/87962572/164980323-907d0093-7974-4ca7-8a0d-ff084099fae1.png">

마이크로서비스는 본직적으로 비즈니스 능력 위주로 구성된 '느슨하게 결합된 서비스'입니다.<BR/>

데이터를 일관성을 유지하는 것도 문제입니다.<BR/>
새 기능을 서비스로 구현할 수 없다면, 일단 모놀리스에 새로운 기능을 구현합니다. 나중에 다른 관련 기능과 함께 해당 기능을 자체 서비스로 추출할 수 있습니다.<BR/>

새 기능을 서비스로 구현하면 개발 속도가 향상되고 모놀리스를 수평적으로 쪼개도 개발 속도를 높이는 데 도움이 됩니다.<BR/>

<H3>13.2.2 표현 계층과 백엔드를 분리한다.</H3>
표현 계층을 비즈니스 로직과 데이터 접근 계층에서 분리하면 모놀리식 애플리케이션의 덩치를 줄일 수 있습니다.

- 표현 계층 : HTTP 요청을 처리해서 웹 UI에 전달한 HTML 페이지를 생성하는 모듈로 구성되며 사용자 인터페이스가 정요한 애플리케이션은 표현 계층 코드가 대부분이다.<BR/>
- 비즈니스 계층 :엔터프라이즈 애플리케이션 특성상 복잡한 비즈니스 규칙이 구현된 모듈로 구성됩니다.<BR/>
- 데이터 접근 로직 : DB, 메시지 브로커 등 인프라 서비스에 접근하는 모듈로 구성됩니다.<BR/>

<img width="433" alt="13-3" src="https://user-images.githubusercontent.com/87962572/164980523-1d88f998-0b34-4fda-9bd6-492775ed1577.png">

벡엔드, 프론트엔드를 분리하면 독립적으로 배포할 수 있고 서비스가 호출하는 API가 표출된다.<BR/>
표현계층(A)와 비즈니스/데이터 접근 로직(B)로 나눠서 분리한 후에는 A가 B를 원격 호출합니다.<BR/>

<H4>장점</H4>
1. A/B애플리케이션을 서로 독립적으로 배포/개발/확장할 수 있습니다.<BR/>
2. 나중에 개발할 마이크로서비스가 호출할 수 있는 원격 API가 표출됩니다.<BR/>

하지만 이또한 완전한 해결책은 아니다.  -> 3번 전략이 필요하다.

<H3>13.2.3 기능을 여러 서비스로 추출한다.</H3>
새 기능을 서비스로 구현하고 백엔드에서 프런트엔드 웹 애플리케이션을 떼어 내는 것만으로는 한계가 있다.
-> 모놀리스가 가진 비즈니스 능력을 하나씩 서비스로 옮기는 분해 전략을 구사하자.

모놀리스를 나누는 기능은 다음과 같다.
- API 끝점이 구현된 인바운드 어댑터
- 도메인 로직
- DB 접근 로직 등이 구현된 아웃바운드 어댑터
- 모놀리스의 DB 스키마

<img width="433" alt="13-4" src="https://user-images.githubusercontent.com/87962572/164980803-3a488020-7abc-4ae2-9a0f-4ac55f5fe866.png">

서비스를 추출해서 모놀리스를 쪼갠다.
비즈니스 로직과 어댑터로 구성된 기능 덩이를 찾아내 서비스 추출(즉, 코드 서비스 내부로 이전)하다.
새로 추출된 서비스와 모놀리스는 통합 글루가 제공한 API를 통해 협동한다.

<H4>도메인 모델 분리</H4>
서비스를 추출하기 위해 먼저 모놀리스 모델에서 서비스의 도메인 모델을 추출합니다.
서비스 인스턴스는 보통 하나의 프로세스 이기 때문에 서비스 경계를 넘나드는 객체 레퍼런스가 있을 수 없습니다.

<img width="367" alt="13-5" src="https://user-images.githubusercontent.com/87962572/164980944-df0d2dfc-e4fb-4282-a09c-d2ab126a7c59.png">

<img width="379" alt="13-6" src="https://user-images.githubusercontent.com/87962572/164980948-a3e7e4e7-b644-42ab-b991-3ae919e2b001.png">

서비스를 넘나드는 객체 레퍼런스를 제거하고 독립시킨 다음에 기본키로 대체하자.
이러한 변경사항은 사소하다고 할수도있지만, 객체 레퍼런스를 참조하는 클라이언트에는 큰 영향을 미칠 수도 있다.
따라서, "서비스와 모놀리스 간에 데이터를 복제"하면 변경 범위를 줄일 수 있다.


<H4>DB 리팩터링</H4>
도메인 모델은 단순히 코드만 변경한다고 나누어지는 것이 아닙니다.
따라서 모놀리스에서 서비스를 추출하는 것은 데이터도 함께 이전한다를 의미하며, 모놀리스에 있던 DB 테이블도 서비스 DB로 옮겨야 합니다.

또 엔터티를 나누려면 해당 DB 테이블도 분리해서 서비스로 이전해야 합니다.

<H4>변경 범위를 줄이기 위해 데이터 복제</H4>
모놀리스에서 예를들어 Order 엔티티를 분리해서 Delivery 엔티티를 추출하는 작업만 해도 새로 이전한 필드를 참조하는 코드를 모조리 찾아 고쳐햐 합니다.

DB리팩터링에서 가장 큰 장애물은 전체 DB클라이언트가 새 스키마를 사용하도록 바꾸는 일입니다.
그래서 해결책은 전이 기간 동안에는 원본 스키마를 유지하되, "원본 스키마와 신규 스키마를 동기화하는 트리거"를 사용하는 것입니다.

<img width="429" alt="13-7" src="https://user-images.githubusercontent.com/87962572/164981229-85747475-3d07-4f81-b6c1-7db74b1138bc.png">


<H4>어떤 서비스를 언제 추출하나</H4>
일단 추출시 가장 큰 혜택이 큰 서비스에 집중해야되며
마이크로서비스 전환이라는 긴 여행은 시간별로 구획된 아키텍처 정의부터 시작하는 것이 중요합니다.

<H5>전략</H5>
1. 모놀리스 개발 동결하고 요건이 있을 때마다 서비스를 추출해라.
2. 좀 더 계획적인 접근 방식으로 서비스 추출 시 기대되느 혜택을 애플리케이션 모듈별로 순위를 매겨 서비스로 추출합니다.

<H2>13.3 서비스와 모놀리스 간 협동 설계</H2>
모놀리스에서 서비스를 추출하면 원래 ACID 트랜잭션에 묶여 있던 코드로 함께 분리되는데, 데이터 일관성이 그대로 계속 유지되도록 잘 살펴야 합니다.

"통합 글루 코드"가 서비스와 모놀리스 상호 작용을 관장합니다.
요건에 따라 서비스와 모놀리스 REST 또는 메시징으로 상호 작용하며, 그 밖에 다른 IPC로 통신할 수 있습니다.

<img width="427" alt="13-9" src="https://user-images.githubusercontent.com/87962572/164981641-e9a60dac-0bfb-45f9-87a2-78ae2530fc17.png">


<H3>13.3.1 통합 글루 설계</H3>
추출된 서비스와 모놀리스가 협동할 수 있게 통합 글루도 개발해야 합니다.
통합 글루는 특정 IPC를 이용하는 코드를 서비스 및 모놀리스 양쪽에 구성합니다.




