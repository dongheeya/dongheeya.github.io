<h1>2장 분해 전략</h1>
<ul>
  <li>2.1 마이크로서비스 아키텍처란 무엇인가?</li>
  <li>2.2 마이크로서비스 아키텍처 정의</li>
  <li>2.3 마치며</li>
</ul>

<h2>2.1 마이크로서비스 아키텍처란 무엇인가?</h2>

마이크로서비스 아키텍처는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일입니다.


<h3>2.1.1 소프트웨어 아키텍처의 정의와 중요성</h3>
아키텍처는 매우 중요한데 무엇이고 왜 중요한가?

```
컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리컨트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.
```

핵심은 애플리케이션 아키텍처가 여러 엘리먼트로의 분해와 이런 파트 간의 관계이다.

애플리케이션 아키텍처를 바라보는 관점에 4+1 뷰 모델이 유명한다.
4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다.

- 논리 뷰 : 개발자가 작성한 소프트웨어 엘리먼트
- 구현 뷰 : 빌드 시스템의 결과물
- 프로세스 뷰 : 런타임 컴포넌트
- 배포 뷰 : 프로세스가 머신에 매핑되는 방법

![2-1](https://user-images.githubusercontent.com/87962572/154061631-6858ba6c-ff5d-4fb6-9a78-c76847561c38.jpg)

각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가협동하여 요청을 처리하는지 기술한다.

<h4>아키텍처의 중요성</h4>
애플리케이션 요건은 크게 2가지로 나뉜다.
- 애플리케이션이 해야 할 일을 정의한 기능 요건이다.
- 이른바 ~성 으로 끝나는 서비스 품질 요건이다. ( 확장성, 신뢰성, 런타임 품질, 관리성, 테스트성, 배포성.. 개발 시점의 품질이 해당)

<h3>2.1.2 아키텍처 스타일 개요</h3>
마이크로서비스 아키텍처는 애플리에키션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍처 스타일이다.

<h4>육각형 아키텍처 스타일</h4>
- 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 미즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터를 둔다.
- 비즈니스 로직에서의 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업이다.
- 인바운드 포트 : 비즈니스 로직이 표출된 API로서, 외부 애플리케이션은 이 API를 통해 비즈니스 로직을 호출합니다.
- 아웃바운드 포트 : 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것이다.

       
![2-2](https://user-images.githubusercontent.com/87962572/154062631-3703cdd9-5179-428b-a19b-cef62aef7c8c.jpg)

육각형 아키텍처 스타일의 장점 : 비즈니스 로직에 있던 표현/데이터 접근 로직이 어뎁터와 분리되어있어 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다.

(장점) : 비즈니스 로직만 따로 테스트하기 쉽고, 현대 애플리케이션 아키텍처를 좀 더 정확하게 반영할 수 있다.

<h3>2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다.</h3>
4+1 뷰 모델과 아키텍처 스타일 얘기를 했는데, 이제 모놀리식/마이크로서비스 아키텍처를 정의할 차례이다.
먼저 마이크로서비스 아키텍처도 일종의 아키텍처 스타일이다.
여기서 컴포넌트는 곧 서비스고, 각 서비스는 자체 논리 뷰 아키텍처를 갖고 있습니다.

![2-3](https://user-images.githubusercontent.com/87962572/154063266-f977f57d-b707-48c2-b3c5-1291e19b8136.jpg)

마이크로서비스 아키텍처의 핵심 제약 조건은 서비스를 느슨하게 결합한다는 것이다.


그래서 여러 서비스가 협동하는 방식에도 제약사항이 있다.
이를 이해하기 위해서는 서비스는 무엇이고 느슨한 결합이 무엇인지 왜 중요한지 먼저 이해해보자.

<h4>서비스란 무엇인가?</h4>
서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트이다.
서비스는 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커멘트, 쿼리, 이벤트로 구성된 API를 제공한다.
서비스 작업은 크게 커멘드와 쿼리로 나뉜다.

서비스 API는 내부 구현 상세를 캡슐화한다.
개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로 마이크로서비스 아키텍처에서 애플리케이션 모듈성은 보장된다.

<H4>느슨한 결합</H4>
서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 쿠도를 바꿀 수 있다.
느슨하게 결합되어 있으면 유지보수성, 테스트성이 높아지고, 애플리케이션 개발 시간이 단축된다.

서비스는 느슨하게 결합되고 API를 통해서만 동작하기 때문에 서비스가 직접 DB와 통신하는 일은 불가능합니다.
또 클래스 필드 같은 서비스의 영속적 데이터는 반드시 프라이빗으로 유지해야 합니다.

<H4>서비스 규모는 별로 중요하지 않다.</H4>
마이크로서비스라는 용어가 '마이크로'라는 어감때문에 왠지 서비스를 아주 작게 만들어야 할 것 같은 느낌이 든다.
하지만 사실 크기가 중요한 것은 아니다.

크기보다는 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야 한다.

조직 차원에서 소프트웨어를 더 빨리 개발할 수 있고, 주된 목표는 아니지만 애플리케이션 확장성도 향상된다.

<H2>2.2 마이크로서비스 아키텍처 정의</H2>
도메인 전문가 문서로 정의한 요건들과 기존 애플리케이션을 출발점으로 삼아야겠다.

이 절에서는 애플리케이션 아키텍처를 정의하는 3단계 프로세스를 설명한다. (아래 그림)

![2-5](https://user-images.githubusercontent.com/87962572/154064944-23191f29-6033-4bfd-a835-5ab7aa483cbc.jpg)

1단계는 애플리케이션 요건을 핵심 요청으로 추출하는 것이다.
각 시스템 작업은 애플리케이션이 처리하는 요청을 추상화한다.
그리고 데이터 업데이트를 하는 커멘트나 데이터를 조회하는 쿼리가 모두 해댱된다.

각 커멘트 동작은 추상적인 도메인 모델 관점에서 정의되며, 이 또한 요건에서 도출된다.

2단계는 어덯게 여러 서비스로 분해할지 결정하는 것이다.
여러가지 전략이 있겠지만, '기술 개념이 아닌 비즈니스 개념 중심'으로 이뤄진다.

3단계는 서비스별 API를 정의한다.
여러 서비스가 셥동하는 방식을 결정해야 하는데, 대부분 서비스에 추가 지원 작업을 두는 형태가 될 것이다.

분해 과정에서는 장애물이 많다. 네트워크 지연이나, 동기 통신으로 인한 가용성의 저하, 데이터 일괄성 지키는 방법 등이 있다.

<H3>2.2.1 시스템 작업 식별</H3>
애플리케이션 아키텍처를 정의하는 첫 단추는 시스템 작업을 정의하는 일이다.

객체 지향 설계 프로세스에서 영향을 받은 2단계 방법은 아래와 같다.
1단계는 시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성한다.
2단계는 시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술하는 것이다.

 ![2-6](https://user-images.githubusercontent.com/87962572/154066365-44e2c872-7b0f-4c29-8e99-a32a2e1e84d8.jpg)

도메인 모델은 주로 사용자 스토리의 명사에서 도출합니다.
시스템 작업은 주로 동사에서 도출하며, 각각 하나 이상의도메인 객체와 그들 간의 관계로 기술한다.
시스템 작업은 도메인 모델을 생성, 수정, 삭제하거나 모델간 관계를 맺고 끊을 수 있다.

<H4>고수준 도메인 모델 생성</H4>
시스템 작업을 정의하려면 우선 고수준의 애플리케이션 도메인 모델을 대략 그려본다.
고수준 도메인 모델은 시스템 작업의 동작을 기술하는 데 필요한 보케블러리를 정의하기 때문에 이 단계에서는 유용하다.

여러 단계를 치다보면 아래 그림과 같은 핵심 클래스로 구성된 도메인 모델이 완성된다.

![2-7](https://user-images.githubusercontent.com/87962572/154067003-e1360ad9-621e-4668-84fd-d7246214b6e8.jpg)

위 클래스 다이어그램은 애플리케이션 아키텍처의 단면을 잘 나타내지만, 이 그림을 살아 움직이게 할 시나리오가 없으면 예쁘장한 그림에 지나지 않는다.

<H4>시스템 작업 정의</H4>
애플리케이션이 어떤 요청을 처리할지 식별하는 단계이다.
시스템 작업은 크게 2종류로 나뉜다.
- 커멘트 : 데이터 생성, 수정, 삭제
- 쿼리 : 데이터 읽기

커멘드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의한다.
작업 호출시 충족되어야 할 선행 조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성된다.


