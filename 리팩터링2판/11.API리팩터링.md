<H2>11.9 함수를 명령으로 바꾸기</H2>

<img width="571" alt="image" src="https://user-images.githubusercontent.com/87962572/196149548-c59e6c75-4a12-4dc4-a7a0-ba4d1864f70d.png">

<H3>배경</H3>
함수는 프로그래밍의 기본적인 빌딩 블록 중 하나다.
함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다.

이런 객체를 가리켜 '명령 객체' 혹은 단순히 '명령'이라 한다.
명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.

명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다.
명령은 되돌리기 같은 보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공하루 싱ㅆ다.

상속과 훅을 이용해 사용자 맞춤형으로 만들 수도 있다.

비슷하게, 중첩 함수를 지원하지 않는 언어세서도 메서드와 필드를 이용해 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메서드들을 테스트와 디버깅에 직접 이용할 수 있다.

<H3>절차</H3>
- 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다.
- 방금 생성한 빈 클래스로 함수를 옮긴다.
- 리팩터링이 끝날 때까지는 원래 함수를 전달 함수 역할로 남겨두자.
- 명령 관련 이름은 사용하는 프로그래밍 언어의 명명 규칙을 따른다.
- 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다.

<H3>예시</H3>
함수를 일급으로 만든 선택은 아주 훌륭했다.
그래서 일급 함수를 지원하지 않는 언어에서라면 필요했을 일반적인 작업에는 굳이 명령을 만ㄷ르어 해결할 이유가 없다.

예컨대 복잡한 함수를 잘게 쪼개서 이해하거나 수정하기 쉽게 만들고자 할 때가 있다.
그래서 사실 이 리팩터링의 가치를 잘 보여주려면 길고 복잡한 함수를 준비해야 한다.

다음은 건강 보험 애플리케이션에서 사용하는 점수 계산 함수다.

```
function score(candidate, medicalExam, scoringGuide){
  let result = 0;
  let healthLevel = 0;
  let highMedicalRiskFlag = false;
  if (medicalExam.isSmoker) {
  healthLevel += 10;
  highMedicalRiskFlag = true;
  }
  let certificationGrade = "regular";
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
  certificationGrade = "low";
  result -= 5;
  }
  // lots more code like this
  result -= Math.max(healthLevel - 5, 0);
  return result;
}
```

1. 시작한 빈 클래스를 만들고 2. 이 함수를 그 클래스로 옮기기는 일부터다.

```
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer().execute(candidate, medicalExam, scoringGuide);
}

class Scorer {
  execute (candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;
    if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
    }
    let certificationGrade = "regular";
    if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
    }
    // lots more code like this
    result -= Math.max(healthLevel - 5, 0);
    return result;
    }
  }
```

주로 나는 명령이 받는 인수들을 생성자로 옮겨서 execute()메서드는 매개변수를 받지 않게 하는 편이다.
명려으이 수명주기나 사용자 정의 기능 등을 지원해야 해서 매개변수가 복잡할 때는 아주 편리하다.

예컨대 이 방식이라면 매개변수 목록이 서로 다른 여러 형태의 명령들을 하나의 실행 대기열을 통해 전달할 수도 있다.

매개변수 옮기기는 한 번에 하나씩 수행하자

```
function score(candidate, medicalExam, scoringGuide) {
                          -- candidate 삭제
  return new Scorer(candidate).execute(medicalExam, scoringGuide);
}

--Score 클래스

constructor(candidate){
  -- candidate 추가
  this._candidate = candidate;
  }
  execute (candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;
    if (medicalExam.isSmoker) {
    healthLevel += 10;
    highMedicalRiskFlag = true;
    }
    let certificationGrade = "regular";
    if (scoringGuide.stateWithLowCertification(this._candidate.originState)) {
    certificationGrade = "low";
    result -= 5;
    }
    // lots more code like this
    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
```

계속해서 다른 매개변수들도 옮긴다.

```

function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute();
}

--Score 클래스

constructor(candidate, medicalExam, scoringGuide) {
  -- candidate 추가
  this._candidate = candidate;
  this._medicalExam = medicalExam;
  this._scoringGuide = scoringGuide;
  }
  execute (candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
    let highMedicalRiskFlag = false;
    
    if (this._medicalExam.isSmoker) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }
    
    let certificationGrade = "regular";
    if (this._medicalExam.stateWithLowCertification(this._candidate.originState)) {
      certificationGrade = "low";
      result -= 5;
    }
    // lots more code like this
    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
```

남은 지역 변수들도 같은 방법으로 바꿔준다.

```
--Score 클래스

constructor(candidate, medicalExam, scoringGuide) {
  -- candidate 추가
  this._candidate = candidate;
  this._medicalExam = medicalExam;
  this._scoringGuide = scoringGuide;
  }
  execute (candidate, medicalExam, scoringGuide) {
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;
    
    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10;
      this._highMedicalRiskFlag = true;
    }
    
    this._ certificationGrade = "regular";
    if (this._medicalExam.stateWithLowCertification(this._candidate.originState)) {
      this._certificationGrade = "low";
      this._result -= 5;
    }
    // lots more code like this
    result -= Math.max(this._healthLevel - 5, 0);
    return result;
  }

```

이제 함수의 상태가 모두 명령 객체로 옮겨졌다.
따라서 함수가 사용하던 변수나 그 유효 범위에 구애받지 않고 함수 추출하기 같은 리팩터링을 적용할 수 있다.

```
  execute (candidate, medicalExam, scoringGuide) {
    this._result = 0;
    this._healthLevel = 0;
    this._highMedicalRiskFlag = false;
    
    this.scoreSmoking();  // 함수추출하기!
    this._ certificationGrade = "regular";
    if (this._medicalExam.stateWithLowCertification(this._candidate.originState)) {
      this._certificationGrade = "low";
      this._result -= 5;
    }
    // lots more code like this
    result -= Math.max(this._healthLevel - 5, 0);
    return result;
  }

  scoreSmoking(){
    if (this._medicalExam.isSmoker) {
      this._healthLevel += 10;
      this._highMedicalRiskFlag = true;
    } 
  }

```

<h2>11.10 명령을 함수로 바꾸기</h2>

<img width="573" alt="image" src="https://user-images.githubusercontent.com/87962572/196172408-84785df0-6550-4245-9cda-ee693c89e7ac.png">


<h3>배경</h3>
명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다.
구체적으로는, 큰 연산 하나를 여러 개의 작은 메서드로 쪼개고 필드를 이용해 쪼개진 메서드들끼리 정보를 공유할 수 있다.
또한 어떤 메서드를 호출하냐에 따라 다른 효과를 줄 수 있고 각 단계를 거치며 데이터를 조금식 완성해갈 수도 있다.

명령의 이런 능력은 공짜가 아니다.
명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰인다.

이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.

<h3>절차</h3>
1. 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 함수로 추출한다.
2. 명령의 실행 함수가 호출하는 보조 메서드들 각각을 인라인한다.
3. 함수 선언 바꾸기를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다.
4. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개변수를 사용하게끔 바꾼다. 하나씩 수정할 때마다 테스트한다.
5. 생성자 호출과 명령의 실행 메서드 호출을 호출자 안으로 인라인한다.
6. 테스트한다.
7. 죽은 코드 제거하기로 명령 클래스를 없앤다.


<h3>예시</h3>

```
class ChargeCalculator {
  constructor (customer, usage, provider){
    this._customer = customer;
    this._usage = usage;
    this._provider = provider;
  }
  get baseCharge() {
    return this._customer.baseRate * this._usage;
  }
  get charge() {
    return this.baseCharge + this._provider.connectionCharge;
  }
}
```

다음은 호출하는 쪽의 코드다.

```
monthCharge = new ChargeCalculator(customer, usage, provider).charge;
```

이 명령 클래스는 간단한 편이므로 함수를 대체하는 게 나아 보인다.

1. 첫 번째로, 이클래스를 생성하고 호출하는 코드를 함께 함수로 추출한다.

```
-- 호출자
monthCharge = charge(customer, usage, provider);
```

```
-- 최상위
function charge(customer, usage, provider){
  return new ChargeCalculator(customer, usage, provider).charge;
}
```

이때 보조 메서드들을 어떻게 다룰지 정해야 하는데, baseCharge()가 이러한 보조 메서드에 속한다.
값을 반환하는 메서드라면 먼저 반환할 값을 변수로 추출한다.


```
--ChargeCalculator클래스
get baseCharge(){
  return this._customer.baseRate * this._usage;
}

get charge(){
  const baseCharge = this.baseCharge;
  return baseCharget + this._provider.connectionCharge;
}
```

그런 다음 보조 메서드를 인라인한다.

```
--- chargeCalculator 클래스
get charge(){
  const baseCharge = this._customer.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}
```

3. 이제 로직 전체가 한 메서드에서 이뤄지므로, 그다음으로는 생성자에 전달되는 모든 데이터를 주 메서드로 옮겨야 한다.
먼저 생성자가 받던 모든 매개변수를 charge()메서드로 옮기기 위해 함수 선언 바꾸기를 적용한다.

```
--ChargeCalculator 클래스
constructor(customer, usage, provider){
  this._customer = customer;
  this._usage = usagle;
  this._provider = provider;
}

charge(customer, usage, provider){
  const baseCharge = this._customer.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}

-- 최상위
function charge(customer, usage, provider){
  return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider);
}
```

4. 이제 charge()의 본문에서 필드 대신 건네받은 매개변수를 사용하도록 수정한다.
이번에도 한 번에 하나씩 진행한다.

```
--ChargeCalculator 클래스
-- customer 삭제
constructor(usage, provider){
  this._usage = usagle;
  this._provider = provider;
}

charge(customer, usage, provider){
//_customer에서 parameter로 변경
  const baseCharge = customer.baseRate * this._usage;
  return baseCharge + this._provider.connectionCharge;
}

```

생성자에 있는 대입문 ```this._customer = customer;``` 는 무시되므로 꼭 지워야 하는 건 아니지만 지워두는 펴닝 좋다.
그래야 혹시라도 필드 대신 매개변수를 사용하는 수정을 빼먹었을 때 테스트가 실패하기 때문이다.

나머지 매개변수들도 똑같이 바꿔주면 다음처럼 될 것이다.

```
--ChargeCalculator 클래스
charge(customer, usage, provider){
  const baseCharge = customer.baseRate * usage;
  // _provider -> provider 로 변경
  return baseCharge + provider.connectionCharge;

}
```

5. 다 됐다면 최상위 charge() 함수로 인라인할 수 있다.
이는 생성자와 메서드 호출을 함께 안라인하는 특별한 형태의 함수 인라인하기다.

```
-- 최상위
function charge(customer, usage, provider){
  const baseCharge = customer.baseRate * usage;
  return baseCharge + provider.connectionCharge;

}
```
7. 명령 클래스는 이제 죽은 코드가 되었으니 죽은 코드 제거하기로 영면에 들게 해준다.



<h2>11.11 수정된 값 반환하기</h2>

<h3>배경</h3>
데이터가 어떻게 수정되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나다.
특히 같은 데이터 블록을 읽고 수정하는 코드가 여러 곳이라면 데이터가 수정되는 흐름과 코드의 흐름을 일치시키기가 상당히 어렵다.
그래서 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.

데이터가 수정됨을 알려주는 좋은 방법이 있다.
변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다.
이 방식으로 코딩하면 호출자 코드를 읽었을 떄 변수가 갱신될 것임을 분명히 인지하게 된다.



