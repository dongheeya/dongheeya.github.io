
상속은 발등에 불이 떨어져서야 비로소 잘못 사용했음을 알아차리는 경우가 많다.
특정 기능을 상속 계층구조의 위나 아래로 옮겨야 하는 상황은 드물지 않다.
이와 같은 리팩터링으로는 메서드 올리기, 필드 올리기, 생성자 본문 올리기, 메서드 내리기, 필드 내리기가 있다.
계층 사이에 클래스를 추가하거나 제거하는 리팩터링으로는 슈처클래스 추출하기, 서브클래스 제거한다, 계층합치기가 있다.
떄론 필드 값에 따라 동작이 달라지는 코드가 있는데, 이런 필드를 서브클래스로 대체하고 싶다면, 타입 코드를 서브클래스로 바꾸기를 이요한다.

상속은 막강한 도구지만, 잘못된 곳에서 사용되거나 나중에 환경이 변해 문제가 생기기도 한다.
이럴 때는 서브클래스를 위임으로 바꾸기나 슈퍼 클래스를 위임하기 바꾸기를 활용하여 상속을 위임하기로 바꿔준다.

<h2>12.1 메스 올리기</h2>

![image](https://user-images.githubusercontent.com/87962572/196194902-4a37ffa5-3b1f-4584-bda8-20464aea6f17.png)

<h3>배경</h3>
중복 코드 제거는 중요한다.
중복된 두 메서드가 당장은 문제없이 동작할지라도 미래에는 벌레가 꼬이는 음식물 스레기로 전락할 수 있다.
무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에서는 반영되지 않을 수 있다는 위험을 항상 수반한다.
그런데 일반적으로는 중복을 찾기가 그리 쉽지 않다는 게 문제다.

메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다.
이럴 땐 그냥 복사해 붙여넣으면 끝이다.
리팩터링이 제대로 되었는지를 검증하려면 테스트가 여전히 잘 동작하는 지 확인하면 되지만, 테스트를 얼마나 잘 만들었느냐에 크게 의존하는 방법이다.
그래서 차이점을 찾는 방법을 효과가 좋다.

테스트에서 놓친 동작까지 알게 해주는 경우가 자주 있기 떄문이다.

메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다.
이런 경우에 가장 적은 단계를 거쳐 리팩터링하려면 각각의 함수 매개변수화한 다음 메서드를 상속 계층의 위로 올리면 된다.

메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에서만 있는 경우다.

이런 경우라면 필드를 먼저 슈퍼 클래스로 올린 후에 메서드를 올려야 한다.

<h3>절차</h3>
1. 똑같이 동작하는 메서드인지 면밀히 살펴본다.
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
3. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼 클래스에서 사용하고싶은 형태로 통일한다.
4. 슈퍼 클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다.
5. 정적 검사를 수행한다.
6. 서브 클래스 중 하나의 메서드를 제거한다.
7. 테스트한다.
8. 모든 서브클래스의 메서드가 없어질 떄까지 다른 서브 클래스의 메서드를 하나씩 제거한다.

<h3>예시</h3>
1. 두 서브 클래스에서 같은 일을 수행하는 메서드를 찾았다.

```
get annualCost(){
  return this.monthlyCost * 12;
}
```

```
--Department 클래스(Party를 상속함)
get totalAnnualCost(){
  return this.monthlyCost * 12;
}

```

2. 확인해보니 두 메서드에서 참조하는  monthlyCost()속성은 슈처클래스에는 정의되어 있지 않지만 두 서브 클래스 모두에 존재한다.
정적 언어였다면 슈퍼 클래스인 Party에 추상 메서드를 정의해야 한다.

3. 두 메서드의 이름이 다르므로 함수 선언 바꾸기로 이름을 통일한다.

```
-- Department 클래스
get annualCost(){
  return this.monthlyCost * 12;
}
```

4. 서브 클래스 중 하나의 메서드를 복사해 슈퍼클래스에 붙여넣는다.

```
-- Party 클래스
get annualCost(){
  return this.monthlyCost * 12;
}

```

정적 언어엿다면 이 시점에서 컴파일하면 모든 참조가 올바른지 확인해야 한다.


<h2>12.2 필드 올리기</h2>

<img width="571" alt="image" src="https://user-images.githubusercontent.com/87962572/196197382-be4a8215-8580-4a20-9330-3e3c1dc3b54c.png">


<h3>배경</h3>
서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 일부 기능이 중복되어 잇을 때 왕왕 있다.
특히 필드가 중복되기 쉽다.
이런 필드들은 이름이 비슷한게 보통이지만, 항상 그런 것은 아니다.
그래서 어떤 일이 벌어지는지를  알아내려면 필드들이 어떻게 이용되는지 분석해봐야 한다.

이렇게 하면 2가지 중복을 줄일 수 있다.
1. 데이터 중복 선언을 없앨 수 있다.
2. 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.

<h3>절차</h3>
1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다.
2. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다.
3. 슈퍼 클래스에 새로운 필드를 생성한다.
4. 서브 클래스의 필드들을 제거한다.
5. 테스트한다.


<h2>12.3 생성자 본문 올리기</h2>

<img width="584" alt="image" src="https://user-images.githubusercontent.com/87962572/196198046-38fe1614-5b0a-4c8c-a269-1f126b00a27b.png">


<h3>배경</h3>
생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.
나는 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 차례로 적용하여 말끔이 슈퍼클래스로 옮기곤한다.

<h3>절차</h3>
1. 슈퍼 클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다.
2. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다.
3. 공통 코드를 슈퍼클래스에 추가되고 서브클래들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super() 로 건넨다.
4. 테스트한다.
5. 생성자 시작 부분으로 옮길 수 있는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다.


<h3>예시</h3>

```
-- class Party{}
class Party {}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
  super();
  this._id = id;
  this._name = name;
  this._monthlyCost = monthlyCost;
}

// rest of class...
class Department extends Party {
  constructor(name, staff){
    super();
    this._name = name;
    this._staff = staff;
  }
// rest of class...
}
```

입문을 슬라이드하여 super() 호출 바로 아래로 옮긴다.

```
-- class Employee 
class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._name = name;
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
// rest of class...
}
```

3. 테스트가 성공하면 이 공통 코드를 슈퍼클래스로 옮긴다. 이 코드가 생성자의 인수인 name을 참조하므로 이 인수를 슈처클래스 생성자에 매개변수로 건낸다.

```
-- Party  클래스
constructor(name){
  this._name = name;
}

--Employee 클래스
constructor(name, id, monthlyCost) {
  super(name);
  this._id = id;
  this._monthlyCost = monthlyCost;
}

-- Department 클래스
constructor(name, staff){
  super(name);
  this._staff = staff;
}
```

4. 테스트를 돌려 모두 통과하면 리팩터링이 끝난다.
