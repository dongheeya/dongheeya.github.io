<h1>03. 코드에서 나는 악취</h1>


리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.<br/>
인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하기는 쉽다.<br/>
이런 일들을 언제 해야하는지에 대해서는 명확하게 정립된 규칙이 없다.<br/>

<h2>3.1 기이한 이름</h2>
- 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써라.<br/>
- 마땅한 이름이 떠오르지 않는다면 설계와 같은 더 근본적인 문제가 숨어 있을 가능성이 있다.<br/>
- 이름 짓기는 "변수 이름 바꾸기", "필드 이름 바꾸기" 처럼 이름을 바꾸는 리팩터링 방법이 있다.<br/>
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.<br/>
- 이름을 잘 정리하다 보면 간결해지고 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.<br/>

<h2>3.2 중복 코드</h2>
- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.<br/>
- 중복 코드가 있으면, 차이점을 살펴봐야 하는 부담이 생기며 변경 시에도 다른 비슷한 코드를 확인보고 수정해야 한다.<br/>
- 중복 내용이 있다면, "함수로 추출하기"를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.<br/>
- "문장 슬라이드"를 통해 비슷한 로직을 한곳에 모으고, 함수로 추출 가능한지 살펴보자.<br/>
- 서브 클래스에 중복 내용이 있다면 상위로 위치를 올려보자.(메서드 올리기)<br/>
 
<h2>3.3 긴 함수</h2>
- 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.<br/>
- 짧은 함수들이 얼마나 중요한지 꺠닫게 된다.(간접호출의 효과)<br/>
- 즉, 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점을 함수를 짧게 구성할 떄 나오는 것이다.<br/>

- 요즘 언어에서는 함수 호출 비용이 많이 들지 않는다.<br/>
- 함수 이름을 잘 지어두면 굳이 본문을 안봐도 된다.<br/>
- 그래서 훨씬 적극적으로 함수를 쪼개야된다.<br/>
- 함수를 짧게 만드는 작업의  99%는 함수 추출하기가 차지한다.<br/>

- 조건문이나 반복문도 추출 대상의 실마리를 제공한다.<br/>
- 조건문 분해하기로 대응하다.<br/>
- swtich문을 구성하는 case문마다 함수 추출하기를 적용해서 각 case문 본문을 함수 호출문 하나로 바꾼다.<br/>


<h2>3.4. 긴 매개변수 목록</h2>
- 매겨변수 목록이 길어지면 그 자체로 이해하기 어려울 떄가 많았다.<br/>
- 다른 매개변수에서 값을 얻어오는 매개변수가 있다면, 매개변수를 질의 함수로 바꾸자. (매개변수를 사용하는 코드를 추출해서 사용하자)<br/>
- 객체 통째로 넘기기"를 적용해서 원본 데이터 구조를 그대로 전달한다.<br/>
- 항상 함께 전달되는 매개변수들은 매개변수 객체 만들기로 하나로 묶어버린다.<br/>
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 "플래그 인수 제거하기"로 없애준다.<br/>
- 여러 함수를 클래스로 묶는다면 매개변수를 줄일 수 있다.    <br/>


<h2>3.5. 전역 데이터</h2>
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누까 바꿨는지 찾아낼 매커니즘이 없다는 게 문제다.<br/>
- 이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 "변수 캡슐화하기"다.<br/>
- 이를 위해 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.<br/>



<h2>3.6. 가변 데이터</h2>
- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다.<br/>
- "변수 캡슐화하기"를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.<br/>
- 하나의 변수에 용도가 다른 값들은 저장하느라 값을 갱신하는 경우 "변수 쪼개기"를 이용하여 용도별로 독립 변수에 저장하게 값 갱신이 문제를 일으킬 여지를 없앤다.<br/>

- "문장 슬라이드하기"와 "함수 추출하기"를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.<br/>
- 가능한 "세터 제거하기"도 적용하며, 간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.<br/>
- "여러 함수를 클래스로 묶기"나 "여러 함수를 변환 함수로 묶기"를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.<br/>


<h2>3.7. 뒤엉킨 변경</h2>
- 뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.<br/>
- 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.<br/>
- 순차적으로 실행되는 게 자연스러운 맥락이라면, "단계 쪼개기"를 사용하여 특정 데이터 구조에 담아 전달하는 식으로 단계를 분리한다.<br/>
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어 관련 함수들을 모은다(함수 옮기기)<br/>
- 그러면 그 과정이 "맥락별"로 구분된다.<br/>


<h2>3.8. 산탄총 수술</h2>
- 코드를 변경할 때마다 함께 수정해야 하는 부분이 코드 전반에 퍼져 있다면 발생한다.<br/>
- "함수 옮기기"와 "필드 옮기기"로 모두 한 모듈에 묶자.<br/>
- "여러 함수를 변환 함수로 묶기"로 여러 함수를 클래스로 묶거나, 변환 함수 적용한다.<br/>
- 코드를 재구성할 때에는 덩어리로 뭉쳐지는 것을 개의치 않는다.<br/>


<h2>3.9. 기능 편애</h2>
- 모듈 안에서의 상호작용은 늘리고, 모듈끼리의 상호 작용은 최소화해야 하는데, 이것이 제대로 이루어지지 않은 경우 발생한다.<br/>
- 해당 함수가 원하는 적절한 모듈로 옮겨주자.<br/>


<h2>3.10. 데이터 뭉치</h2>
- 데이터는 뭉쳐 다니는 경향이 있다.<br/>
- 이런 친구들은 하나의 클래스로 묶어주자.<br/>
- 여러 데이터가 묶여서 의미를 만든다면 그것은 데이터 뭉치다.<br/>
- 돌려다니는 데이터 항목들은 보금자리처럼 따로 마련해줘야 마땅하다.<br/>
- 기본형만 고집하지 말고 필드 형태의 데이터 뭉치를 찾아서 "클래스 추출하기"로 하나의 객체로 묶는다.<br/>
- 뭉치를 넘기는 "매개변수 객체 만들기"나 "객체 통째로 넘기기"를 적용해서 매개변수 수를 줄여본다.<br/>
- 그러면 메서드 호출 코드가 간결해진다.<br/>

<h2>3.11. 기본형 집착</h2>
- 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과로 이어지기도 한다.<br/>


<h2>3.12. 반복되는 switch문</h2>
- 코드에 등장하는 switch 문은 모조리 조건부 로직을 다형성으로 바꾸기로 없애야 할 대상으로고 주장한다.<br/>
- 최신 언어에서는 switch문 자체가 문제가 아니라 중복된 switch 문이 문제다.<br/>
- 중복된 switch문은 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다. <br/>
- 이럴 때 switch문의 다형성을 이용하도록 바꿔서 악취를 없애자.<br/>


<h2>3.13. 반복문</h2>
- 반복문보다는 filter, map 등의 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는 지 쉽게 파악할 수 있다.<br/>

<h2>3.14. 성의 없는 요소.</h2>
- 구조를 잡기 위해 사용된 프로그램 요소가 필요 없어 보인다면, 인라인으로 처리해주자.<br/>
- 상속을 사용했다면 "계층 합치기"를 적용한다.<br/>


<h2>3.15. 추측성 일반화</h2>
- '이거 나중에 필요할 거야'라는 생각으로 필요 없는 로직과 후킹 포인트를 만든 경우, 해당 악취가 발생한다.<br/>
- 하는 일이 거의 없는 추상 클래스는 합쳐서 제거하고(계층 합치기)<br/>
- 쓸데없이 위임하는 코드는 "함수 인라인하기"나 "클래스 인라인 코드"로 삭제한다.<br/>
- 그리고 본문에서 사용되지 않는 매개변수는 "함수 선언 바꾸기"로 없앤다.<br/>
- 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다.<br/>
- 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 "죽은 코드 제거하기"로 날려버리자.<br/>


<h2>3.16. 임시 필드</h2>
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.<br/>
- 임시 필드를 갖도록 작헝하면 코드를 이해하기 어렵고 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하는게 어려워진다.<br/>
- 이런 필드들은 "클래스 추출"하기로 옮겨주고, 관련 "함수 옮기기"로 임시 필드들과 관련된 코드를 모조리 새 클래스로 몰아넣는다.<br/>
- 이런 필드의 유효성 체크 로직은 '유효하지 않은 경우'를 위한 대안 클래스를 만들어 제거할 수 있다.<br/>


<h2>3.17. 메시지 체인</h2>
- 메세지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.<br/>
- 이런 문제는 "위림 숨기기"로 해결한다.<br/>
- 리팩터링은 메세지 체인의 다양한 연결점에 적용할 수 있다.<br/>
- 
- 객체를 통해 다른 객체를 얻는 과정이 연쇄적으로 이어질 때에 발생한다.<br/>

- ex) person.job.company.department...<br/>
- getter를 통해 캡슐화로 해결하자.<br/>
- 적절하게 함수로 추출하고 위치를 옮겨 체인을 숨겨보자.<br/>


<h2>3.18. 중개자</h2>
- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.<br/>
- 캡슐화하는 과정에서는 위임이 자주 활용된다.<br/>
- 클래스가 다른 클래스에 구현을 위임하는 '중간 역할'만을 하고 있다면 직접 소통하도록 바꿔주자.<br/>
- 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자(함수 인라인하기)<br/>


<h2>3.19. 내부자 거래</h2>
- 모듈 사이에 데이터 거래가 많으면 결합도가 높아진다.<br/>
- 이를 투명하세 처리하기 위해서는 데이터를 주고받는 모듈끼리 "함수 옮기기"와 "필드 옮기기"기법으로 뗴어놓아서 사적으로 처리하는 부분을 줄일 수 있다.<br/>
- 여러 모듈이 관심사를 공유한다면 해당 부분을 제3의 모듈로 만들자.<br/>
- 상속 구조에서 자식 클래스는 부모 클래스의 데이터에 접근하고 싶은 경우가 많은데, 부모 품을 떠나야 할 때다. 인터페이스로 연결하여 결합도를 낮추자.<br/>


<h2>3.20. 거대한 클래스</h2>
- 클래스가 너무 많은 일을 담당하면 필드 수가 늘어나고 중복 코드가 생기기 쉽다.<br/>
- 클래스가 항시 모든 필드를 사용하지 않을 수도 있다. 이럴 때는 앞에서 언급한 추출 기법을 여러 차례 수행해야 할지도 모른다.<br/>
- 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.<br/>
- 공통 부분은 작은 메서드들로 뽑아내자.<br/>
- 연관된 필드를 묶고 상속 관계의 클래스로 추출하자.<br/>
- 코드량이 너무 많다면 중복을 제거하고 작은 메서드로 추출하자.<br/>

<h2>3.21. 서로 다른 인터페이스의 대안 클래스들</h2>
- 서로 다른 클래스의 두 메서드가, 하는 일은 비슷한데, 인터페이스가 다른 경우, 인터페이스를 통일시키고 가능하다면 추출하자.<br/>


<h2>22. 데이터 클래스</h2>
- 데이터 클래스란 데이터 필드와 게터/세터 메서드들로만 구성된 클래스를 말한다.<br/>
- 게터와 세터, 그리고 데이터 필드로 구성된 데이터 클래스는 다른 클래스가 함부로 다루는 경우가 많다.<br/>
- 필드를 캡슐화하고, 변경하지 못하는 필드는 "레코드 캡슐화하기"로 숨기자<br/>
- 다른 클래스에서 해당 데이터 클래스의 게터나 세터를 사용하는 코드를 찾아서 이를 데이터 클래스로 가져올 수 있는지 살펴보고 가능하다면 옮겨보자.<br/>


<h2>23. 상속 포기</h2>
- 부모 클래스의 특정 부분을 상속받기 원치 않는 경우에 발생한다.<br/>
- 상속하지 않을 부모 코드를 따로 분리해내어, 공통된 부분만 남도록 한다.<br/>
- 하지만 악취가 참을만 하므로 그다지 권하진 않는다.<br/>
- 부모의 인터페이스를 따르고 싶지 않으면 아예 상속 메커니즘에서 벗어나도록, 위임 클래스를 만들고 이를 이용하도록 만들자.<br/>


<h2>24. 주석</h2>
- 주석은 탈취제가 아니다.<br/>
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.<br/>
- 주석 대신 함수 추출하기로 특정 코드 블록을 추출해보자.<br/>
- 주석 대신 함수 이름을 바꿔보자.<br/>
- 선행 조건을 명시하고 싶다면 어서션을 추가할 수도 있다.<br/>
