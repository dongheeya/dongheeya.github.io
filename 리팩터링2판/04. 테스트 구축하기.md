<H1>04. 테스트 구축하기</H1>
리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡아주는 견고한 테스트 스튀트가 뒷바침돼야 한다.
테스트 작성하는데 시간일 뺏긴다고 생각하지말고 왜 효율이 좋아히지는 지 확인해보자.

<H2>자가 테스트 코드의 가치</H2>
프로그래머들이 어떻게 일하는지 가만히 살펴보면 실제로 코드를 작성하는 시간의 비중은 그리 크지 않다.
파악하거나 설계하는데 많이 쓰고 디버깅에 많이쓴다.

반복적 개발론 방법론을 따르게 되면 반복 주기가 하나 끝날 떄마다 가능한 테스트 코드를 추가하게되고, 
그러면 테스트도 쉽고 빠르고 생산성이 급상승한다.
의심되는 코드의 양을 빠르게 줄일 수 있고, 버그를 쉽게 찾을 수 있다.

스몰토크 버전 단위 테스트 프레임워크를 자바로 포팅한 결과가 JUnit이다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다.
기능을 추가해야할 때 테스트부터 작성했다.

테스트 주도 개발이란 기법을 창시했다TDD에서는 테스트를 작성하고 테스르를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을 짧은 주기로 반복한다.

<H2>첫 번째 테스트</H2>
테스트에 가낭 잘 알려진 "모카"를 사용한다.

```
describe('province',function(){
  if('shortfall',runction(){
    const asia = new Province(sampleProvinceData9));   // 픽스처 설정(1)
    assert.equal(asia.shortfall, 5);   // 검증(2)
  });
});
```

(1) 첫 번째 단계에서는 테스트에 필요한 데이터와 객체를 뜩하는 픽스처를 설정한다.
(2) 두 번째 단계에서는 이 픽스처를 속성으로 검증하는데, 여기서는 주어진 초깃값에 기초하여 생산 부족분을 정확히 계산했는지 확인한다.

테스트를 할때에는 실패해야 할 상황에서는 반드시 실패하게 만들자.

예를들면 다음과 같다.

```
get shortfall() {
    return this._demand - this.totalProduction * 2;   //오류 주입
}
```

모카 프레임워클르 사용하면 무언가 문제가 생겼을 때 즉시 알 수 있다.
실패 원인을 추론해볼 수 있는 단서까지 제공한다


간결한 피드백은 자가 테스트에서 매우 중요하고 이는 리팩터링하면서 실수한 것이 없는지 확인하기 위해서이다.

<h2>테스트 추가하기</h2>
클래스가 하는 일을 모두 살펴보고 각각의 기능에서 오류가 생길 수 있는 조건을 하나식 테스트하는 식으로 진행하겟다.
테스트는 위험 요인을 중심으로 작성해야하고,
테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는 데 있다.

잘못됫까봐 가장 걱정되는 영역을 집중적으로 테스트하는데, 이렇게 해서 테스트에 쏙는 노력의 효과를 극대화하는 것이다.



```
if('profit',runction(){
  const asia = new Province(sampleProvinceData9));   // 픽스처 설정(1)
  expect(asis.profit).equal(230);
});
```

위에 소스에서는 기대값 자리에 임의로 값을 넣고 테스트를 수행한 다음, 프로그램이 내놓은 실제 값으로 대체했다
테스트가 제대로 작동하면 원래 코드로 되돌리면 된다.

임시 값을 설정했다가 실제 값으로 대체했고, 오류를 심었다가 되돌리는 이 패턴은 실제로 내가 기존 코드를 검사하는 테스트를 추가할 때 흔히 쓰는 방식이다.


<h2>4.6 경계 조건 검사하기</h2>

범위를 벗어나는 경계 지점에서 문제가 생기면 어떤 일이 벌어지는지 확인하는 테스트도 함께 작성하면 좋다.
그를 통해 경례를 확인하는 테스트를 작성해보면 프로그램에서 이런 특이 상황을 어떻게 처리하는 게 좋을지 생각해 볼 수 있다.

문제가 생길 가능성이 생기는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.



