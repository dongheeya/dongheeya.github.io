  <h1>02. 리팩터링 원칙</h1>
  
  <h2>2.1 리팩터링 정의</h2>
  
  - 리팩터링 : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법<br/>
  - 리팩터링(하다) : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.<br/>

앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.<br/>
리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.<br/>

따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.<br/>

리팩터링하기 전과 후의 코드가 똑같이 동작해야하지만 완전히 똑같다라는 말은 아니다.<br/>
가령 함수 추출하기를 거치면 콜스택이 달라져서 성능이 변할 수 있다.<br/>
하지만 '사용자 관점'에서는 달라지는 점이 없어야한다.<br/>


<h2>2.3 리팩터링 하는 이유</h2>
리팩터링이 소프트웨어의 모든 문제를 해결하는 만병통치약은 절대 아니다.<br/>
코드를 건강한 상태로 유지하는 데 도와주는 역할을 하는 것이다.<br/>

<h3>리팩터링하면 소프트웨어 설계가 좋아진다.</h3>
리팩터링하지 않으면 소프트웨어 설계가 썩기 쉽다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.<br/>
코드만 봐서는 설계를 파악하기 어려워진다.<br/>
그래서 악순환으로 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.<br/>

같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다.<br/>
코드량을 줄인다고 시스템이 빨라지는 것은 아니다.<br/>
하지만 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.<br/>
비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다.<br/>
반면 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.<br/>

<h3>리팩터링하면 소프트웨어를 이해하기 쉬워진다.</h3>
프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다보니 나만 코드를 읽을 뿐만 아니라 다른 사람들도 읽을 것이다.<br/>
따라서 누군가가 내 코드를 쉽게 읽을 수 있게된다면 금방 수정할 수 있게 된다.<br/>

코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다.<br/>
리팩터링은 코드가 더 잘 읽히게 도와준다.<br/>

다른 사람을 위한 배려가 아닌 나를 위한 배려로 리팩터링 하자.<br/>

<h3>리팩터링하면 버그를 쉽게 찾을 수 있다.</h3>
코드를 읽기 쉽다는 소리는 버그를 찾기 쉽다는 말이기도 하다.<br/>
리팩터링하면 코드가 하는 일을 깊이 파악학 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.<br/>

<h3>리팩터링하면 프로그래밍 속도를 높일 수 있다.</h3>
새로운 기능을 추가할수록 기존 코드베이스에 작 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.<br/>
게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간이 한층 더 걸린다.<br/>

그래서 리팩터링하는 부담에 기능 추가 속도가 계속 떨어지게 되고, 차라리 처음부터 다시 개발하는 편이 낫다고 생각하는 지경에 이르게 된다.<br/>

20년 전만 해도 설계를 잘하려면 코딩을 시작하기 전에 설계부터 완벽히 마쳐야 한다는 것이 정설이다.<br/>
코딩 단계에 한번 들어서면 코드가 부패할 일만 남기 때문이다.<br/>
이를 리팩터링으로 해결할 수 있다.<br/>
리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개션할 수 있다.<br/>

<h2>2.4 언제 리팩터링해야 할까?</h2>
<h3>준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기</h3>
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.<br/>
이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워진 만한 부분을 찾는다.<br/>

<h3>이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기</h3>
코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.<br/>
코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.<br/>

리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다.<br/>
그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 그리고 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.<br/>

<h3>쓰레기 줍기 리팩터링</h3>
코드를 파악사던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다.<br/>
로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다.<br/>

지은이는 간단히 수정할 수 잇는 것은 즉시 수정하고, 시간이 좀 걸리는 일은 짧은 메모만 님긴 다음, 하던 일을 끝내고 나서 처리한다고 한다.<br/>
급한 일이 없다면 조금이나마 개션해두는 것이 좋다.<br/>

<h3>계획된 리팩터링과 수시로 하는 리팩터링</h3>
리팩터링은 프로그래밍과 구분되는 별개의 활동은 아니다.<br/>
보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.<br/>

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 수정하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.<br/>
소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다.<br/>

그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.

계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다.<br/>
리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야된다.<br/>

<h3>오래 걸리는 리팩터링</h3>
리팩터링은 대부분 몇 분 안에 끝난다.<br/>
하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.<br/>
예를 들어 라이브러리를 새 것으로 교체하는 작업일 수도 있고 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.<br/>

이러한 상황에 처하더라도 팀 전체가 리팩터링하는 것보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 떄가 많다.<br/>
누구든지 리팩터링해야 할 코드와 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.<br/>

<h3>코드 리뷰에 리팩터링 활용하기</h3>
코드 리뷰를 정기적으로 수행하는 조직도 있다.<br/>
코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다.<br/>
경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.<br/>

리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다.<br/>
리팩터링을 활용하기 전에는 코드를 읽고, 그럭저럭 이해한 뒤, 몇 가지 개선 사항을 제시했다.<br/>
그리고 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 잇는지 살펴보는 것이 좋다.<br/>

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다.<br/>
개선안들을 제시하는 것에서 그치지 않고, 그 중 상당수를 즉시 구현해볼 수 있기 때문이다.<br/>

코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다.<br/>
코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다.<br/>
내가 경험한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 방식인 "짝 프로그래밍"도 좋다.<br/>

<h3>리팩터링하지 말아야 할 때</h3>
저자는 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다고한다.<br/>
외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.<br/>
내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.<br/>

<H2>2.5 리팩터링 시 고려할 문제</H2>
<H3>새 기능 개발 속도 저하</H3>
많은 사람이 리팩터링 때문에 새 기능을 개발하는 속도가 느려진다고 여기지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다.<br/>
리팩터링으로 인해 진행이 느려진다고 생각하는 사람이 여전히 많다.<br/>

상황에 맞게 조율해야 한다.

새기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다.<br/>
반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편이다.<br/>

리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다.

<H3>브랜치</H3>
현재 흔히 쓰이는 방법은 팀 단위 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나식 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서
다른 팀원과 공유하는 것이다.<br/>

이 방식의 장점은 작업이 끝나지 않은 코드가 마스터에 섞이지 않고 기능이 추가될 때마다 버전을 명확히 나눌 수 있고, 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있다.

하지만 이 방식의 단점은 독립 브랜치로 작업하는 기간이 길어질 수록 작업 결과를 마스터로 통합하기가 어려워진다.<br/>
그리고 많은 이들이 마스터로 개인 브랜치로 수시로 리베이스하거나 머시하면 여러 개능 브래치에서 동시에 개발이 진행될 시에 이런 식으로는 해결할 수 없다.<br/>

따라서 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해아한다고 주장하는 사람이 많다.<br/>
이러한 방식을 CI(지속적 통합) 또는 트렁크 기반 개발(TBD)이라 한다.<br/>
이렇게 하면 다른 브랜치들과 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다.

머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋다.<br/>
리팩터링하다보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다.<br/>
EX)프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예이다.<br/>

머지 과정에서 의미 충돌이 생기기가 쉽다. 이를 위해 CI와 리팩터링을 합쳐서 XI(익스프림 프로그래밍)이 생겼다.<br/>


<H3>테스팅</H3>
리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다.<br/>
절차를 지켜 제대로 리팩터링하면 동작이 꺠지지 않아야 한다.<br/>

실수를 하더라도 재빨리 해결하면 문제가 되지 않는다. 리팩터링은 단계별 변경폭이 작아서 도중 발생한 오류의 원인이 될만한 코드 범위가 넓지 않는다.

실제로 이렇게 하기 위해서는 다양한 측면을 검사하는 테스트 스튀으가 필요하다.<br/>
이를 빠르게 수행할 수 있어야 수시로 테스트하는 데 부담이 없다.<br/>

수십 년 동안 자가 테스트를 이용하여 소프트웨어를 빌드하는 팀을 많이 봤다.<br/>
물론 테스트에 어느 정도 노력을 기울여야 하는 것은 사실이지만, 효과는 상당하다.<br/>
자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능을 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.<br/>
그리고 실수로 만든 버그를 빠르게 찾아서 제거할 수 있다.<br/>

<H3>레거시 코드</H3>
물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.<br/>
무엇보다도 다른 사람이 작성한 것이다.<br/>

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다.

대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

테스트를 갖추고 있더라도 복합하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다.<br/>
레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다.<br/>

<H3>데이터베이스</H3>
데이터베이스의 리팩터링 방법은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터마이그레이션 스크립트를 작성하고, <br/>
접근 코드와 데이터베이스 스키나에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.<br/>

전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.<br/>
데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.<br/>








