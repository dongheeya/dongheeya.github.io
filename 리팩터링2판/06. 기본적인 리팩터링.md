저자가 가장 많이 사용하는 리팩터링은 함수 추출하기와 변수 추출하기이다.<br/>
리팩터링은 본래 코드를 변경하는 작어빈 만큼, 이 두 리패겉링을 반대로 진행하는 함수 인라인하기와 변수 인라인하기도 자주 사용한다.<br/>

- 함수 추출하기 : 결국 이름 짓기. 코드 이해도가 높아지다 보면 이름을 바꾸야 할 때가 많다.<br/>
- 함수 선언 바꾸기 : 함수의 이름을 변경할 때 많이 쓰인다. 함수의 인수를 추가하거나 제거할 때도 이 리팩터링을 적용한다.<br/>
- 변수 이름 바꾸기 : 바꿀 대상이 변수라면 사용<br/>
- 변수 캡슐화하기 : 변수 이름 바꾸기와 관련이 깊고, 배개변수 객체 만들기를 적용해 객체 하나로 묶으면 편리하게 사용가능하다.<br/>

- 여러 함수를 클래스로 묶기 : 함수를 만들고 나면 다시 고수준 모듈로 묶는 작업으로 이때 함수들이 사용하는 데이터도 클래스로 함께 묶는다.<br/>
- 여러 함수를 변환 함수로 묶기 : 일기 전용 데이터를 다룰 때 특히 좋다.<br/>
- 단계 쪼개기 : 한데 묶은 모듈들의 작업 처리 과정을 명확한 단계로 구분 짓기<br/>



<H2>6.1 함수 추출하기 (EXTRACT FUNCTION)</H2>

![image](https://user-images.githubusercontent.com/87962572/179374098-16a12cfb-bf29-4bd0-a7fb-d9a8c09e1fee.png)

1. 배경 : 여기서 객체는 객체 지향 언어의 메서드나 절차형 언어의 프로시져. 서브 루틴도 모두 똑같이 적용된다.<br/>
   - 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.<br/>
   - 코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 많다.(길이, 재사용성, 목적과 구현분리)<br/>
   - a.길이 : 가령 함수 하나가 한 화면을 넘어가면 안 된다.<br/>
   - b.재사용성 : 두 번 이상 사용될 코드를 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것이다.<br/>
   - c.목적과 구현의 분리 : 가장 합리적인 기준으로 코드를 보고 무슨 일을 하는지 파악한 다음에 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 붙인다.<br/>
          그러면, 나중에 코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고, 본문 코드에 대해서 더 이상 신경 쓸 일이 없어진다.<br/>

1.a.길이 : <-> 길이는 그리 중요하지 않다(오리지널 스몰 토크 시스템)<br/>
 - 흑백 시스템을 구현할 때 텍스트나 그래픽을 강조하기 위해 색상을 반전시켰는데. 이때 higlight() 메서드를 구현하였다.<br/>
 - 코드의 목적과 구현 사이의 차이가 그만큼 컸다.<br/>
 - 함수를 짧게 쓰면 성능이 느려진다? -> No. 함수가 짧아지면 캐싱하기가 더 쉬워서 컴파일러하기가 유리할 때가 많다.<br/>


2. 절차 : <br/>
  - a. 함수를 새로 만들고 목적이 잘 드러나는 이름을 짓는다. (무엇을 하는지 드러나야 한다.) <br/>
        - 반대로 이름이 떠오르지 않는다면 함수로 추출하면 안된다.<br/>
        - 일단 함수로 추출해서 사용해보고 효과가 크지 않으면 다시 원래 상태로 인라인해도 된다.<br/>

  - b. 추출할 코드를 원본 함수에서 복사해서 새 함수에 붙여넣는다.<br/>
  - c. 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.<br/>
        - 일반적으로 지역 변수와 매개변수가 있다. 가장 일반적인 처리 방법은 이런 변수를 모두 인수로 전달한다. 사용은 하지만 값이 바뀌지 않는 변수는 대체로 이렇게 처리한다.<br/>
        - 추출한 코드에서만 사용하는 변수가 함수 밖에 선언되어 있다면, 추출한 함수 안에서 선언하도록 수정한다.<br/>
        - 추출한 코드 안에서 값이 바뀌는 변수 중에서 값으로 전달되는 것들은 주의해서 처리하고, 이런 변수가 하나라면 추출한 코드를 질의 함수로 취급해서 그 결과를 해당 변수에 대입한다.<br/>
        - 때로눈 추출한 코드에서 값을 수정하는 지역 변수가 너무 많을때에는 변수 쪼재기나 임시 변수를 질의 함수로 바꾸기와 같은 다른 리팩터링 방법을 살펴본다.<br/>
  - d. 변수를 다 처리했다면 컴파일한다.
  - e. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
  - f. 테스트한다
  - g. 다른 코드 방금 추출한 것과 똑같거나 비슷한 코드가 있는지 살펴보고 있다면 새 함수를 호출하도록 바꿀지 검토한다.


3. 예시. 유효범위를 벗어나는 변수가 없을 때.

```
function printOwing(invoice) {
  let outstanding = 0;
  
  console.log("***********************");
  console.log("**** Customer Owes ****");
  console.log("***********************");
  
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  // record due date
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  
  //print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);
  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}
```

여기에서 Clock.today는 Clock Wrapper라고 부르는 것으로, 시슽메 시계를 감싸는 객체다.
Date.now()처럼 시스템 시간을 알려주는 함수는 직접 호출하지 않는다.


```
function printOwing(invoice) {
  let outstanding = 0;
  
  printBanner(); // 함수 추출하기 사용
  
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  // record due date
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  //print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);
  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
  }
  
  function printBanner() {
  console.log("***********************");
  console.log("**** Customer Owes ****");
  console.log("***********************");
}
```

해당 배너를 추출하는 소스를 printBanner로 간단히 추출할 수 있다.<br/>
그냥 해당 코드를 잘라내서 새 함수로 붙이고, 원래 자리에 새 함수 호출문을 넣으면 된다.<br/>

```
function printOwing(invoice) {
  let outstanding = 0;
  
  printBanner();
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  // record due date
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  printDetails();   // 세부사항 로직을 다음과 같이 정의한다. 지역변수 사용하고 있어 첫단계로는 안에서 function 정의
  
  function printDetails() {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
    console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
  }
}
function printBanner() {
  console.log("***********************");
  console.log("**** Customer Owes ****");
  console.log("***********************");
}

```


2. 예시. 지역 변수를 사용할 때

지역 변수와 관련하여 가장 간단한 경우는 변수를 사용하하지만 다른 값을 다시 대입하지 않을때다.<br/>
이 경우에는 지역 변수들을 그냥 매개변수로 넘기면 된다.<br/>

```
function printOwing(invoice) {
  let outstanding = 0;
  printBanner();
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  // record due date
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  //print details
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);
  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}

```
   
세부 사항을 출력하는 코드를 다음과 같이 지역 변수 두 개를 매개변수로 받는 함수로 추출한다.

```
function printOwing(invoice) {
let outstanding = 0;
  printBanner();
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  // record due date
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  
  printDetails(invoice, outstanding);  // 앞에 예와 달리 지역 변수를 매개변수로 전달
  
}

function printDetails(invoice, outstanding) {
  console.log(`name: ${invoice.customer}`);
  console.log(`amount: ${outstanding}`);
  console.log(`due: ${invoice.dueDate.toLocaleDateString()}`);
}
```

지역 변수가 (배열, 레코드, 객체와 같은) 데이터 구조라면 똑같이 매개변수로 넘긴 후 필드값을 수정할 수 있다.<br/>
가령 마감일을 설정하는 코드는 다음과 같이 추출한다.<br/>

```

function printOwing(invoice) {
  let outstanding = 0;
  printBanner();
  
  // calculate outstanding
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  recordDueDate(invoice);  // 마감일 설정 로직을 함수로 추출
  printDetails(invoice, outstanding);
}

function recordDueDate(invoice) {
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
}
```

3. 예시: 지경 변수의 값을 변경할 때

지역 변수에 값을 대입하게 되면 문제가 복잡해진다.<br/>
지금은 임시 변수만을 취급한다.<br/>
만약 매개변수에 값을 대입하는 코드를 발견하면, 곧바로 그 변수를 쪼개서 임시 변수를 새로 하나 만들어 그 변수에 대입하게 되면 된다.<br/>

대입 대상이 되는 임시 변수를 크게 두 가지로 나눌 수 있다.<br/>
먼저 간단한 경우는 변수가 추출된  코드 안에서만 사용할 때다.<br/>
만약 변수가 초기화되는 지점과 실제로 사용되는 지점이 떨어져 있다면 문장 슬라이드하기를 활용해서 변수 조작을 모두 한곳에서 처리하도록 모아두면 편하다.<br/>

```
function printOwing(invoice) {

  printBanner();
  
  
  let outstanding = 0;   // 맨 위에 있던 선언문을 이 위치로 이동
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

```

그런 다음 추출한 부분을 새로운 함수로 복사한다.

```
function printOwing(invoice) {

  printBanner();
  
  // 추출 필요한 코드 ~~
  let outstanding = 0;
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  
  //  ~~ 여기까지
  
  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

// 추출할 코드 복사
function calculateOutstanding(invoice) {   
  let outstanding = 0;   
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding;
}
```


추출한 코드의 원래 자리를 새로 뽑아낸 함수를 호출하는 문장으로 교체한다.<br/>
추출한 함수에서 새값을 반환하니, 이 값을 원래 변수에 저장한다.<br/>

```
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding(invoice);   // 함수 추출 완료. 추출한 함수가 반환한 값을 원래 변수에 저장한다.
  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutstanding(invoice) {
  let outstanding = 0;
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding;
}

```

마지막으로 반환 값 이름을 코딩 스타일에 맞게 바꾼다.

```
function printOwing(invoice) {
  printBanner();
  
  const outstanding = calculateOutstanding(invoice);   // 원본 변수인 const타입으로 변경하여 불변으로 만들었다.
  
  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}
  
function calculateOutstanding(invoice) {
  let result = 0;   // 변수 이름 변경
  for (const o of invoice.orders) {
    result += o.amount;
  }
  return result;
}
```

<h2>6.2 함수 인라인하기</h2>

![image](https://user-images.githubusercontent.com/87962572/179374753-48021c59-5b9b-4dc2-b6d1-6f4db60d7500.png)


1. 배경 : 함수 본문이 이름만큼 명확한 경우도 있다. 함수 본문 코드를 이름만큼 깔끔하게 리팩터링할 때도 잇다. 이럴 때는 그 삼루를 제거한다.<br/>
      - 간접 호출은 유용할 수도 있지만 쓸데없는 간접 호출은 거슬릴 뿐이다.<br/>
      - 리팩터링 과정에서 잘못 추출된 함수들도 다시 인라인한다.<br/>
      - 잘못 추출된 함수들을 원래 함수로 합친 다음, 필요하면 원하는 형태로 다시 추출하는 것이다.<br/>
      - 간접 호출을 너무 과하게 쓰는 코드도 흔한 인라인 대상이다.<br/>
      - 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게 얽혀 있으면 인라인해버린다.<br/>
      - 간접 호출을 유지하는 편이 나은 경우도 있겟지만, 모두 그렇지는 않을 것이다.<br/>
      - 함수 인라인을 할용하면 유용한 것만 남기고 나머지는 제거할 수 있다.<br/>

2. 절차 :
   - a. 다형 메서드인지를 확인한다.<br/>
   - b. 인라인할 함수를 호출하는 곳을 모두 찾는다<br/>
   - c. 각 호출문은 함수 본문으로 교체한다.<br/>
   - d. 하나씩 교체할 때마다 테스트한다.<br/>
   - e. 함수 정의를 삭제한다.<br/>

3. 예시

원본 예시
```
function rating(aDriver) {
  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(aDriver) {
  return aDriver.numberOfLateDeliveries > 5;
}

```

이 경우에는 반환 호출문을 그대로 복사해서 호출하는 함수의 호출문을 덮어쓰면 끝이다.

```
function rating(aDriver) {
  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;
}
```

그런데 복사한 코드가 새로운 위치에 잘 들어맞도록 손봐줘야 하는 경우도 있다.
만약에 인수 이름이 다르게 정의되어있다면 어떻게 해야되나?

```
function rating(aDriver) {
  return moreThanFiveLateDeliveries(aDriver) ? 2 : 1;
}
// aDriver를 매개변수로 전달하고, 전달받은 함수에서는 dvf로 정의되어있다면?
function moreThanFiveLateDeliveries(dvr) {
  return dvr.numberOfLateDeliveries > 5;
}

```

아래와 같이 정의해준다.


```
function rating(aDriver) {
  return aDriver.numberOfLateDeliveries > 5 ? 2 : 1;
}
```

이보다 일이 더 많은 경우도 있다.

```
function reportLines(aCustomer) {
  const lines = [];
  gatherCustomerData(lines, aCustomer);
  return lines;
}
function gatherCustomerData(out, aCustomer) {
  out.push(["name", aCustomer.name]);
  out.push(["location", aCustomer.location]);
}
```

단순히 잘라붙이는 식으로는 gatherCustomerData()를 reportLines()로 인라인할 수 없다.<br/>
실수하지 않으려면 한 번에 한 문장씩 옮기는 것이 좋다.<br/>

```
function reportLines(aCustomer) {
  const lines = [];
  lines.push(["name", aCustomer.name]); -> 이동!
  gatherCustomerData(lines, aCustomer);
  return lines;
}
function gatherCustomerData(out, aCustomer) {
  out.push(["name", aCustomer.name]); -> 삭제 
  out.push(["location", aCustomer.location]);
}
```
나머지 문장도 같은 식으로 처리한다.

```
function reportLines(aCustomer) {
  const lines = [];
  lines.push(["name", aCustomer.name]);
  lines.push(["location", aCustomer.location]);
  return lines;
}
```

한문장씩 작업을 해야. 실패시에 다시 돌아가기 쉽다.


<h2>6.3 변수 추출하기</h2>

![image](https://user-images.githubusercontent.com/87962572/179374947-156c526a-100b-4ec4-9000-cba49abb6d5c.png)

1. 배경 : 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다. 그러면 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어 코드의 목적을 훨씬 명확하게 드러낼 수 있다.<br/>
  - 이름이 통용되는 문맥이 넓힐 때에는 임시 변수를 질의 함수로 바구기를 적용할수 있을 때까지 일단 놔두고, 처리할 수 있을때 즉시 넓혀서 다른 코드에서도 사용할 수 있게 한다.<br/>


2. 절차 : 
  - a. 추출하려는 표현식에 부작용이 없는지 확인한다.<br/>
  - b. 불변 변수를 하나 선언하고 이름을 붙일 표현식을 복제본을 대입한다.<br/>
  - c. 원본 표현식을 새로 만든 변수로 교체한다.<br/>
  - d. 테스트한다.<br/>
  - e. 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다.<br/>


3. 예시

```
function price(order) {
  // 가격 = 기본가격 - 수량 할인 + 배송비
  return order.quantity * order.itemPrice ­
    Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 +
    Math.min(order.quantity * order.itemPrice * 0.1, 100);
}

```

이를 더 쉽게 만들 수 있다.<br/>
먼저, 기본 가격은 상품 가격에 수량을 곱한 값임을 파악해야 한다.<br/>
그리고 로직을 이해했다면, 기본 가격을 담을 변수를 만들고 적절한 이름을 지어준다.<br/>


```
function price(order) {
  // 가격 = 기본가격 - 수량 할인 + 배송비
  const basePrice = order.quantity * order.itemPrice;
  return basePrice ­
    Math.max(0, order.quantity ­ 500) * order.itemPrice * 0.05 +
    Math.min(order.quantity * order.itemPrice * 0.1, 100);
}

```
