<H1>6장.스프링 부트 API 서버 구축</H1>

해당 장에서는 외부 시스템을 위한 인터페이스인 API서버를 만드는 방법을 알려준다.<br/>
- JSON 기반 웹 서비스 구축<br/>
- 스프링 레스트 독을 활용한 API 문서화<br/>
- 스프링 부트로 만든 API 포털에서 다양한 API 제공<br/>
- 스프링 헤이티오스HATEOAS를 사용한 하이퍼미디어 활용<br/>
- API 포털에 하이퍼미디어 링크 추가<br/>

<H2>HTTP 웹 서비스 구축</H2>

가장 단순한 API 서버는 쿼리를 실행하고 결과를 반환한다.<br/>
오늘날 이커머스와 매시업 분야에서 가장 중요한 키워드는 JSON이다.<br/>
HTML 대신 JSON을 반환하는 스프링 웹플럭스 엔드포인트는 아주 쉽게 만들 수 있다.<br/>

EX. 리포지토리에서 데이터를 가져와서 모델을 생성하고, 모델을 템플릿에 바인딩해서 화면을 반환하는 대신 데이터를 그대로 직접 반환하면 어떻게 될까?<br/>

```
@RestController
public class ApiItemController {
  private final ItemRepsoitory repository;  -- (1)
  
  public ApiItemController(ItemRepository repository) _
    this.repository = repository; -- (2)
  }
}
```

(1) @RestController는 html대신 데이터를 응답 분문에 직접 써서 반환하는 스프링 웹 컨트롤러임을 나타낸다.<br/>
  - RestController는 스프링이 컴포넌트 소캐닝을 통해 자동으로 감지하고 빈으로 등록한다는 관점에서 기존의 @Controller와 같다.<br/>
  - 하지만, 웹 요청이 들어오면 @RestController가 붙은 클래스의 메소드는 화면 HTML을 렌더링하는 데 사용되는 값을 반환하지 않는다.<br/>
  - 대신 데이터 자체를 반환하고, 반환된 데이터 객체는 직렬화되고 응답 본문에 직접 기록된다.<br/>
(2) 5장까지 만들어진 Repository이다.<br/>
(3) ItemRepository는 생성자를 통해 주입된다.<br/>


```
@RestController
public class ApiItemController {
  private final ItemRepsoitory repository;  -- (1)
  
  public ApiItemController(ItemRepository repository) {
    this.repository = repository; -- (2)
  }
  
  @GetMapping("/api/items") -- (3)
  Flux<Item> findAll(){ -- (4)
    return this.repository.findAll(); -- (6)
  }
}

```

(3) @GetMapping("/api/items") 애너테이션은 /api/items로 들어오는 Get 요청 처리를 담당하는 메서드임을 나타낸다.<br/>
(4) Flux<Item>을 반환하므로 0개 또는 그 이상의 Item 객체가 JSON 구조로 직렬과돼서 응답 본문에 기록된다.<br/>
(5) 상품의 조회는 ItemRepositoy에 위임한다. ItemResitory.findAll() 메서드가 호출 결과인 Flux<Item>를 반환한다.<br/>
  
한 개의 Item 객체를 조회하는 것도 어렵지 않다.

```
@GetMapping("/api/items/{id}") -- (1)
Mono<Item> findOne(@PathVariable String id) { -- (2)
    return this.repository.findById(id); -- (3)
}
```
  
(1) /api/items/{id}로 들어오는 GET 요청을 처리한다. {id}는 Item객체의 키 값을 가리킨다.<br/>
  ex) /api/items/42 -> 키 값이 42인 Item을 반환한다.<br/>
(2) 키를 지정해서 '하나'의 Item객체만 요청하고 있으므로 Mono<Item>을 반환한다.<br/>
  {id}로 들어오는 값과 @PathVariable에 들어오는 id와 같으므로 위와 같이 표현하고, <br/>
  만약에 다르다면, @PathVariable("id") String itemId와 같이 템플릿 변수 이름도 함께 명시해준다.<br/>
  
(3) 스프링 데이터의 findById() 메소드를 호출하고 결과를 그대로 반환하므로 리스트 6-2와 마찬가지로 별다른 처리 없이 데이터 저장소로의 연결 통로 역할만 한다.<br/>
  
조회가 아니라 새로운 Item객체를 저장해야 한다면 다른 접근방식이 필요하다.
  
```
@PostMapping("/api/items") // <1>
Mono<ResponseEntity<?>> addNewItem(@RequestBody Mono<Item> item) { // <2>

  return item.flatMap(s -> this.repository.save(s)) // <3>
      .map(savedItem -> ResponseEntity //
          .created(URI.create("/api/items/" + //
              savedItem.getId())) // <4>
          .body(savedItem)); // <5>
}
```
  
(1) @PostMapping("/api/items") : /api/items/로 들어오는 POST 요청을 처리한다.<br/>
  새로 생성되는 Item객체의 id값은 몽고 디비에 저장되기 전까지는 알수 없으므로 요청 URI에 id는 필요하지 않다.<br/>
  
(2) 새로운 Item을 생성해서 추가하므로 이름을 addNewItem으로 명칭했고, @RequestBody 애너테이션은 요청 본문이 인자로 사용된다라는 것을 뜻한다.<br/>
  인자 타입이 리액터 타입인 Mono이므로 이 요청 처리를 위한 리액티브 플로우에서 구독이 발생하지 않으면 요청 본문을 Item 타입으로 역직렬화하는 과정도 실행되지 않는다.<br/>
  
(3) 이 단계에서는 데이터를 저장하는 것이 목적이므로 요청 본문으로 들어온 item객체에 map이나 flatMap연산을 적용하면 된다.<br/>
  이 중, 인자로 받은 Mono에서 꺼낸 후 스프링 데이터의 save() 메서드에 전달되고 다시 Mono를 반환하므로 flatMap을 사용해아한다.<br/>
  
(4) created() 메서드를 사용해서 새로 생성된 Item 객체의 id값을 포함하는 URI를 응답 메세지에 담아 반환한다.
  
(5) ResponseEntity.created() 메서드는 새로 생성된 savedItem 객체를 응답 본문에 담아 반환할 수 있다.<br/>
  saveItem 객체를 직렬화해서 응답 본문에 적는 일은 스프링 웹플럭스가 담당한다.<br/>
  
```
@PutMapping("/api/items/{id}") // <1>
public Mono<ResponseEntity<?>> updateItem( //
    @RequestBody Mono<Item> item, // <2>
    @PathVariable String id) { // <3>

  return item //
      .map(content -> new Item(id, content.getName(), content.getDescription(), //
          content.getPrice())) // <4>
      .flatMap(this.repository::save) // <5>
      .map(ResponseEntity::ok); // <6>
}
  
```
  
(1) @PutMapping("/api/items/{id}")가 붙은 메소드는 /api/items/{id}로 들어오는 PUT요청을 처리한다.<br/>
  HTTP PUT은 교체를 의미하며, 교체 대상이 존재하지 않으면 새로 생성한다.<br/>

(2) @RequestBody가 붙어 있으므로 교체에 사용할 Item정보를 응답 본문에서 추출한다.<br/>
(3) 교체를 하려면 교체 대상을 지정해야 하므로 id 값이 필요하다. @PathVaribale 을 사용해서 uri에서 id값을 받아온다.<br/>
(4) 응답 본문에 들어 있는 Item 객체의 id값과 요청 URI에 지정된 ID값이 다를 수 있다는 점에 유의해야 한다.<br/>
  교체 대상은 요청 URI에 지정된 id값을 기준으로 판별해야 하며, map연산을 통해 응답 본문에 담겨 있는 Item상세 정보와 {id} 값으로 새로운 Item인스턴스를 생성한다.<br/>
(5) savee() 메서드는 Item객체를 Mono에 담아 반환하고, flatMap 메소드는 Item 객체를 꺼내서 다시 Mono에 담아 반환한다.<br/>
(6) thenReturn 메소드는 스프링 웹의 ResponseEntity.ok() 헬퍼 메소드를 사용해서 교체 후, 데이터를 HTTP 200 Ok와 함께 반환한다.<br/>
  
  
<h2>API 포털 생성</h2>
웹 서비스를 출시한 후에는 사용자에게 사용법을 알려줘야 한다.<br/>
가장 좋은 방법은 API 포털을 만들고 사용자에게 필요한 정보를 제공하는 것이다.<br/>

소프링 레스트 독이 API 문서화 작업을 도와준다.<br/>
스프링 레스트 독을 프로젝트에 추가하면 사용자가 직접 사용해볼 수 있는 API예제를 포함해서 API 문서를 쉽게 만들어낼 수 있다.<br/>

```
//pom.xml에 아시키닥터를 추가한다.
<plugin>
  <groupId>org.asciidoctor</groupId>
  <artifactId>asciidoctor-maven-plugin</artifactId>
  <version>1.5.3</version>
  <executions>
    <execution>
      <id>generate-docs</id>
      <phase>prepare-package</phase>
      <goals>
        <goal>process-asciidoc</goal>
      </goals>
      <configuration>
        <backend>html</backend>
        <doctype>book</doctype>
      </configuration>
    </execution>
  </executions>
  <dependencies>
    <dependency>
      <groupId>org.springframework.restdocs</groupId>
      <artifactId>spring-restdocs-asciidoctor</artifactId>
      <version>${spring-restdocs.version}</version>
    </dependency>
  </dependencies>
</plugin>
```

asciidoctor-maven-plugin은 확장자가 .adoc인 아스키독 파일을 HTML로 변환해준다.
스프링 레스트 독은 아스키독 파일의 주요 내용을 자동으로 생성해준다.
그래서 스프링 레스트 독이 자동 생성해준 아스키독 파일을 asciidoctor-maven-plugin이 HTML로 만들어준다.
최종 HTML은 target/generated-docs 디렉터리에 저장한다.
  
스프링 레스트 독은 기본적으로 src/main/asciidoc 디렉터리에서 이스키독 파일을 읽어서 주요 내용을 자동으로 생성하므로 src/main/asciidoc/indoex.adoc 파일을 만들고
새 API 포털의 도입부를 직접 작성해야 한다.
  
```
= 스프링 부트 실전 활용 마스터

웹 서비스를 출시하면 개발자들에게 사용법을 알려줘야 합니다.

스프링 레스트 독 덕분에 테스트 케이스에서 서비스의 모든 상호 작용을 추출하고 읽기 좋은 문서를 자동으로 만들 수 있으며, +
IDE를 통해 아주 쉽게 작업을 수행할 수 있습니다.


다음 요청을 실행하면:
```
  
만들고 있는 API와 연게할 수 있는 더 나은 방법이 있다면 먼저 spring-restdocs-webtestclient를 추가한다.
  
```
<dependency>
  <groupId>org.springframework.restdocs</groupId>
  <artifactId>spring-restdocs-webtestclient</artifactId>
  <scope>test</scope>
</dependency>
```
  
테스트 스코프로 추가된 spring-restcods-webtestclient는 스프링 웹플럭스 컨트롤러를 테스트할 수 있게 해주는 WebTestClient에 스프링 레스트 독 기능을 추가해준다.
  
스프링 부트에 정적 웹 컨텐츠 제공 기능과 스프링 레스트 독을 조합하면 항상 애플리케이션의 최신 상태가 반영된 문서를 제공할 수 있다.
쉽게 요약하면 스프링 레스트 독으로 자동 생성한 문서를 스프링 부트의 정적 웹 컨텐츠 제공 디렉터리로 복사하면 된다.

```
  <plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <version>2.7</version>
    <executions>
      <execution>
        <id>copy-resources</id>
        <phase>prepare-package</phase>
        <goals>
          <goal>copy-resources</goal>
        </goals>
        <configuration>
          <outputDirectory>${project.build.outputDirectory}/static/docs</outputDirectory>
          <resources>
            <resource>
              <directory>${project.build.directory}/generated-docs</directory>
            </resource>
          </resources>
        </configuration>
      </execution>
    </executions>
  </plugin>
```
  
maven-resources=plugin을 위와 같이 설정해서 추가하면 jar 파일 생성시 target/generated-docs에 있는 모든 파일을 정적 웹 컨텐츠 서비스 디렉터리인 
target/clasees/statics/docs로 복사한다.
  
테스트 케이스를 작성하고 api문서를 자동 생성해볼 모든 준비가 끝난다.

```
@WebFluxTest(controllers = ApiItemController.class) // <1>
@AutoConfigureRestDocs // <2>
public class ApiItemControllerDocumentationTest {

	@Autowired private WebTestClient webTestClient; // <3>

	@MockBean InventoryService service; // <4>

	@MockBean ItemRepository repository; // <5>
  
```
<1> : @WebFluxTest는 웹플럿르 컨트롤러 테스트에 필요한 내용만 자동설정되게 한다.<br/>
  ApiItemController.class를 지정하면 이 테스트 클래스는 오직 ApiItemController.class만 집중적으토 테스트한다.<br/>
<2> : @AutoConfigureRestDocs는 스프링 레스트 독 사용에 필요한 내용을 자동으로 설정해준다.<br/>
<3> : 웹플럭스 컨트롤러 호출에 사용되는 WebTestClient를 자동 주입한다.<br/>
<4> : @WebFluxTest는 웹플럭스 컨트롤러 테스트에 필요한 내용만 자동으로 설정하고, 서브스를 포함한 그 외의 커포넌트는 생성하지 않는다.<br/>
  @MockBean을 붙여주면 해당 클래스의 목 개게를 자동으로 생서해서 주입해준다.<br/>
<5> : InventoryService와 마찬가지로 ItemRepository에도 @MockBean을 붙여서 목 객체를 주입받는다.<br/>
  

```
	@Test
	void findingAllItems() {
		when(repository.findAll()).thenReturn( // <1>
				Flux.just(new Item("item-1", "Alf alarm clock", //
						"nothing I really need", 19.99)));

		this.webTestClient.get().uri("/api/items") // <2>
				.exchange() //
				.expectStatus().isOk() // <3>
				.expectBody() // <4>
				.consumeWith(document("findAll", preprocessResponse(prettyPrint()))); // <5>
	}
```
<1> : when(), thenReturn() 메소드는 Mockito가 제공하는 정적 메소드이며 테스트 코드 수행 중 repository.findAll()이 호출되면 특정 item을 반환하도록 지정한다.<br/>
<2> : 이 테스트 메소드는 /api/items 경로로 보내는 GET 요청을 테스트한다. /api/items 요청 처리 과정에서 협력하는 객체는 @MockBean과 Mockito에 의해 미리 정해진 값을 반환한다.<br/>
<3> : 실행 결과 상태 코드가 Ok인지 검증한다.<br/>
<4> : expectBody() 메소드를 사용해서 응답 본문에 대해 더 여러 가지를 단언할 수 있지만, 지금은 문서 자동 생성이 목표이므로 생략한다.<br/>
<5> : 스프링 레스트 독이 마법을 부리는 지점으로 document()는 스프링 레스트 독 정적 메서드이며, 문서 생성 기능을 테스트에 추가하는 역할을 한다. <br/>
  문서는 target/generated-snippets/findAll 디렉터리에 생성된다.<br/>

* document() 메소드는 2개의 인자를 받고, <br/>
* 첫번째 인자인 "findAll"이 전달되는데, 이렇게하면 findAll 디렉터리가 생성되고,<br/>
  그 안에 여러 .adoc 파일이 생성된다.<br/>
* 두번째 인자인 preprocessResonse(prettyPrint()) 는 요청 결과로 반환되는 JSON 문자열을 보기 편한 형태로 출력해 준다.
    
새 객체 추가 테스트 및 문서화
```
	@Test
	void postNewItem() {
		when(repository.save(any())).thenReturn( //
				Mono.just(new Item("1", "Alf alarm clock", "nothing important", 19.99)));

		this.webTestClient.post().uri("/api/items") // <1>
				.bodyValue(new Item("Alf alarm clock", "nothing important", 19.99)) // <2>
				.exchange() //
				.expectStatus().isCreated() // <3>
				.expectBody() //
				.consumeWith(document("post-new-item", preprocessResponse(prettyPrint()))); // <4>
	}
```
<1> :WebTestClient의 post() 메소드를 사용해서 새 객체 생성을 위한 POST 요청을 보낸다.
<2> : 새로 생성할 객체 정보를 bodyValue() 메소드에 전달해서 요청 본문에 넣는다.
<3> : 요청 처리 결과 요청초드가 HTTP 202 Created인지 확인한다.
<4> : 테스트에서 자동 생성된 문서는 post-new-item 디렉토리에 저장된다.
  
  
```
  
	@Test
	void findOneItem() {
		when(repository.findById("item-1")).thenReturn( //
				Mono.just(new Item("item-1", "Alf alarm clock", "nothing I really need", 19.99))); // <1>

		this.webTestClient.get().uri("/api/items/item-1") //
				.exchange() //
				.expectStatus().isOk() //
				.expectBody() //
				.consumeWith(document("findOne", preprocessResponse(prettyPrint()))); // <2>
	}
	// end::test3[]

	@Test
	void updateItem() {
		when(repository.save(any())).thenReturn( //
				Mono.just(new Item("1", "Alf alarm clock", "updated", 19.99)));

		this.webTestClient.put().uri("/api/items/1") // <1>
				.bodyValue(new Item("Alf alarm clock", "updated", 19.99)) // <2>
				.exchange() //
				.expectStatus().isOk() // <3>
				.expectBody() //
				.consumeWith(document("update-item", preprocessResponse(prettyPrint()))); // <4>
	}
}

```

