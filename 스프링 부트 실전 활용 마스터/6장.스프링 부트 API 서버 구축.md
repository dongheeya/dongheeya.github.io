<H1>6장.스프링 부트 API 서버 구축</H1>

해당 장에서는 외부 시스템을 위한 인터페이스인 API서버를 만드는 방법을 알려준다.<br>
- JSON 기반 웹 서비스 구축<br>
- 스프링 레스트 독을 활용한 API 문서화<br>
- 스프링 부트로 만든 API 포털에서 다양한 API 제공<br>
- 스프링 헤이티오스HATEOAS를 사용한 하이퍼미디어 활용<br>
- API 포털에 하이퍼미디어 링크 추가<br>

<H2>HTTP 웹 서비스 구축</H2>

가장 단순한 API 서버는 쿼리를 실행하고 결과를 반환한다.<br>
오늘날 이커머스와 매시업 분야에서 가장 중요한 키워드는 JSON이다.<br>
HTML 대신 JSON을 반환하는 스프링 웹플럭스 엔드포인트는 아주 쉽게 만들 수 있다.<br>

EX. 리포지토리에서 데이터를 가져와서 모델을 생성하고, 모델을 템플릿에 바인딩해서 화면을 반환하는 대신 데이터를 그대로 직접 반환하면 어떻게 될까?<br>

```
@RestController
public class ApiItemController {
  private final ItemRepsoitory repository;  -- (1)
  
  public ApiItemController(ItemRepository repository) _
    this.repository = repository; -- (2)
  }
}
```

(1) @RestController는 html대신 데이터를 응답 분문에 직접 써서 반환하는 스프링 웹 컨트롤러임을 나타낸다.<br>
  - RestController는 스프링이 컴포넌트 소캐닝을 통해 자동으로 감지하고 빈으로 등록한다는 관점에서 기존의 @Controller와 같다.<br>
  - 하지만, 웹 요청이 들어오면 @RestController가 붙은 클래스의 메소드는 화면 HTML을 렌더링하는 데 사용되는 값을 반환하지 않는다.<br>
  - 대신 데이터 자체를 반환하고, 반환된 데이터 객체는 직렬화되고 응답 본문에 직접 기록된다.<br>
(2) 5장까지 만들어진 Repository이다.<br>
(3) ItemRepository는 생성자를 통해 주입된다.<br>


```
@RestController
public class ApiItemController {
  private final ItemRepsoitory repository;  -- (1)
  
  public ApiItemController(ItemRepository repository) _
    this.repository = repository; -- (2)
  }
  
  @GetMapping("/api/items") -- (3)
  Flux<Item> findAll(){ -- (4)
    return this.repository.findAll(); -- (6)
  }
}

```

(3) @GetMapping("/api/items") 애너테이션은 /api/items로 들어오는 Get 요청 처리를 담당하는 메서드임을 나타낸다.<br>
(4) Flux<Item>을 반환하므로 0개 또는 그 이상의 Item 객체가 JSON 구조로 직렬과돼서 응답 본문에 기록된다.<br>
(5) 상품의 조회는 ItemRepositoy에 위임한다. ItemResitory.findAll() 메서드가 호출 결과인 Flux<Item>를 반환한다.<br>
  
한 개의 Item 객체를 조회하는 것도 어렵지 않다.

```
@GetMapping("/api/items/{id}") -- (1)
Mono<Item> findOne(@PathVariable String id) { -- (2)
    return this.repository.findById(id); -- (3)
}
```
  
(1) /api/items/{id}로 들어오는 GET 요청을 처리한다. {id}는 Item객체의 키 값을 가리킨다.
  ex) /api/items/42 -> 키 값이 42인 Item을 반환한다.
(2) 키를 지정해서 '하나'의 Item객체만 요청하고 있으므로 Mono<Item>을 반환한다.
  {id}로 들어오는 값과 @PathVariable에 들어오는 id와 같으므로 위와 같이 표현하고, 
  만약에 다르다면, @PathVariable("id") String itemId와 같이 템플릿 변수 이름도 함께 명시해준다.
  
(3) 스프링 데이터의 findById() 메소드를 호출하고 결과를 그대로 반환하므로 리스트 6-2와 마찬가지로 별다른 처리 없이 데이터 저장소로의 연결 통로 역할만 한다.
  
조회가 아니라 새로운 Item객체를 저장해야 한다면 다른 접근방식이 필요하다.
  
```
@PostMapping("/api/items") // <1>
Mono<ResponseEntity<?>> addNewItem(@RequestBody Mono<Item> item) { // <2>

  return item.flatMap(s -> this.repository.save(s)) // <3>
      .map(savedItem -> ResponseEntity //
          .created(URI.create("/api/items/" + //
              savedItem.getId())) // <4>
          .body(savedItem)); // <5>
}
```
  
(1) @PostMapping("/api/items") : /api/items/로 들어오는 POST 요청을 처리한다.
  새로 생성되는 Item객체의 id값은 몽고 디비에 저장되기 전까지는 알수 없으므로 요청 URI에 id는 필요하지 않다.
  
(2) 새로운 Item을 생성해서 추가하므로 이름을 addNewItem으로 명칭했고, @RequestBody 애너테이션은 요청 본문이 인자로 사용된다라는 것을 뜻한다.
  인자 타입이 리액터 타입인 Mono이므로 이 요청 처리를 위한 리액티브 플로우에서 구독이 발생하지 않으면 요청 본문을 Item 타입으로 역직렬화하는 과정도 실행되지 않는다.
  
(3) 이 단계에서는 데이터를 저장하는 것이 목적이므로 요청 본문으로 들어온 item객체에 map이나 flatMap연산을 적용하면 된다.
  이 중, 인자로 받은 Mono에서 꺼낸 후 스프링 데이터의 save() 메서드에 전달되고 다시 Mono를 반환하므로 flatMap을 사용해아한다.
  
(4) created() 메서드를 사용해서 새로 생성된 Item 객체의 id값을 포함하는 URI를 응답 메세지에 담아 반환한다.
  
(5) ResponseEntity.created() 메서드는 새로 생성된 savedItem 객체를 응답 본문에 담아 반환할 수 있다.
  saveItem 객체를 직렬화해서 응답 본문에 적는 일은 스프링 웹플럭스가 담당한다.
  
```
@PutMapping("/api/items/{id}") // <1>
public Mono<ResponseEntity<?>> updateItem( //
    @RequestBody Mono<Item> item, // <2>
    @PathVariable String id) { // <3>

  return item //
      .map(content -> new Item(id, content.getName(), content.getDescription(), //
          content.getPrice())) // <4>
      .flatMap(this.repository::save) // <5>
      .map(ResponseEntity::ok); // <6>
}
  
```
  
(1) @PutMapping("/api/items/{id}")가 붙은 메소드는 /api/items/{id}로 들어오는 PUT요청을 처리한다.
  HTTP PUT은 교체를 의미하며, 교체 대상이 존재하지 않으면 새로 생성한다.

  (2)
