<h1>2장. 스프링 부트를 활용한 데이터 엑세스</h1>

- 리액티브 데이터 스토어의 요건<br/>
- 이커머스 애플리케이션 도메인 객체 정의<br/>
- 객체를 저장하고 조회할 리포지토리 생성<br/>
- 상기 내용을 서비스에 적용<br/>

<h2>리액티브 데이터 스토어 요건</h2>

리액티브 프로그래밍의 핵심 요건은 리액티브 프로그래밍을 사용하려면 모든 과정이 리액티브여야 한다.<br/>

웹 컨트롤로를 리액티브 방식으로 동작하게 만들고 서비스 계층도 리액티브 방식으로 동작하게 만들었는데, 블로킹 방식으로 연결되는 데이터베이스를 호출하면 리액티브는 무너진다.<br/>

리액티브 프로그래밍과 관련해 흔히 떠올리는 선입견 중 하나는 리액티브가 태생적으로 빠르다는 주장이다.<br/>
작업을 수행하는 단일 스레드의 처리 속도 기준으로 보면 리액티브 프로그매잉은 여러 가지 오버헤드를 수반하므로 성능 저하가 발생한다.<br/>

작업량을 대규모로 늘려야 한느 상황이 아니라면, 리액티브 방식의 오버헤드로 인해 시스템을 더 느리게 동작한다.<br/>

리액티브 프로그래밍도 사용자 수가 작고 데이터도 많지 않다면 불필요한 오버헤드를 감수하면서 리액티브를 사용하는 것은 낭비다.<br/>

대규모의 트래픽이 발생하고 백엔드에서 대용량의 데이터를 처리하는 환경에서는 리액티브 프로그래밍의 장점이 빛을 발하게 된다.<br/>

<h3>회사에서 리액티브를 활용하는 환경이 아닌 이유?</h3>
대부분의 자바에서는 관계형 데이터베이스를 사용할 때 다음과 같은 기술을 사용하고 있다.<br/>
- jdbc<br/>
- jpa<br/>
- jdbi<br/>
- jOOQ<br/>

디부분은 이와 같이 가장 널리 사용되는 4가지 기술을 좀 더 쓰기 편하게 감싼 것들이다.<br/>
결국 JPA와 JDBC는 이와 연결되어 있는 관계형 데이터베이스를 활용하고 있다.<br/>

그리고 JPA와 JDBC는 블로킹 API이다. 트랜잭션을 시작하는 메세지를 전송하고, 쿼리를 포함하는 메세지를 전송하고, 결과가 나올 때 클라이언트에게 스트리밍해주는 개념 자체가 없다.<br/>
모든 데이터베이스 호출은 응답을 받을 때까지 블로킹되어 기다려야 한다.<br/>


<H3>내부 스레드 풀의 문제점</H3>

장비의 코어 수보다 많은 스레드를 사용하는 것은 장점이 거의 없다는 점이다.<br/>
JPA 같은 블로킹 API 앞에 스레드 풀을 두고 여러 스레드를 사용하는 방식은 일밙거으로 포화지점에 도달하게 된다.<br/>
이 지점을 지나면 스레드 풀은 새 요청이 들어와도 받아서 처리할 스레드가 없으므로 스레드 풀 자체도 블로킹된다.<br/>

100% 리액티브 애플리케이션을 만들려면 데이터베이스와 물리적 연결과 상호작용 과정에 비동기, 논블로킹 개념을 적용할 수 있는 데이터베이스 드라이버가 필요하다.<br/>



<H2>이커머스 애플리케이션 도메인 정의</H2>
POM.XML 빌드 파일에 새로운 의존관계를 추가한다.

```
<dependency>
  <grouId>org.springframework.book</groupId>
  <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
<dependency>
  <grouId>de.fladoodle.embed</groupId>
  <artifactId>de.flapdoodle.embed.mongo</artifactId>
</dependency>
<dependency>
  <grouId>org.mongodb</groupId>
  <artifactId>mongodb-driver-sync</artifactId>
</dependency>
```

- spring-boot-starter-data-mongodb-reactive : 스프링 데이터 몽고이비를 포함하고 있으며, 특히 리액티브 버전이 들어 있다.<br/>
- de.flapdoodle.embed.mongo : 내장형 몽고디비 도구. 데이트에 주로 사용<br/>
- mongodb-driver-sync : 전통적인 몽고디비 드라이버 <br/>

```
public class Item {
  private @Id String id;
  private String name;
  private double price;
  
  private Item(){ }
  
  Item(String name, double price){
    this.name = name;
    this.prive = price;
  }
}
```

몽고 디비의 ObjectId값으로 사용할지 결정해야 한다.<br/>
ObjectId는 모든 몽고이비 컬렉션에 있는_id 필드를 사용된다.<br/>
@Id 애너테이션을 사용해서 특정 필드를 ObjectId필드로 지정한다.<br/>


```
class CartItem {
  private Item item;
  private int quantity;
  
  private CartItem() { }
  
  CartItem(Item item){
    this.item = item;
    this.quantity = 1;
  }

}

class Cart {
  private @Id String id;
  private List<CartItem> cartItems;
  
  private Cart(){ }
  
  public Cart(String id) {
    this(id, new ArrayList<>());
  }
  
  public Cart(String id, List<CartItem> cartItems){
    this.id = id;
    this.cartItems = cartItems;
  }  

}
```

판매 상품을 장바구니에 넣는 기능을 만들어보자.<br/>

<h2>리포지토리 만들기</h2>

몽고 디비와 같은 NoSQL 데이터 스토어를 표준화 시키는 방법은 딱히 없다.<br/>

그렇다면 스프링 데이터는 이 문제를 어떻게 해결할 것인가?<br/>

스프링이 가진 가장 강력한 패러다임 중의 하나는 JdbcTemplete, RestTemplate, JmsTemplate 같은 템플릿 패턴이다.<br/>
템플릿이라는 이름이 붙은 이 다양한 도구는 타입 안전 방식으로 연산을 처리하고, 다루기 복잡하고 귀찮은 것들을 추상화해서 데이터베이스 등 협력 대상과의 상호작용이 바르게 
동작하도록 보장한다.<br/>

예를 들어, JdbcTemplate를 사용하면 개발자가 데이터베이스 연결을 직접 열고 닫지 않아도 된다.<br/>


몽고디비를 비롯해 다양한 데이터베이스를 지원하는 스프링 데이터 모듈에는 리포지토리 계층이 있다.<br/>
템플릿에 포함돼 있는 풍부한 연산을 사용하다보면, 그 많은 API를 모두 익히는 일이 결국 몽고디비에서 사용할 새로운 몽고SQL 쿼리문을 타입 안전 방식으로 작성하는 것과 같다는 느낌을
받을 것이다.<br/>

저장, 조회, 삭제 같은 단순하고 공통적인 연산은 추상화해서 표준화된 방식으로 접근하면 편리하다.<br/>

EX) 판매 상품(Item)에 대한 리포지토리를 한번 만들어보자.<br/>

```
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

public interface ItemRepository extends ReactiveCrudRepository<Item, String> {

}
```

첫 번째 제네릭 파라미터는 리포지토리가 저장하고 조죄하는 타입을 말한다.<br/>
두번쨰 제너릭 파라미터인 String은 저장되는 데이터의 식별자의 타입이 String라는 의미이다.<br/>

부모 인터페이스인 ReactiveCrudRepository로부터 상속받는 메소드는 다음과 같다.<br/>

```
save(), saveAll()
findById(), findAll(), findAllById()
extistById()
count()
deleteById(), delete(), deleteAll()
```

이 모든 메소드의 반환 타입이 Mono 혹은 Flux이다.<br/>

Mono나 Flux를 구독하고 있다가 몽고디비가 데이터를 제공할 준비가 됐을 때 데이터를 받을 수 있게 된다.<br/>

이 메서드 중 일부는 리액티브 스트림의 Publisher 타입을 인자로 받을 수 있다.<br/>




<h2>테스트 데이터 로딩</h2>

```
itemRepository.save(new Item("Alf alarm clock", 19.99))
```

ReactiveCrudRepository.save()는 Mono<T>를 반환하고 이떄 subscribe없이는 동작하지 않는다.<br/>

  
```
itemRepository.save(new Item("Alf alarm clock", 19.99))
  .subscribe()
```
 
애플리케이션 시작 시점에 어떤 작업을 하려면, 다소 맥빠지는 감이 없진 않지만 블로킹 버전의 스프링 데이터 몽고디비를 사용하는 편이 좋다.<br/>
이는 애플리케이션 시작 시점에서만 발생하는 이슈이며, 불로킹 코드는 실제 운영 소스에서는 사용하면 안 된다.<br/>
  

```
interface BlockingItemRepository extends CrudRepository<Item, String>{
  
}
```

블로킹 인터페이스인 CrudRepository를 상속받는다는 점 외에는 앞에서 만든 방식과 동일하다.<br/>
  
```
@Component   // 스프링 부트의 컴포넌트 탐색 단계에서 클래스가 빈으로 등록되게 해주는 스프링 프레임워크 애너테이션이다.
public class RepositoryDatabaseLoader {
  
  @Bean // 자동으로 실행되는 특수한 스프링 부트 컴포넌트로서, run() 메소드 하나만 갖고 있는 함수형 인터페이스다.
  CommandLineRunner initialize(BlockingItemRepository repository){   // BlockingItemRepository 타입의 빈을 요청하며, 
  스프링 프레임워크는 등록된 빈 중에서 해당 타입의 빈을 찾아서 메소드 인자를 주입한다.
    return args -> {
      repository.save(new Item("Alf alarm clock", 19.99));
      repository.save(new Item("Smurf Tv Tray", 24.99));
    };  
  }
}
```
  
해당 소스는 블로킹으로 동작하므로 애플리케이션 시작 시 네티와 충돌할 위험은 없다.
  
블로킹 리포지토리의 대안은 아예 사용 가능성을 낮추고 아예 만들지 말아야 한다.
  
BlockingItemRepository와 이를 사용하는 RepositoryDatabaseLoader를 제거하자.<br/>
누군가 보고 따라 할 블로킹 코드가 없으니 잘못된 코드를 사용할 위험도 함께 제거된다.<br/>
  
데이터는 MongoTemplate를 사용하면 된다.<br/>
MongoTemplate는 블로킹 버전이고, ReactiveMongoTemplate는 비동기. 논블로킹 버전이다.<br/>
  

```
@Component 
public class TemplateDatabaseLoader {
  
  @Bean
  CommandLineRunner initalize(MongoOperations mongo){
    return args -> {
      mongo.save(new Item("Alf alarm clock", 19.99));
      mongo.save(new Item("Smurf Tv Tray", 24.99));
    };
  }
}
```

MongoOperations 는 무엇일까?<br/>
수년 전에 스프링 팀은 JdbcTemplate에서 일부를 추출해서 JdbcOperations라는 인터페이스를 만들었다.<br/>

애플리케이션과 몽고디비의 결합도를 낮추려면 MongoOperations 인터페이스를 사용하는 것이 좋다.<br/>

설계 관점에서 보자면 ItemRepository를 만든 것은 매우 적절하다.<br/>

<h2>장바구니 보여주기</h2>

```
@GetMapping
Mono<Rendering> home(){   // Mono<String>을 반환했지만, 이번에는 뷰/애트리뷰트를 포함하는 웹플럭스 컨테이너인 Mono<Rendering>을 반환한다.
  return Mogo.just(Rendering.view("home.html") // 랜더팅에 사용할 템플릿 이름을 지정한다.
.modelAttribute("items",this.itemRepository.findAll())  // 템플리셍서 사용될 데이터를 지정한다.
.modelAttribute("cart", this.cartRepository.findById("My Cart")
.defaultIfEmpty(new Cart("My Cart"))))
.build());
}
```
  
<h2>장바구니에 상품 담기</h2>

  ```
  @PostMapping("/add/{id}")
  Mono<String> addToCart(@PathVariable String id){
    return this.cartRepository.findById("My cart").
  .defaultIfEmpty(new Cart("My Cart"))   // MongoDb에서 My Cart를 찾아서 없으면 defaultIfEmpty()를 통해서 새로 생성해 반환한다.
  .flatMap(cart -> cart.getCartItems().stream()
  .filter(cartItem -> cartItem.getItem()
 .getId().equals(id))
  .findAny() // 같은 상품 존재시 +1하고 반환
  .map(cartItem -> {
    cartItem.increment();
    return Mono.just(cart);
  })
  .orElseGet(() -> {   // 새로 장바구니에 담은 상품이 장바구니에 담겨있지 않은 상품이라면, cartItem에 담은 이후에 장바구니에 추가한다.
    return this.itemRepository.findById(id)
  .map(item -> new CartItem(item))
  .map(cartItem -> { cart.getCartItems().add(cartItem);
  return cart;
  });
  }))
  .flatMap(cart -> this.cartRepository.save(cart))
  .thenReturn("redirect:/");
  }
  ```
  

  
  
  
