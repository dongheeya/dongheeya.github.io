<h1>9장 일반적인 프로그래밍 원칙</h1>

<h2>아이템57. 지역변수의 범위를 최소화하라</h2>
지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다.<br/>
지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'다<br/>
사용하려면 멀었는데, 미리 선언부터 해두면 코드가 어수선해져 가독성이 떨어진다.<br/>
변수를 실제로 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.<br/>

지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날때까지이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아 있게 된다.<br/>
그래서 실제로 의도한 범위 앞 혹은 뒤에서 그 변수를 사용하면 끔찍한 결과로 이어질 수 있다.<br/>

거의 모든 지역변수는 선언과 동시에 초기화해야 한다.<br/>
초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.<br/>
단, try-catch문은 이 규칙에 예외다.<br/>
변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.<br/>

<h3>while문 보다는 for문을 활용하라</h3>
반복문은 독특한 방식으로 변수 범위를 최소화해준다.<br/>
for는 키워드와 몸체 사이의 괄호 안으로 범위가 제한된다.<br/>
반복변수의 값이 반복문이 종료된 이후에도 써야되는 상황이라면 while문보다는 for문을 쓰는 편이 낫다.<br/>

```
for(Element e:c){
  ...//e로 무언가를 한다.
}
```

반복문을 사용해야 하는 상황이라면 for-each문 대신 전통적인 for 문을 쓰는 것이 낫다.

```
for(Iterator<Element> i = c.iterator(); i.hasNext();){
  Element e = i.next();
  ...// e와 i로 무언가를 한다.
}
```

다음은 두 while문을 보면 앞서 for문이 더 나은 이유를 알 수 있다.

```
Iterator<Element> i = c.iterator();
while(i.hasNext()){
  doSomething(i.next());
}
...

Iterator<Element> i2 = c2.iterator();
while(i.hasNext()){                    // 오류
  doSomething(i2.next());
}
```
아래에 while문을 사용할 때에는 i의 유효범위가 아직 끝나지 않았으므로 컴파일 오류를 던지지는 않지만, 사실상 i는 이미 순회가 끝났으므로 아래의 while문에서는 아무 동작을 하지 않게 된다.
따라서 두 번째 while문에서는 c2를 순회하지 않고 곧장 끝나버려 c2가 비어있다고 착각하게 만든다.

이를 복붙의 오류를 for문을 사용하면 컴파일타임에서 잡을 수 있다.

```
for(iterator<Element> i = c.iterator(); i.hasNext();){
  Element e = i.next();
  ... // e와 i로 무언가를 한다.
}

// i를 찾을 수 없다는 컴파일 오류를 낸다.
for(Iterator<Element> i2  = c2.iterator(); i.hasNext();){
  Element e = i2.next();
  ... // e와 i로 무언가를 한다.
}
```

또한 for문은 변수 유효 범위가 for문 범위와 일치하여 똑같은 이름의 변수를 여러 반복문에서 써도 서로 아무런 영향을 주지 않는다.


```
for(int i= 0, n=expensiveComputation(); i< n; i++){
  .. // i로 무언가를 한다.
}
```

여기서 주목할 부분은 정확히 범위가 for문과 일치한 두 반복 변수 i와 n이다.<br/>

지역변수 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한가지 기능에 집중하는 것이다.<br/>

<h2>아이템 58. 전통적인 for문보다는 for-each 문을 사용하라.</h2>
다음은 전통적인 for문으로 컬렉션을 순회하는 코드다.<br/>

```
//58-1. 
for(Iterator<Element> i = c.iterator(); i.hasNext()){
  Element e = i.next();
  ... // e무언가를 한다.
}

//58-2/
for(int i=0; i<a.length; i++){
  ... // a[i]로 무언가를 한다.
}
```

이 관용구들은 while문 보다는 낫지만 가장 좋은 방법은 아니다.<br/>
반복자와 인덱스 변수는 모두 코르를 지저분하게 할 뿐 우리에게 진짜 필요한 건 원소뿐이다.<br/>
혹시라도 잘못된 변수를 사용했을 때 컴파일러가 잡아줄리라는 보장이 없다.<br/>

위의 문제를 for-each문을 사용하면 모두 해결된다.<br/>
반복자와 인덱스 변수를 사용하지 않으므로 코드가 깔끔하고 오류가 날 일도 없다.<br/>

```
for(Element e : elements){
  ... //e로 무언가를 한다.
}
```

여기서 :(콜론)을 사용하고 있고, 반복 대상이 컬렉션이든 배열이든 이전의 for-each문을 사용해도 속도는 그대로이다.
컬렉션을 중첩해 순회해야 한다면 for-each문의 이점은 더욱 커진다.

```
//버그를 찾아보자.
enum Suit {CLUB, DIAMOND, HEART, SPADE}
enum Rank {ACE, DEUCE, THREE, FOUR, FIVE .... }
...

static Collection<Suit> suits = Arrays.asList(Suit.values());
static Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    	deck.add(new Card(i.next(), j.next()); // 버그
```

여기서 문제는 바깥 쪽 Suit에 의해서 i.next()가 너무 많이 불린다는 것이 문제이다. <br/>
이 next()는 '숫자(Suit) 하나당' 한 번씩만 불려야 하는데, 안쪽 반복문에서 호출되는 바람에 '카드(Rank) 하나당' 한 번씩 불리고 있다. <br/>
따라서 Suit가 바닥나면 NoSuchElemnentException을 던지고 말 것이다.<br/>

운이 나빠서 바깥 컬렉션의 크기가 안쪽 컬렉션 크기의 배수라면 이 반복문은 예외를 던지지 않고 종료한다. 물론 우리가 원하는 일을 수행하지 않은 채 말이다.<br/>

위의 문제를 아래와 같이 수정한다면 문제점이 고쳐졌다.
```
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	Suit suit = i.next();  
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    	deck.add(new Card(suit, j.next());
```

for-each 문을 중첩하는 것으로 이 문제가 간단히 해결된다.
코드도 간결해진다.

```
for (Suit suit : suits)
	for (Rank rank : ranks)
    	deck.add(new Card(suit,rank));
```

하지만 다음과 같은 상황에서는 for-each를 사용하지 않고 전통적인 for문을 사용한다.<br/>

1. 파괴적인 필터링 :  컬렉션을 순회하면서 선택된 원소를 제거한다면 반복자의 remove를 호출해야 한다. <br/>
자바 8부터는 Collection의 removeIf 메서드를 사용해서 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.<br/>

2. 변형 : 리스트나 배열을 순회하면서 그 원소의 값 일부나 전체를 교체해야 한다면, 리스의 반복자나 배열의 인덱스를 사용해야 한다. <br/>

3. 병렬 반복 :  여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 엄격하고 명시적으로 제어해야 한다.<br/>

for-each문은 컬렉션과 배열은 물론이고 Iterable 인터페이스를 구현한 객체라면 무엇이든지 순회할 수 있다. <br/>
따라서, 원소들의 묶음을 표현하는 타입을 작성해야 한다면 Iterable을 구현하는 쪽으로 고민해보면 된다. <br/>
비록, 해당 타입에서 Collection 인터페이스를 구현하지 않아도 말이다.<br/>

<h2>아이템 59. 라이브러리를 익히고 사용하라</h2>
무작위 정수를 하나 생성하고 싶을 때 어떻게 코드를 짤 수 있을까? 값의 범위는 0부터 명시한 숫자 사이이다. <br/>

```
// 59-1 .흔하지만 문제가 심각한 코드!
static Random rnd = new Random();
static int random(int n) {
	return Math.abs(rnd.nextInt()) % n;
}
```
이 코드는 다음과 같은 문제가 있다.<br/>
n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.<br/>
n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 잘 반환된다.<br/>

무작위 수 백만개를 생성한 다음, 그 중 중간 값보다 작은 게 몇 개인지를 출력한다<br/>
```
public static void main(String[] args) {
	int n = 2 * (Integer.MAX_VALUE /3 );
    int low  = 0;
    for (int i=0;i<1000000; i++)
    	if(random(n) < n/2)
        	low++;
    System.out.println(low);
}
```
random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제는 666,666에 가까운 값을 얻는다. <br/>
2/3가 중간값보다 낮은 쪽으로 쏠린 것이다. <br/>
가끔, 지정한 범위 '바깥'의 수가 종종 튀어나올 수 있다.<br/>

이러한 라이브러리에 대한 버그는 다행히 프로그래머는 직접 해결할 필요가 없다. <br/>
Random.nextInt(int)가 이미 해결해놨다. <br/>
이 메서드의 자세한 동작 방식은 몰라도 된다. <br/>
버그가 발견되더라도 다음 릴리즈에서 수정될 것이다. <br/>
표준 라이브러리를 사용하면 그 코드를 작성한 전문가와 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.<br/>

표준라이브러리를 쓰는 두번째 이점은 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다는 것이다.<br/>
세번째는 따로 노력하지 않아도 성능이 지속해서 개선이 된다는 점이다.<br/>
네번째는 기능이 점점 많아진다는 것이다.<br/>
마지막 이점은 여러분이 작성한 코드가 많은 사람들에게 낯익은 코드가 되어서 더 읽기 좋고 유지보수하지 좋고 재사용성이 높아진다.<br/>

이러한 이점들을 비춰봤을 때 표준 라이브러리의 기능을 사용하는 것이 좋아보이지만, 실상은 많은 프로그래머가 직접 구현해 쓰고 있다.<br/>
그 이유는 라이브러리에 그런 기능이 많은지 모르기 때문이다.<br/>

따라서 메이저 릴리스마다 주목할 만한 수많은 기능의 라이브러리에 추가되는 살펴봐야 한다.<br/>

라이브러리가 너무 방대하여 모든 API 문서를 공부하기 벅차겠지만, 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다. <br/>
다른 라이브러리들은 필요할 떄마다 익히면 좋다. <br/>

<h2>아이템 60. 정확한 답이 필요하다면 float와 double은 피하라</h2>

float와 double 타입은 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 섬세하게 설계되었다. <br/>
따라서 정확한 결과가 필요할 때는 사용하면 안된다. <br/>
float와 double 타입은 특히 금융 관련 계산은 맞지 않는다. <br/>

```
//예를 들어 주머니에 1.03 달러가 있는데 그중 42센트를 썼다고 해보자.
System.out.println(1.03 - 0.42);
// 0.6100000000000001
```
결과값 출력전에는 반올림하면 해결되리라고 생각할 지 모르지만 반올림해도 틀린 값이 나올 수 있다.

따라서 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

다음은 계산의 부정확함을 막기 위해 BigDecimal를 사용했다.

```
public static void main(String[] args) {
	final BigDecimal TEN_CENTS = new BigDecimal("0.10");

    int itemsBought = 0;
    BigDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price=TEN_CENTS; funds.compareTo(price)>=0; price =price.add(TEN_CENTS)) {
    	  funds = funds.subtract(price);
        itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(달러):" + funds);
}
```
올바른 답이 나오지만 BigDecimal에는 2가지 단점이 있다.<br/>

기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느리다. 단발성 계산이라면 상관 없지만, 쓰기 불편한건 마찬가지이다.<br/>

그래서 BigDecimal의 대안으로 int 혹은 long으로 쓸 수도 있다.<br/>
그럴 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.<br/>

```
public static void main(String[] args) {
	int funds = 100;
  int itemsBought = 0;
  for (int price=10; funds>=price; price +=10) {
    funds -=price;
      itemsBought++;
  }
  System.out.println(itemBough + "개 구입");
  System.out.println("잔돈(센트):" + funds);
}
```
 
<h2>아이템 61. 박시된 기본 타입보다는 기본 타입을 사용하라</h2>

자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. 기본타임인 int, double, boolean 같은 기본 타입과 String, List와 같은 참조 타입이다.<br/>
그리고 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 존재하며, 이를 박싱한 기본 타입이라고 한다.<br/>

예컨대, int, double, boolean에 대응하는 박싱타입은 Integer, Double, Boolean이다.<br/>

기본 타입과 박싱된 기본 타입의 주된 차이점은 크게 3가지이다.<br/>
1. 기본 타입은 값만 있으나, 박싱된 기본 타입은 식별성(identity)이 있어서 값이 같아도 다르게 식별될 수 있다.<br/>
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 null을 가질 수 있다.<br/>
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.<br/>

다음은 Integer 값을 오름차순으로 정렬하는 비교자다.<br/>
compare 메서드는 첫 번째 원소가 두번째 원소보다 작으면 음수, 같으면 0, 크면 양수를 반환한다.<br/>
Integer는 그 자체로 순서가 있으니 이 비교자가 실질적인 의미는 없지만, 흥미로운 사실 하나를 보여준다.<br/>

```
Comparator<Integer> naturalOrder = (i,j) -> (i<j)? -1 : (i==j ? 0 : 1);
```

여기서의 심각한 결함은 두 객체에서는 식별성을 검사하기 때문이다.<br/>
( i < j ) 는 잘 작동한다. <br/>
여기서 i와 j가 참조하는 오토박시된 Integer 인스턴스는 기본 타입 값으로 변환된다. <br/>
그런 다음만약 i가 j보다 작지 않다면 두번째 검사( i == j )가 아뤄진다. ( 식별성 검사)<br/>
i와 j가 서로 다른 Integer 인스턴스라면, 비록 값은 같더라도 비교 결과는 false가 되고, (잘못된 결과인) 1을 반환한다. <br/>
이처럼 같은 객체를 비교하는 것이 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.<br/>

기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder()를 사용하자.

```
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) ->
	int i = iBoxed, j = jBoxed;        // 오토박싱
    return i < j ? -1 : ( i == j ? 0 : 1 );
};
```

지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다.

다음은 기이하게 동작하는 코드이다.

```
public class Unbelievable {
	static Integer i;
    
  public static void main(String[] args) {
    if (i == 42)
        System.out.println("믿을 수 없군!");
  }
}
```

여기서 i == 42를 검사할 때 NullPointerException을 던지는데, 이는 i가 int가 아닌 Integer이며, 다른 탐조 타입 필드와 마찬가지로 i의 초깃값도 null이라는 데 있다.<br/>
즉 i== 42는 Integer와 int를 비교하는 것인데, 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용하는 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.<br/>
이 때의 해법은 간단한다. i를 int로 선언해주면 끝이다.<br/>

```
public static void main(String[] args) {
	Long sum = 0L;
  for ( long i = 0; i <= Integer.MAX_VALUE; i++ ) {
    sum += i;
  }
  System.out.println(sum);
}
```
하지만 이 프로그램의 실수는 지역변수 sum을 박싱된 기본타입으로 선언하였다는 것이다. <br/>
오류나 경고 없이 컴파일되지만, 박싱과 언방식이 반복해서 일어나 체감될 정도로 성능이 느려진다.<br/>

<h3>박싱된 기본 타입은 언제 써야 하는가?</h3>

첫 번째, 컬렉션의 원소 , 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없다. <br/>
자바 언어가 매개변수로 기본 타입을 지원하지 않기 때문이다. <br/>
두 번째, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.<br/>



 
 


