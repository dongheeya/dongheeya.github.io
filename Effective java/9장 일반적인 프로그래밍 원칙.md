<h1>9장 일반적인 프로그래밍 원칙</h1>

<h2>아이템57. 지역변수의 범위를 최소화하라</h2>
지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다.<br/>
지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'다<br/>
사용하려면 멀었는데, 미리 선언부터 해두면 코드가 어수선해져 가독성이 떨어진다.<br/>
변수를 실제로 사용하는 시점엔 타입과 초깃값이 기억나지 않을 수도 있다.<br/>

지역변수의 범위는 선언된 지점부터 그 지점을 포함한 블록이 끝날때까지이므로, 실제 사용하는 블록 바깥에 선언된 변수는 그 블록이 끝난 뒤까지 살아 있게 된다.<br/>
그래서 실제로 의도한 범위 앞 혹은 뒤에서 그 변수를 사용하면 끔찍한 결과로 이어질 수 있다.<br/>

거의 모든 지역변수는 선언과 동시에 초기화해야 한다.<br/>
초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.<br/>
단, try-catch문은 이 규칙에 예외다.<br/>
변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 try 블록 안에서 초기화해야 한다.<br/>

<h3>while문 보다는 for문을 활용하라</h3>
반복문은 독특한 방식으로 변수 범위를 최소화해준다.<br/>
for는 키워드와 몸체 사이의 괄호 안으로 범위가 제한된다.<br/>
반복변수의 값이 반복문이 종료된 이후에도 써야되는 상황이라면 while문보다는 for문을 쓰는 편이 낫다.<br/>

```
for(Element e:c){
  ...//e로 무언가를 한다.
}
```

반복문을 사용해야 하는 상황이라면 for-each문 대신 전통적인 for 문을 쓰는 것이 낫다.

```
for(Iterator<Element> i = c.iterator(); i.hasNext();){
  Element e = i.next();
  ...// e와 i로 무언가를 한다.
}
```

다음은 두 while문을 보면 앞서 for문이 더 나은 이유를 알 수 있다.

```
Iterator<Element> i = c.iterator();
while(i.hasNext()){
  doSomething(i.next());
}
...

Iterator<Element> i2 = c2.iterator();
while(i.hasNext()){                    // 오류
  doSomething(i2.next());
}
```
아래에 while문을 사용할 때에는 i의 유효범위가 아직 끝나지 않았으므로 컴파일 오류를 던지지는 않지만, 사실상 i는 이미 순회가 끝났으므로 아래의 while문에서는 아무 동작을 하지 않게 된다.
따라서 두 번째 while문에서는 c2를 순회하지 않고 곧장 끝나버려 c2가 비어있다고 착각하게 만든다.

이를 복붙의 오류를 for문을 사용하면 컴파일타임에서 잡을 수 있다.

```
for(iterator<Element> i = c.iterator(); i.hasNext();){
  Element e = i.next();
  ... // e와 i로 무언가를 한다.
}

// i를 찾을 수 없다는 컴파일 오류를 낸다.
for(Iterator<Element> i2  = c2.iterator(); i.hasNext();){
  Element e = i2.next();
  ... // e와 i로 무언가를 한다.
}
```

또한 for문은 변수 유효 범위가 for문 범위와 일치하여 똑같은 이름의 변수를 여러 반복문에서 써도 서로 아무런 영향을 주지 않는다.


```
for(int i= 0, n=expensiveComputation(); i< n; i++){
  .. // i로 무언가를 한다.
}
```

여기서 주목할 부분은 정확히 범위가 for문과 일치한 두 반복 변수 i와 n이다.<br/>

지역변수 범위를 최소화하는 마지막 방법은 메서드를 작게 유지하고 한가지 기능에 집중하는 것이다.<br/>

<h2>아이템 58. 전통적인 for문보다는 for-each 문을 사용하라.</h2>
다음은 전통적인 for문으로 컬렉션을 순회하는 코드다.<br/>

```
//58-1. 
for(Iterator<Element> i = c.iterator(); i.hasNext()){
  Element e = i.next();
  ... // e무언가를 한다.
}

//58-2/
for(int i=0; i<a.length; i++){
  ... // a[i]로 무언가를 한다.
}
```

이 관용구들은 while문 보다는 낫지만 가장 좋은 방법은 아니다.<br/>
반복자와 인덱스 변수는 모두 코르를 지저분하게 할 뿐 우리에게 진짜 필요한 건 원소뿐이다.<br/>
혹시라도 잘못된 변수를 사용했을 때 컴파일러가 잡아줄리라는 보장이 없다.<br/>

위의 문제를 for-each문을 사용하면 모두 해결된다.<br/>
반복자와 인덱스 변수를 사용하지 않으므로 코드가 깔끔하고 오류가 날 일도 없다.<br/>

```
for(Element e : elements){
  ... //e로 무언가를 한다.
}
```

여기서 :(콜론)을 사용하고 있고, 반복 대상이 컬렉션이든 배열이든 이전의 for-each문을 사용해도 속도는 그대로이다.
컬렉션을 중첩해 순회해야 한다면 for-each문의 이점은 더욱 커진다.

```
//버그를 찾아보자.
enum Suit {CLUB, DIAMOND, HEART, SPADE}
enum Rank {ACE, DEUCE, THREE, FOUR, FIVE .... }
...

static Collection<Suit> suits = Arrays.asList(Suit.values());
static Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    	deck.add(new Card(i.next(), j.next()); // 버그
```

여기서 문제는 바깥 쪽 Suit에 의해서 i.next()가 너무 많이 불린다는 것이 문제이다. <br/>
이 next()는 '숫자(Suit) 하나당' 한 번씩만 불려야 하는데, 안쪽 반복문에서 호출되는 바람에 '카드(Rank) 하나당' 한 번씩 불리고 있다. <br/>
따라서 Suit가 바닥나면 NoSuchElemnentException을 던지고 말 것이다.<br/>

운이 나빠서 바깥 컬렉션의 크기가 안쪽 컬렉션 크기의 배수라면 이 반복문은 예외를 던지지 않고 종료한다. 물론 우리가 원하는 일을 수행하지 않은 채 말이다.<br/>

위의 문제를 아래와 같이 수정한다면 문제점이 고쳐졌다.
```
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	Suit suit = i.next();  
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    	deck.add(new Card(suit, j.next());
```

for-each 문을 중첩하는 것으로 이 문제가 간단히 해결된다.
코드도 간결해진다.

```
for (Suit suit : suits)
	for (Rank rank : ranks)
    	deck.add(new Card(suit,rank));
```

하지만 다음과 같은 상황에서는 for-each를 사용하지 않고 전통적인 for문을 사용한다.<br/>

1. 파괴적인 필터링 :  컬렉션을 순회하면서 선택된 원소를 제거한다면 반복자의 remove를 호출해야 한다. <br/>
자바 8부터는 Collection의 removeIf 메서드를 사용해서 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.<br/>

2. 변형 : 리스트나 배열을 순회하면서 그 원소의 값 일부나 전체를 교체해야 한다면, 리스의 반복자나 배열의 인덱스를 사용해야 한다. <br/>

3. 병렬 반복 :  여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 엄격하고 명시적으로 제어해야 한다.<br/>

for-each문은 컬렉션과 배열은 물론이고 Iterable 인터페이스를 구현한 객체라면 무엇이든지 순회할 수 있다. <br/>
따라서, 원소들의 묶음을 표현하는 타입을 작성해야 한다면 Iterable을 구현하는 쪽으로 고민해보면 된다. <br/>
비록, 해당 타입에서 Collection 인터페이스를 구현하지 않아도 말이다.<br/>

<h2>아이템 59. 라이브러리를 익히고 사용하라</h2>
무작위 정수를 하나 생성하고 싶을 때 어떻게 코드를 짤 수 있을까? 값의 범위는 0부터 명시한 숫자 사이이다. <br/>

```
// 59-1 .흔하지만 문제가 심각한 코드!
static Random rnd = new Random();
static int random(int n) {
	return Math.abs(rnd.nextInt()) % n;
}
```
이 코드는 다음과 같은 문제가 있다.<br/>
n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복된다.<br/>
n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 잘 반환된다.<br/>

무작위 수 백만개를 생성한 다음, 그 중 중간 값보다 작은 게 몇 개인지를 출력한다<br/>
```
public static void main(String[] args) {
	int n = 2 * (Integer.MAX_VALUE /3 );
    int low  = 0;
    for (int i=0;i<1000000; i++)
    	if(random(n) < n/2)
        	low++;
    System.out.println(low);
}
```
random 메서드가 이상적으로 동작한다면 약 50만개가 출력되어야 하지만, 실제는 666,666에 가까운 값을 얻는다. <br/>
2/3가 중간값보다 낮은 쪽으로 쏠린 것이다. <br/>
가끔, 지정한 범위 '바깥'의 수가 종종 튀어나올 수 있다.<br/>

이러한 라이브러리에 대한 버그는 다행히 프로그래머는 직접 해결할 필요가 없다. <br/>
Random.nextInt(int)가 이미 해결해놨다. <br/>
이 메서드의 자세한 동작 방식은 몰라도 된다. <br/>
버그가 발견되더라도 다음 릴리즈에서 수정될 것이다. <br/>
표준 라이브러리를 사용하면 그 코드를 작성한 전문가와 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.<br/>

표준라이브러리를 쓰는 두번째 이점은 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다는 것이다.<br/>
세번째는 따로 노력하지 않아도 성능이 지속해서 개선이 된다는 점이다.<br/>
네번째는 기능이 점점 많아진다는 것이다.<br/>
마지막 이점은 여러분이 작성한 코드가 많은 사람들에게 낯익은 코드가 되어서 더 읽기 좋고 유지보수하지 좋고 재사용성이 높아진다.<br/>

이러한 이점들을 비춰봤을 때 표준 라이브러리의 기능을 사용하는 것이 좋아보이지만, 실상은 많은 프로그래머가 직접 구현해 쓰고 있다.<br/>
그 이유는 라이브러리에 그런 기능이 많은지 모르기 때문이다.<br/>

따라서 메이저 릴리스마다 주목할 만한 수많은 기능의 라이브러리에 추가되는 살펴봐야 한다.<br/>

라이브러리가 너무 방대하여 모든 API 문서를 공부하기 벅차겠지만, 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다. <br/>
다른 라이브러리들은 필요할 떄마다 익히면 좋다. <br/>

<h2>아이템 60. 정확한 답이 필요하다면 float와 double은 피하라</h2>

float와 double 타입은 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 섬세하게 설계되었다. <br/>
따라서 정확한 결과가 필요할 때는 사용하면 안된다. <br/>
float와 double 타입은 특히 금융 관련 계산은 맞지 않는다. <br/>

```
//예를 들어 주머니에 1.03 달러가 있는데 그중 42센트를 썼다고 해보자.
System.out.println(1.03 - 0.42);
// 0.6100000000000001
```
결과값 출력전에는 반올림하면 해결되리라고 생각할 지 모르지만 반올림해도 틀린 값이 나올 수 있다.

따라서 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 한다.

다음은 계산의 부정확함을 막기 위해 BigDecimal를 사용했다.

```
public static void main(String[] args) {
	final BigDecimal TEN_CENTS = new BigDecimal("0.10");

    int itemsBought = 0;
    BigDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price=TEN_CENTS; funds.compareTo(price)>=0; price =price.add(TEN_CENTS)) {
    	  funds = funds.subtract(price);
        itemsBought++;
    }
    System.out.println(itemsBought + "개 구입");
    System.out.println("잔돈(달러):" + funds);
}
```
올바른 답이 나오지만 BigDecimal에는 2가지 단점이 있다.<br/>

기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느리다. 단발성 계산이라면 상관 없지만, 쓰기 불편한건 마찬가지이다.<br/>

그래서 BigDecimal의 대안으로 int 혹은 long으로 쓸 수도 있다.<br/>
그럴 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.<br/>

```
public static void main(String[] args) {
	int funds = 100;
  int itemsBought = 0;
  for (int price=10; funds>=price; price +=10) {
    funds -=price;
      itemsBought++;
  }
  System.out.println(itemBough + "개 구입");
  System.out.println("잔돈(센트):" + funds);
}
```
 
<h2>아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라</h2>

자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. 기본타임인 int, double, boolean 같은 기본 타입과 String, List와 같은 참조 타입이다.<br/>
그리고 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 존재하며, 이를 박싱한 기본 타입이라고 한다.<br/>

예컨대, int, double, boolean에 대응하는 박싱타입은 Integer, Double, Boolean이다.<br/>

기본 타입과 박싱된 기본 타입의 주된 차이점은 크게 3가지이다.<br/>
1. 기본 타입은 값만 있으나, 박싱된 기본 타입은 식별성(identity)이 있어서 값이 같아도 다르게 식별될 수 있다.<br/>
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 null을 가질 수 있다.<br/>
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.<br/>

다음은 Integer 값을 오름차순으로 정렬하는 비교자다.<br/>
compare 메서드는 첫 번째 원소가 두번째 원소보다 작으면 음수, 같으면 0, 크면 양수를 반환한다.<br/>
Integer는 그 자체로 순서가 있으니 이 비교자가 실질적인 의미는 없지만, 흥미로운 사실 하나를 보여준다.<br/>

```
Comparator<Integer> naturalOrder = (i,j) -> (i<j)? -1 : (i==j ? 0 : 1);
```

여기서의 심각한 결함은 두 객체에서는 식별성을 검사하기 때문이다.<br/>
( i < j ) 는 잘 작동한다. <br/>
여기서 i와 j가 참조하는 오토박시된 Integer 인스턴스는 기본 타입 값으로 변환된다. <br/>
그런 다음만약 i가 j보다 작지 않다면 두번째 검사( i == j )가 아뤄진다. ( 식별성 검사)<br/>
i와 j가 서로 다른 Integer 인스턴스라면, 비록 값은 같더라도 비교 결과는 false가 되고, (잘못된 결과인) 1을 반환한다. <br/>
이처럼 같은 객체를 비교하는 것이 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.<br/>

기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder()를 사용하자.

```
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) ->
	int i = iBoxed, j = jBoxed;        // 오토박싱
    return i < j ? -1 : ( i == j ? 0 : 1 );
};
```

지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음, 모든 비교를 이 기본 타입 변수로 수행해야 한다.

다음은 기이하게 동작하는 코드이다.

```
public class Unbelievable {
	static Integer i;
    
  public static void main(String[] args) {
    if (i == 42)
        System.out.println("믿을 수 없군!");
  }
}
```

여기서 i == 42를 검사할 때 NullPointerException을 던지는데, 이는 i가 int가 아닌 Integer이며, 다른 탐조 타입 필드와 마찬가지로 i의 초깃값도 null이라는 데 있다.<br/>
즉 i== 42는 Integer와 int를 비교하는 것인데, 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용하는 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.<br/>
이 때의 해법은 간단한다. i를 int로 선언해주면 끝이다.<br/>

```
public static void main(String[] args) {
	Long sum = 0L;
  for ( long i = 0; i <= Integer.MAX_VALUE; i++ ) {
    sum += i;
  }
  System.out.println(sum);
}
```
하지만 이 프로그램의 실수는 지역변수 sum을 박싱된 기본타입으로 선언하였다는 것이다. <br/>
오류나 경고 없이 컴파일되지만, 박싱과 언방식이 반복해서 일어나 체감될 정도로 성능이 느려진다.<br/>

<h3>박싱된 기본 타입은 언제 써야 하는가?</h3>

첫 번째, 컬렉션의 원소 , 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없다. <br/>
자바 언어가 매개변수로 기본 타입을 지원하지 않기 때문이다. <br/>
두 번째, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.<br/>


<h2>아이템62. 다른 타입이 적절하다면 문자열 사용을 피하라</h2>
문자열(String)은 텍스트를 표현하도록 설계되었고, 그 일을 아주 멋지네 해낸다.
그런데 문자열은 워낙 흔하고 자바가 또 잘 지원해주어 원래 의도하지 않은 용도로도 쓰이는 경향이 있다.

문자열은 다른 값 타입을 대신하기에 적합하지 않다.
받는 데이터가 수치형이라면 int, float, BigInteger 등 적당한 수치 타입으로 변환해야 한다.
'예, 아니오' 질문의 탑이라면 적절한 열거 타입이나 boolean 으로 변환해야 한다.

문자열은 열거 타입을 대신하기에 적합하지 않다.
상수를 열거할 때는 문자열보다는 열거 타입이 월등히 낫다.

문자열은 혼합 타입을 대신하기에 적합하지 않다.
여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 생각이다.

```
String compoundKey = className + "#" + i.next();
```
 
이는 단점이 많다.
혹여라도 두 요소를 구분해주는 문자 #이 두 요소 중 하나에서 쓰였다면 혼란스러운 결과를 초래한다.
각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커진다.
차라리 전용 클래스를 새로 만드는 편이 낫다.

이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.

문자열은 권한을 표현하기에 적합하지 않다.
ex) 권한을 문자열로 표현하는 경우가 종종 있다. 스레드 지역변수 기능을 설계한다고 해보자.

```
// 잘못된 예 - 문자열을 사용해 권한을 구분하였다.
public class ThreadLocal {
	private ThreadLocal() { } // 객체 생성 불가

	// 현재 스레드의 값을 키로 구분해 저장한다.
	public static void set(String key, Object value);

	// (키가 가리키는) 현재 스레드의 값을 반환한다.
	public static Object get(String key);
}
```

이 방식의 문제는 스레드 구분용 문자열 키가 전역 이름공간에서 공유된다는 점이다.
의도대로 동작하려면 각 클라이언트가 고유한 키를 제공해야 한다.

만약 두 클라이언트가 서로 소통하지 못해 같은 키를 쓰기로 결정한다면, 의도치 않게 같은 변수를 공유하게 된다.

결국 두 클라이언트 모두 제대로 기능하지 못할 것이다. 

보안도 취약하다. 악의적인 클라이언트라면 의도적으로 같은 키를 사용하여 다른 클라이은트의 값을 가져올 수도 있다.

```
// key클래스로 권한을 구분했다.
class ThreadLocal {
    private ThreadLocal() { } // 객체 생성 불가

    public static class Key { // (권한)
        Key() { }
    }

    // 위조 불가능한 고유 키를 생성한다. 
    public static Key getKey() {
        return new Key();
    }

    public static void set(Key key, Object value);
    public static Object get(Key key);
}
```

set와 get은 이제 정적 메서드일 이유가 없으니 Key 클래스의 인스턴스 메서드로 바꾸자.
이렇게 하면 Key는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 스레드 지역변수가 된다.

```
// Key를 ThreadLocal로 변경 
public final class ThreadLocal {
    public ThreadLocal();
    public void set(OBject value);
    public Object get();
}
```

이 API에서는 get으로 얻은 Object를 실제 타입으로 형변환해 써야 해서 타입 안전하지 않다.
ThreadLocal을 매개변수 타입으로 선언하여 해당 문제를 해결할 수 있다.

```
매개변수화하여 타입 안전성 확보 
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

<h1>아이템 63. 문자열 연결은 느리니 주의하라</h1>
문자열 연결 연산자(+)는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.
그런데 고정된 객체의 문자열 표현을 만들때라면 괜찮지만, 본격적으로 사용하게 된다면, 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n^2에 비례하게된다.

따라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야하므로 성능 저하는 피할 수 없는 결과다.
성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하라.

```
public String statement(){
	StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
	for(int i=0; i< numItems(); i++){
		b.append(lineForItem(i));
	}
	return b.toString();
}
```
자바 6 이후 문자열 연결 성능을 다방면으로 개선하였지만, String을 사용할때와 StringBuilder를 사용할 때와 성능차이는 여전히 크다.
따라서 문자열 연산자(+)은 피하자.

<h2>아이템 64. 객체는 인터페이스를 사용해 참조하라</h2>
적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 떄 뿐이다.

ex) Set 인터페이스를 구현한 LinkedHashSet 변수를 선언하는 모습니다.

```
// 올바른 예
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예. 클래스 타입으로 사용했다.
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자를 호출해주기만 하면 된다.

```
Set<Son> sonSet = new HashSet<>();
```

위와 같이 바꿔주면 새로 구현한 클래스로의 교체가 완료된다.

단, 원래의 클래스가 인터페이스의 일반 규약 외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작한다면 새로운 클래스에서도 반드시 같은 기능을 제공해야 한다.
예를 들어, 첫 번째 선언의 주변 코드가 LinkedHashSet이 따르는 순서 정책을 가정하고 동작하는 상황에서 이를 HashSet으로 바꾸면 문제가 될 수 있다. 
왜냐면 HashSet은 반복자의 순회 순서를 보장하지 않기 때문이다.

<h3>인터페이스 참조 주의점</h3>
선언 타입과 구현 타입을 동시에 바꿀 수 있다보니 변수를 구현 타입으로 선언해도 괜찮을 거라 생각할 수도 있다.
그래서 자칫하면 프로그램이 컴파일 되지 않을 수 있다.

적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.
String 과 BigInteger 같은 값 클래스가 그렇다.

적합한 인터페이스가 없는 부류는 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이다.
이런 경우라면 특정 구현 클래스보다 기반 클래스를 사용해 참조하는 게 좋다.

<h2>아이템 65. 리플렉션보다는 인터페이스를 사용하라</h2>
리플랙션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
Class 객체가 주어지면 그 클래스의 생성자, 메서드 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있다.
이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다. 
또한 각 인스턴스들을 사용하여 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있다. 
이 인스턴스들을 통해 해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있다. 

리플렉션의 단점 
1. 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
2. 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
3. 성능이 떨어진다.

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점을 취할 수 있다.
리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.

HashSet 이라면 순서가 무작위일 것이고, TressSet을 지정하면 순서가 정렬되어 알파벳 순서로 출력될 것이다.

```
public class Main {
    // 코드 65-1 리플렉션으로 생성하고 인터페이스로 참조해 활용한다. (372-373쪽)
    public static void main(String[] args) {


        // 클래스 이름을 Class 객체로 변환
        Class<? extends Set<String>> cl = null;
        try {
            cl = (Class<? extends Set<String>>)  // 비검사 형변환!
                    Class.forName("java.util.HashSet");
        } catch (ClassNotFoundException e) {
            fatalError("클래스를 찾을 수 없습니다.");
        }

        // 생성자를 얻는다.
        Constructor<? extends Set<String>> cons = null;
        try {
            cons = cl.getDeclaredConstructor();
        } catch (NoSuchMethodException e) {
            fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
        }

        // 집합의 인스턴스를 만든다.
        Set<String> s = null;
        try {
            s = cons.newInstance();
        } catch (IllegalAccessException e) {
            fatalError("생성자에 접근할 수 없습니다.");
        } catch (InstantiationException e) {
            fatalError("클래스를 인스턴스화할 수 없습니다.");
        } catch (InvocationTargetException e) {
            fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
        } catch (ClassCastException e) {
            fatalError("Set을 구현하지 않은 클래스입니다.");
        }

        // 생성한 집합을 사용한다.
        s.addAll(Arrays.asList("a","b","c").subList(1, 3));
        System.out.println(s);
    }

    private static void fatalError(String msg) {
        System.err.println(msg);
        System.exit(1);
    }
}
```

이 예는 리플렉션의 단점 2가지를 보여준다.

1.런타임에 총 6가지나 되는 예외를 던질 수 있다.
그 모두가 인스턴스를 리플렉션 없이 생성했다면 컴파일 타임에 잡아낼 수 있었을 예외들이다.
2.클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성했다.
리플렉션이 아니라면 생성자 호출 한줄로 끝났을 것이다.

참고로 리플렉션 예외 각각을 잡는 대신 모든 리플렉션 예외의 상위 클래스인 ReflectiveOperationException 을 잡도록 하여 코드 길이를 줄일 수도 있다.

객체가 일단 만들어지면 그 후의 코드는 기본 Set 인스턴스를 사용하는 코드와 동일하다. 
이 프로그램을 컴파일하면 비검사 형변환 경고가 뜬다. 
하지만 Class<? extends Set<String>>으로의 형변환은 심지어 명시한 클래스가 Set을 구현하지 않았더라도 성공할 것이라, 실제 문제로 이어지지는 않는다. 
이 경고는 숨길 수 있다.


<h2>아이템 66. 네이티브 메서드는 신중히 사용하라</h2>
자바 네이티브 인터페이스(Java Native Interface, JNI) 는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.  
여기서 네이티브 메서서란 C, C++과 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다. 

전통적으로 네이티브 메서드의 주요 쓰임은 다음 3가지다.
1) 레지스트리와 같은 플랫폼 특화 기능을 말한다.
2) 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 레거시 데이터를 사용하는 레거시 라이브러리가 그 예다.
3) 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.
-> JVM에는 거의 해당되지 않는다.

성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.

네이티브 메서드의 단점
1) 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더이상 안전하지 않다.
2) 네이티브 언어는 자바보다 플랫폼을 많이 타서 이식성도 낮다.
3) 디버깅도 더 어렵다.
4) 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수 없다. 
5) 자바 코드와 네이티브 코드 사이의 '접착 코드(glue code)' 를 작성해야하는데, 이는 가독성이 떨어지고 귀찮은 작업이다.

