<h1>아이템 20. 추상 클래스보다는 인터페이스를 우선하라.</h1>

  인터페이스 vs 추상 클래스를 비교해보자.  <br/>
  
  [추상 클래스]  <br/>
  - java에서는 단일 상속만 지원되니 "추상"클래스에서는 새로운 타입을 정의하는 데 제약이 있다.<br/>
  - 클래스는 두 부모를 섬길 수 없다.<br/>
  - 두 클래스가 같은 추상 클래스를 extends하고 있다면, 그 추상 클래스는 계층 구조상 두 클래스의 공통 조상이어야 한다.<br/>
  - 새로 추가된 추상클래스의 모든 자손이 이를 상속해야 되는 것이다.<br/>
  - 만약에 적절하지 않은 상황임에도 그래야된다.<br/>
  <br/>
  
  [인터 페이스]<br/>
  - 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급한다.<br/>
  - 기존 클래스에 손쉽게 새로운 인터페이스를 구현해서 넣을 수 있다.<br/>
  - 클래스 선언에 implements만 추가하면 된다.<br/>
  - 믹스인하기 좋다. 주된 타입외에도 특정 선택적 행위를 제공한다고 선언할 수 있다. <br/>
   ; 이는 여러개의 implements를 할 수 있으므로 가능하다.<br/>
  - 계층구조가 없는 타입 프레임워크를 만들 수 있다.<br/>
  - 기능을 향상시키는 안전하고 강력한 래퍼클래스 관용구를 함께 사용할 수 있다.
  - 디폴트 메서드를 제공해 프로그래머들의 일감을 덜어줄 수 있다.
  <br/>
  
  <h3>계층구조가 없는 타입 프레임워크를 만들 수 있다</h3>
  
  현실에서는 계층을 엄격하게 구분하기 어려운 개념도 있다. 예를 들어 가수 Singer 인터페이스와 작곡가 Songwriter 인터페이스가 있다고 해보자.<br/>
  
  ```
  public interface Singer{  
    AudioClip sing(Song s);  
  }  
  
  public interface Songwriter{  
    Song compose (int charPosition);  
  }  
  ```
  <br/>
  
  우리 주변엔 작곡도 하는 가수가 제법있다. 그런 경우에는 위의 2개의 implements를 사용하면되고, 심지어 새로운 메서드까지 추가하는 제 3의 인터페이스도 만들 수 있다.
  
  ```
  public interface SingSongwriter implements Singer, Songwriter{  
    AudioClip strum();
    void actSensitive();
  }  
  ```
  <br/>
  
  <h3>기능을 향상시키는 안전하고 강력한 래퍼클래스 관용구를 함께 사용할 수 있다.</h3>
  - 타입을 추상 클래스로 정의해두면 그 타입에 기능을 추가하는 방법은 상속뿐이다.
  - 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기는 더 쉽다.

  (래퍼 클래스 : https://m.blog.naver.com/itinstructor/100202885690)
  
  <h3>디폴트 메서드를 제공해 프로그래머들의 일감을 덜어줄 수 있다.</h3>
  
  Java8 부터는 인터페이스에서 디폴트 메소드 기능을 제공해 개발자들이 중복되는 메소드를 구현하는 수고를 덜어줄 수 있게 되었다. 
  하지만 디폴트 메소드에도 단점은 존재한다. 
  Object의 equals, hashcode 같은 메소드는 디폴트 메소드로 제공해서는 안 된다. 
  또한 public이 아닌 정적 멤버도 가질 수 없다. 
  또한 본인이 만들지 않은 인터페이스에는 디폴트 메소드를 추가할 수 없다. 

  한편, 인터페이스와 추상 골격 구현 클래스를 함께 제공하면 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.
  1) 인터페이스로는 타입을 정의하고 필요한 일부 디폴트 메소드를 구현한다.
  2) 추상 골격 구현 클래스는 나머지 메소드들 까지 구현한다. 
  3) 이렇게 하면 추상 골격 구현 클래스를 확장하는 것만으로 인터페이스를 구현하는데 대부분 일이 완료된다. 

  이는 템플릿 메소드 패턴과 같다. 
  이런 추상 골격 구현 클래스를 보여주는 좋은 예로는 컬렉션 프레임워크의 AbstractList, AbstractSet 클래스이다. 
  이 두 추상 클래스는 각각 List, Set 인터페이스의 추상 골격 구현 클래스이다.
  
  
