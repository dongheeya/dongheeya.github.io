<h1>int 상수 대신 열거 타입을 사용하라</h1>
열거타입이란, 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.<br/>
ex) 사계절, 태양계의 행성, 카드게임의 카드 종류 <br/>

자바에서 열거 타입을 지원하기 전에는 다음처럼 정수 상수를 한 묶음 선언해서 사용하곤 했다.<br/>

```
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;
public static final int APPLE_GRANNY_SMITH = 2;

public static final int APPLE_NAVEL = 0;
public static final int APPLE_TEMPLE = 1;
public static final int APPLE_BLOOD = 2;
```

이런 정수 열거 패턴(int enum pattern) 기법에는 단점이 많다.<br/>
- 타입의 안전을 보장할 방법이 없다.<br/>
- 표현력이 좋지 않다.<br/>
- 오렌지를 건네야 할 메서드에 사과를 보내고 동등 연산자(==)로 비교하더라도 컴파일러는 아무런 경고 메세지를 출력하지 않는다.<br/>
- 별도 이름 공간(namespace)을 지원하지 않기 때문에 어쩔 수 없이 접두어를 써서 이름 충돌을 방지해야 한다.<br/>
  ex) 사과용 상수 이름을 모두 APPLE_ ~로 시작하게 만들고, 오렌지용 상수는 ORANGE_~로 접두어를 사용해서 구분.<br/>
- 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다. 평범한 상수를 나열한것뿐이라 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨진다. <br/>
 따라서 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야 한다. 그렇지 않으면 엉뚱하게 동작할 것이다.<br/>
- 문자열로 출력하기가 다소 까다롭다. 그 값을 출력하거나 디버거로 살펴보면 단지 숫자로만 보여서 썩 도움이 되지 않는다.<br/>
- 그 안에 상수가 몇 개인지 알 수 없다.<br/>
- 같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅하지 않다.<br/>

이에 반해, 열거 타입은(enum type) 열거 패턴의 단점을 말끔히 씻어주는 동시에 여러 장점이 있다.

```
// 코드 34-2
public enum Apple { FIJU, PIPPIN, GRANNY_SMITH};
public enum Orange { NAVEL, TEMPLE, BLOOD};
```

열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나식 만들어 public static final 필드로 공개한다.<br/>
열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.<br/>
따라서 클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없으니 열거 타입으로 만들어진 인스턴스들은 딱 하나씩만 존재한다.<br/>

<h3>열거 타입의 장점</h3>
- 컴파일 타입 안전성을 제공한다.<br/>
 예를들어, 위에 Apple 열거타입을 매개변수로 받는 메서드를 선언했다면, 건네받은 참조는 (null이 아니라면) Apple의 세 가지 값 중 하나임이 확실하다.<br/>
 다른 타입의 값을 넘기려 하면 컴파일 오류가 난다. (위에 정수 열거 패텬과 다르게) 다른 열거 타입의 값끼리 == 연산자로 비교할 수 없다.<br/>
- 각자의 이름공간이 있어서 이름이 같은 상수도 평화롭게 공존한다.<br/>
- 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.<br/>
- 공개되는 것이 오직 필드의 이름뿐이라, 정수 열거 패턴과 달리 상수 값이 클라이언트로 컴파일되어 각인되지 않기 때문이다.<br/>
- toString 메서드는 출력하기에 적합한 문자열을 내어준다.<br/>

<h3>열거 타입의 활용</h3>
- 열거 타입에 메서드나 필드를 추가해서 활용할 수 있다.<br/>
ex) Apple과 Orange를 예를 든다면, 과일의 색을 알려주거나 과일 이미지를 반환하는 메서드를 추가하고 싶을 수 있다.<br/>
- 가장 단순하게는 상수 모음일 뿐인 열거 타입이지만, (실제로는 클레스이므로) 고차원의 추상 개념 하나를 완벽히 표현할 수도 있는 것이다.<br/>

- 태양계의 여덟 행성은 거대한 열거 타입을 설명하기에 좋은 예이다.<br/>
- 각 행성에는 질량과 반지름이 있고, 이 두 속성을 이용해 표면 중력을 계산하고 있다.<br/>
- 따라서 어떤 객체의 질량이 주어지면 그 객체의 행성 표면에 있을 때의 무게도 알 수 있다.<br/>

```
public enum Planet {
    // 각각 class이고 생성자에 넘겨지는 매개변수로(질량, 반지름)을 뜻함
    MERCURY(3.302e+23, 2.439e6),
    VENUS  (4.869e+24, 6.052e6),
    EARTH  (5.975e+24, 6.378e6),
    MARS   (6.419e+23, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN (5.685e+26, 6.027e7),
    URANUS (8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.477e7);

    private final double mass;            // 질량 (단위: 킬로그램)
    private final double radius;          // 반지름 (단위: 미터)
    private final double surfaceGravity; // 표면중력 (단위: m / s^2)

    // 중력 상수 (단위 : m^3 / kg s^2)
    private static final double G = 6.67300E-11;

    // 생성자 
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius); 
    } 

    public double getMass() {
        return mass;
    }

    public double getRadius() {
        return radius;
    }

    public double surfaceGravity() {
        return surfaceGravity;
    }

    // 표면 중력을 계산해 저장하는 이유는 단순히 최적화를 위함.
    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}
```

보다시피 거대한 열거 타입을 만드는 일도 그리 어렵지 않다.<br/>
열거 타입 상수 각각을 데이터와 연결지으러면 생성자에 데이터를 받아 인스턴스 필드에 저장하면 된다.<br/>
열거 타입은 근본적으로 불변이라 모든 필드는 final이어야 한다.<br/>
또한 필드를 public으로 해도되지만 private으로 두고 별도의 public 접근자 메서드를 두는 게 낫다.<br/>

Planet 열거 타입은 단순하지만 놀랍도록 강력하다.<br/>
어떤 객체의 지구에서의 무게를 입력받아 여덟 행성에서의 무게를 출력하는 일은 다음처럼 짭은 코드로 작성할 수 있다.<br/>

```
public class WeightTable {
	public static void main(String[] args) {
		double earthWeight = Double.parseDouble(args[0]);
		double mass = earthWeight / Planet.EARTH.surfaceGarvity();
		for (Planet p : Planet.values()) {
			System.out.printf("%s에서의 무게는 %f이다.%n", p, p.surfaceWeight(mass));
		}			
	}
}

// 결과 일부
MECURY에서의 무게는 69.912739이다.
VENUS에서의 무게는 167.434436이다.
```
 
  
