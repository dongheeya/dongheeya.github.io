<h1>10장 예외</h1>

예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못 사용하면 반대의 효과만 나타낸다.<BR/>
이번 장에서는 예외를 효과적으로 활용하는 지침을 다룬다.<BR/>


<h2>아이템 69. 예외는 진짜 예외 상황에만 사용하라</h2>

```
// 예외를 완전히 잘못 사용한 예.
try {
  int i=0;
  while(true){
    range[i++].climb();
  }
}catch(ArrayIndexOutOfBoundsException e){
}
```

해당 코드는 전혀 직관적이지 않다는 사실 하나만으로도 코드를 이렇게 작성하면 안된다.(아이템 67)<BR/>
이 코드는 배열의 원소를 순회하는 데 아주 끔찍한 방법으로 하고 있다.<BR/>
무한 로프를 돌다가 배열의 끝에 도달해 ArrayIndexOutOfBoundsException이 발생하면 끝을 내는 것이다.<BR/>

이 코드를 다음과 같이 표준적인 관용구대로 작성했다면 모든 자바 프로그래머가 곧바로 이해했을 것이다.<BR/>

```
for(Mountain m : range)
  m.climb();
```

위에 잘못된 코드에서 왜 루프를 써서 종료한 것일까? 이는 잘못된 푸론을 근거로 성능을 높여보려 한 것이다.<BR/>
JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료된다.<BR/>
따라서 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.<BR/>

실상 예외를 사용한 쪽이 표준 관용구에 비해 훨씬 느리다.(테스트 결과 2배)<BR/>

예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않는다.<BR/>
심지어 제대로 동작하지 않을 수도 있다.<BR/>

심지어 반복문 안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게할 것이다.<BR/>

따라서 예외는 오직 예외 상황에서만 사용해야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.<BR/>
더 일반화하자면, 표준적이로 쉽게 이해되는 관용구를 사용하고 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.<BR/>

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.<BR/>
특정 상태에서만 호출할 수 있는 '상태 의존적'메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다.<BR/>

Interator 인터페이스의 next와 hasNext 가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당된다.<BR/><BR/>
Iterator가 hasNext를 제공하지 않았다면 그 일을 클라이언트가 대신해야만 했다.<BR/>

```
for (Interator<Foo> i = collection.iterator(); i.hasNext(); ) {
  Foo foo = i.next(); 
  ... 
}
```

이 코드는 배열을 순회하던 윗 코드와 상당히 비슷해 보인다.<BR/>
반복문에 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에서 발생한 버그를 숨기기도 한다.<BR/>

```
try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
        Foo foo = i.next();
        ...
    }
} catch (NoSuchElementException e){
}
```

상태 검사 메서드 대신 사용할 수 있는 선택지도 있다.<BR/>
올바르지 않은 상태일 때 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법이다.<BR/>
상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침을 알아보자.<BR/>

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나, 외부 요인으로 상태가 변할 수 있다.<BR/>
옵셔널이나 특정 값을 사용한다.<BR/>
상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.<BR/>
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행하는 일을 한다.<BR/>
옵셔널이나 특정 값을 선택한다.<BR/>
3. 다른 모든 경우에는 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.<BR/>
가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다.<BR/>
상태 검사 메서드 호출을 잊었다면, 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다.<BR/>
반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다.<BR/>

<H2>아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.</H2>

자바는 문제 상황을 알리는 타입으로 검사 예외, 런타임 예외, 에러, 이렇게 세 가지를 제공하는데, 언제 무엇을 사용해야 할까?<BR/>
<h3>1. 검사 예외</h3>
호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.<BR/>
검사 예외를 던지면 호출자가 그 예외를  CATCH로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.<BR/>
따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API사용자에게 알려주는 것이다.<BR/>

<h3>2. 비검사 예외</h3>
비검사 예외 throwable은 2가지로 바로 런타임 에러와 에러다.<BR/>
이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다.<BR/>
프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 것이다.<BR/>

프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.<BR/>
ex) 배역의 인덱스는 0에서 배열 크기 -1 사이어야 한다. ArrayIndexOutOfBoundsException이 발생했다는 건 이 전제조건이 지켜지지 않았다는 뜻이다.<BR/>
이상의 조건에서 문제가 하나 있다면 복구할 수 있는 상황인지 프로그램 오류인지가 항상 명확히 구분되지는 않는다는 사실이다.<BR/>

예를 들어 자원 고갈이 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류라고 할때, 복구 가능하다고 믿는다면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하자.<BR/>

에러는 보통 jvm이 자원 부족, 불변식 꺠짐 등 더이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.<BR/>
다시 말해 여러분이 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.<BR/>
Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.<BR/>
throwable은 이로울게 없으니 절대 사용하지 말자!<BR/>

<h3>핵심 정리</h3>
복구할 수 있는 상황 : 검사 예외 - 필요한 정보를 알려주는 메서드도 제공하자<BR/>
프로그래밍 오류 : 비검사 예외<BR/>
학실하지 않으면 : 비검사 예외<BR/>
검사 예외도 아니고, 런타임 예외도 아닌 throwable은 정의하지도 말자.<BR/>

<h2>아이템 71. 필요 없는 검사 예외 사용은 피하라.</h2>
검사 예외를 싫어하는 자바 프로그래머는 많지만 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.<BR/>
결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.<BR/>

어떤 메서드가 검사 예외를 던질 수 있다고 선언했다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다.<BR/>
어느쪽이든 API 사용자에게 부담을 준다.<BR/>
검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터는 부담이 더욱 커졌다.<BR/>
API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우라면 이 정도 부담쯤은 받아들일 수 있다.<BR/>
그러나 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는게 좋다.<BR/>

검사 예외, 비검사 예외 중 어느 것을 선택해야 할지는 프로그래머가 그 예외를 어떻게 다룰지 생각해보면 알 수 있다. 아래와 같은 상황에선 비검사 예외를 선택해야 한다.<BR/>

```
} catch(TheCheckedException e){
    throw new AssertionError();  //일어날 수 없다.
}


} catch(TheCheckedException e) {
    e.printStackTrace();
    System.exit(1);
}
```

더 나은 방법이 없다면 비검사예외를 사용하라.<BR/>
검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다.<BR/>

검사 예외를 회피하는 방법<BR/>
1. 적절한 결과 타입을 담은 옵셔널을 반환하라<BR/>
이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.<BR/>
반면에 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.<BR/>

2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.<BR/>

```
// 검사 예외 던지기 - 리팩터링 전
try {
    obj.action(args);
} catch (TheCheckException e) {
  ... // 예외 상황에 대처한다.     
}

// 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후
if(obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황에 대처한다.
}
```

러팩터링 후의 API가 딱히 더 아름답지는 않지만, 더 유연한 것은 확실하다.<BR/>
프로그래머가 이 메서드가 성공하리라는 걸 안다거나, 실패 시 스레드 중단하길 원한다면 다음처럼 한줄로 작성해도 무방하다.<BR/>

```
obj.action(args);
```

<h3>핵심정리</h3>
꼭 필요한 곳에서만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 api를 낳는다.<BR/>


<h2>아이템 72. 표준 예외를 사용하라.</h2>

숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.<BR/>
예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기 충분한 수의 에외를 사용한다.<BR/>

<h3>표준 예외의 장점</h3>
- api가 다른 사람이 익히고 사용하기 쉬워진다.<BR/>
- 낯선 예외를 사용하지 않게 되어 읽기 쉬워진다.<BR/>
- 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스 적재하는 시간도 적게 된다.<BR/>

ex) IllegalArgumentException : 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외. 반복 횟수 지정하는 매개변수에 음수를 건넬 때.<BR/>
IllegalStateException : 대상 객체의 상태가 호출된 메서드를 수행하시에 적합하지 않을 때 주로 사용. 제대로 초기화되지 않은 객체를 사용하러 할때.<BR/>
인수 값이 무엇이었든 어차피 실패했을 때.<BR/>
NullPointerException : null 값을 허용하지 않는 메서드에 null을 건낼 때.<BR/>
IndexOutOfBoundsException : 시퀀스의 허용 범위를 넘는 값을 건낼 때.<BR/>
ConcurrentModificationException : 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때. 알려주는 정도의 역할.<BR/>
UnsupportedOperationException : 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때.<BR/>


Exception, RuntimException, Throwable, Error는 직접 재사용하지 말자.<BR/>
여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.<BR/>


<h2>아이템 73. 추상화 수준에 맞는 예외를 던지라</h2>

수행하려는 일과 관련 어 보이는 예외가 튀어나오면 당황스러울 것이다.<BR/>
메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다.<BR/>
내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.<BR/>

<h3>예외 번역(exceptin translation)</h3>
상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 

```
// 예외 번역
try {
    ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);    
}
```

<h3>예외 연쇄(exception chanining)</h3>
예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<BR/>
별도의 접근자 메서드를 통해 필요하면 언제든 저수준 예외를 꺼내볼 수 있다.<BR/>

```
// 예외 번역
try {
    ... // 저수준 추상화를 이용
} catch (LowerLevelException cause) {
    //저수준 예외를 고수준 예외에 실어 보낸다. 
    throw new HigherLevelException(cause);    
}

// 예외 연쇄용 생성자
class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다. <BR/>
그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 '원인'을 직접 못박을 수 있다. <BR/>
고수준 예외의 생성자는 (예외 연쇄용으로 설계된) 상위 클래스의 생성자에 '원인'을 건네주어, 최종적으로 Throwable(Throwable) 생성자까지 건네지게한다.<BR/>

```
class HigerLevelException extends Exception {
  HigerLevelException(Throwable cause){
    super(cause);
  }
}
```

대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다.<BR/>
그렇지 않은 예외라도 throwable 의 initCuase 메서드를 이용해 '원인'직접 못박을 수 있다.<BR/>
예외 연쇄는 문제의 원인을 getCause 메서드로 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 추적 정보를 잘 통합해 준다.<BR/>

무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇닥 남용해서는 곤란하다.<BR/>
가능하다면 저수준 메서드가 반드시 성공하도록하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<BR/>

때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건내기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다.<BR/>

아래 계층에서의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API호출자에까지 전파하지 않는 방법이 있다<BR/>
이 경우 발생하는 예외는 java.util.logging 같은 적절한 로깅 기능을 활용하여 기록해두면 좋다.<BR/>

<h3>핵심 정리</h3>
아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.<BR/>

<h2>아이템 74. 메서드가 던지는 모든 예외를 문서화하라.</h2>
메서드가 던지는 예외는 그 메서드를 올바로 사용하는 데 아주 중요한 정보다.<BR/>
따라서 각 메서드가 던지는 예외 하나하나를 문서화하는 데 충분한 시간을 쏟아야 한다.(아이템 56)<BR/>

검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.<BR/>
공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 삼가자.<BR/>

메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할 뿐더라, 같은 맥락에서 발생할 여지가 잇는 다른 예외들까지 삼켜버릴 수 있어 API사용성을 크게 떨어트린다.<BR/>

비검사 에외도 검사 예외처럼 정성껏 문서화하라.<BR/>
비검사 예외는 일반적으로 프로그래밍 오류를 뜻하는데(아이템 70), 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩해준다.<BR/>

메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws목록에 넣지 말자.<BR/>
검사냐 비검사냐에 따라 API 사용자가 해야할 일이 달라지므로 이 둘을 확실히 구분해주는 게 좋다.<BR/>
자바독 유틸리티는 메서드 선언의 throws 절에 등장하고 메서드 주석의 @throws 태그에도 명시한 예외와 @throws 태그에만 명시한 예외를 시각적으록 구분해준다.<BR/>

비검사 예외도 모두 문서화하라고 했지만, 오히려 언급되지 않은 새로운 비검사 예외를 전파하게 될 것이다.

한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있다.<BR/>
NullPointerException이 가장 흔한 사례다.<BR/>

<h2>아이템 75. 예외의 상세 메세지에 실패 관련 정보를 담으라</h2>

예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외 스택 추적 정보를 자동으로 출력한다.<BR/>
스택 추적은 예외 객체의 toString 메서드를 호출해 얻는 문자열로, 보통은 예외의 클래스 이름 뒤에 상세 메세지가 붙는 형태다.<BR/>

실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담아야 한다.<BR/>
관련 데이터를 모두 담아야 하지만 장황할 필요는 없다.<BR/>
예외의 상세 메세지와 최종 사용자에게 보여줄 오류 메세지를 혼동해서는 안된다.<BR/>
예외 메세지는 가독성보다는 담긴 내용이 훨씬 중요하다.<BR/>

실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아서 상세 메세지까지 미리 생성해놓는 방법도 괜찮다.<BR/>

```
/**
 * IndexOutOfBoundsException을 생성한다.
 *
 * @param lowerBound 인덱스의 최솟값
 * @param upperBound 인덱스의 최댓값 + 1
 * @param index 인덱스의 실젯값
 */
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {
   // 실패를 포착하는 상세 메시지를 생성한다.
   super(String.format("최솟값: %d, 최댓값: %d, 인덱스: %d", lowerBound, upperBound, index));

   // 프로그램에서 이용할 수 있도록 실패 정보를 저장해둔다.
   this.lowerBound = lowerBound;
   this.upperBoudn = upperBound;
   this.index = index;
}
```

이렇게 해두면 프로그래머가 던지는 예외는 자연스럽게 실패를 더 잘 포착한다.<BR/>
실패를 포착하지 못하게 만드는 게 오히려 더 어려울 것이다<BR/>

포착한 실패 정보는 예외 상황을 복구하는 데 유용할 수 있으므로 접근자 메서드는 비검사 예외보다는 검사 예외에서 더 빛을 발한다.<BR/>


<h2>아이템 76. 가능한 한 실패 원자적으로 만들라</h2>

호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태로 유지해야 한다.<BR/>
이러한 특성을 실패 원자적(failure-atomic)이라고 한다.<BR/>

메서드를 실패 원자적으로 만드는 방법이 다양하다.<BR/>

<h3>방법 1. 불변 객체로 만들기</h3>
가장 간단한 방법은 불변 객체로 설계하는 것이다(아이템 17)<BR/>
불변 객체는 태생적으로 실패 원자적이다.<BR/>
불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않기 때문이다.<BR/>

<h3>방법 2. 작업 수행에 앞서 매개변수의 유효성을 검사</h3>
가변 객체의 메서드를 실패 원자적으로 만드는 가장 흔한 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는 것이다(아이템 49)<BR/>
객체의 내부 상태를 변경하기 전에 잠재적 예외의 가능성 대부분을 걸러낼 수 있는 방법이다.<BR/>

```
public Object pop() {
  if(size == 0){
      throw new EmptyStackException();
  }
  Object result = elements[--size];
  elements[size] = null // 다쓴 참조 해제
  return result;
}
```

이 메서드는 처음의 if문에서 size의 값을 확인하여 0이며 예외를 던진다.<BR/>
다만 size 의 값이 음수가 되어 다음 번 호출도 실패하게 만들며, 이때 던지는 ArrayIndexOutofBoundsException은 추상화 수준이 상황에 어울리지 않다고 볼수 있다.<BR/>
덧붙여서 실패할 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법을 추가로 사용할 수 있다.<BR/>

<h3>방법 3.객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체</h3>
실패 원자성을 얻는 세 번째 방법은 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하는 것이다.<BR/>
데이터 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식이다.<BR/>

<h3>방법 4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법</h3>
주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 쓰이지만 자주 쓰이지는 않는다.<BR/>


실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는 것은 아니다.<BR/>
실패 원자적으로 만들 수 있더라도 항상 그리 해야하는 것도 아니다.<BR/>
실패 원자성을 달성하기 위한 비용이나 복잡도가 아주 큰 연산도 있기 때문이다.<BR/>

실패 원자적으로 만들수 있더라도, 비용이나 복잡도가 큰 연산의 경우는 제외해야 한다.<BR/>
또한 메서드 명세에 기술한 예외라면 혹시나 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본규칙이다. <BR/>
이를 지키지 못한다면 API 설명에 명시해야 하지만 잘 지켜지지 않고 있다.<BR/>

<h2>아이템 77. 예외를 무시하지 말라</h2>

API 설계자가 메서드 선언에 예외를 명시하는 까닭은, 그 메서드를 사용할 때 적절한 조치를 취해달라고 말하는 것이다.
API 설계자의 목소리를 흘려버리지말자. 안타깝게도 예외를 무시하기란 아주 쉽다. 해당 메서드 호출을 try문으로 감싼 후 catch 블록에서 아무일도 하지 않으면 끝이다.

```
try {
    ...
} catch (SomeException e) {
}
```

예외는 문제 상황에 잘 대처하기 위해 존재하는 데 catch 불록을 비워두면 예외가 존재할 이유가 없어진다.

<h3>예외를 무시해야 할 때</h3>
예외는 문제 상황에 잘 대처하기 위해 존재하는데, catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
예외를 무시하기로 했다면(간혹 무시해야 할 때도 있다 - FileInputStream) catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓도록 하자.

```
Future<Integer> f = exec.submit(planarMap::chromticNumber);
int numColors = 4; //기본. 어떤 지도라도 이 값이면 충분하다
try {
    numColors = f.get(1L, TimeUnit.SECONDS);
} catch (TimeOutException | ExecutionExcetion ignored) {
    // 기본값을 사용한다(색상 수를 최소화하면 좋지만, 필수는 아니다.)
}
```

이번 절의 내용은 검사와 비검사 예외에 똑같이 적용된다.
예측할 수 있는 예외 상황이든 프로그래밍 오류든, 빈 catch 블록으로 못 본척 지나치면 그 프로그램은 오류를 내재한 채 동작하게 된다.
예외를 적절히 처리하면 오류를 완전히 피할 수도 있다.
무시하지 않고 바깥으로 전파되게만 놔둬도 최소한 디버깅 정보를 남긴 채 프로그램이 신속히 중단되게는 할 수 있다.
