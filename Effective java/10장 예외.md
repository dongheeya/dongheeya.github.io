<h1>10장 예외</h1>

예외를 제대로 활용한다면 프로그램의 가독성, 신뢰성, 유지보수성이 높아지지만, 잘못 사용하면 반대의 효과만 나타낸다.<BR/>
이번 장에서는 예외를 효과적으로 활용하는 지침을 다룬다.<BR/>


<h2>아이템 69. 예외는 진짜 예외 상황에만 사용하라</h2>

```
// 예외를 완전히 잘못 사용한 예.
try {
  int i=0;
  while(true){
    range[i++].climb();
  }
}catch(ArrayIndexOutOfBoundsException e){
}
```

해당 코드는 전혀 직관적이지 않다는 사실 하나만으로도 코드를 이렇게 작성하면 안된다.(아이템 67)<BR/>
이 코드는 배열의 원소를 순회하는 데 아주 끔찍한 방법으로 하고 있다.<BR/>
무한 로프를 돌다가 배열의 끝에 도달해 ArrayIndexOutOfBoundsException이 발생하면 끝을 내는 것이다.<BR/>

이 코드를 다음과 같이 표준적인 관용구대로 작성했다면 모든 자바 프로그래머가 곧바로 이해했을 것이다.<BR/>

```
for(Mountain m : range)
  m.climb();
```

위에 잘못된 코드에서 왜 루프를 써서 종료한 것일까? 이는 잘못된 푸론을 근거로 성능을 높여보려 한 것이다.<BR/>
JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사하는데, 일반적인 반복문도 배열 경계에 도달하면 종료된다.<BR/>
따라서 이 검사를 반복문에도 명시하면 같은 일이 중복되므로 하나를 생략한 것이다.<BR/>

실상 예외를 사용한 쪽이 표준 관용구에 비해 훨씬 느리다.(테스트 결과 2배)<BR/>

예외를 사용한 반복문의 해악은 코드를 헷갈리게 하고 성능을 떨어뜨리는데서 끝나지 않는다.<BR/>
심지어 제대로 동작하지 않을 수도 있다.<BR/>

심지어 반복문 안에 버그가 숨어 있다면 흐름 제어에 쓰인 예외가 이 버그를 숨겨 디버깅을 훨씬 어렵게할 것이다.<BR/>

따라서 예외는 오직 예외 상황에서만 사용해야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.<BR/>
더 일반화하자면, 표준적이로 쉽게 이해되는 관용구를 사용하고 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.<BR/>

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.<BR/>
특정 상태에서만 호출할 수 있는 '상태 의존적'메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 한다.<BR/>

Interator 인터페이스의 next와 hasNext 가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당된다.<BR/><BR/>
Iterator가 hasNext를 제공하지 않았다면 그 일을 클라이언트가 대신해야만 했다.<BR/>

```
for (Interator<Foo> i = collection.iterator(); i.hasNext(); ) {
  Foo foo = i.next(); 
  ... 
}
```

이 코드는 배열을 순회하던 윗 코드와 상당히 비슷해 보인다.<BR/>
반복문에 예외를 사용하면 장황하고 헷갈리며 속도도 느리고, 엉뚱한 곳에서 발생한 버그를 숨기기도 한다.<BR/>

```
try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
        Foo foo = i.next();
        ...
    }
} catch (NoSuchElementException e){
}
```

상태 검사 메서드 대신 사용할 수 있는 선택지도 있다.<BR/>
올바르지 않은 상태일 때 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법이다.<BR/>
상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침을 알아보자.<BR/>

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나, 외부 요인으로 상태가 변할 수 있다.<BR/>
옵셔널이나 특정 값을 사용한다.<BR/>
상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.<BR/>
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행하는 일을 한다.<BR/>
옵셔널이나 특정 값을 선택한다.<BR/>
3. 다른 모든 경우에는 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.<BR/>
가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다.<BR/>
상태 검사 메서드 호출을 잊었다면, 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러낼 것이다.<BR/>
반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다.<BR/>

<H2>아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.</H2>

자바는 문제 상황을 알리는 타입으로 검사 예외, 런타임 예외, 에러, 이렇게 세 가지를 제공하는데, 언제 무엇을 사용해야 할까?<BR/>
<h3>1. 검사 예외</h3>
호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.<BR/>
검사 예외를 던지면 호출자가 그 예외를  CATCH로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다.<BR/>
따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API사용자에게 알려주는 것이다.<BR/>

<h3>2. 비검사 예외</h3>
비검사 예외 throwable은 2가지로 바로 런타임 에러와 에러다.<BR/>
이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다.<BR/>
프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 것이다.<BR/>

프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.<BR/>
ex) 배역의 인덱스는 0에서 배열 크기 -1 사이어야 한다. ArrayIndexOutOfBoundsException이 발생했다는 건 이 전제조건이 지켜지지 않았다는 뜻이다.<BR/>
이상의 조건에서 문제가 하나 있다면 복구할 수 있는 상황인지 프로그램 오류인지가 항상 명확히 구분되지는 않는다는 사실이다.<BR/>

예를 들어 자원 고갈이 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류라고 할때, 복구 가능하다고 믿는다면 검사 예외를, 그렇지 않다면 런타임 예외를 사용하자.<BR/>

에러는 보통 jvm이 자원 부족, 불변식 꺠짐 등 더이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.<BR/>
다시 말해 여러분이 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.<BR/>
Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.<BR/>
throwable은 이로울게 없으니 절대 사용하지 말자!<BR/>

<h3>핵심 정리</h3>
복구할 수 있는 상황 : 검사 예외 - 필요한 정보를 알려주는 메서드도 제공하자<BR/>
프로그래밍 오류 : 비검사 예외<BR/>
학실하지 않으면 : 비검사 예외<BR/>
검사 예외도 아니고, 런타임 예외도 아닌 throwable은 정의하지도 말자.<BR/>

<h2>아이템 71. 필요 없는 검사 예외 사용은 피하라.</h2>
검사 예외를 싫어하는 자바 프로그래머는 많지만 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.<BR/>
결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.<BR/>

어떤 메서드가 검사 예외를 던질 수 있다고 선언했다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다.<BR/>
어느쪽이든 API 사용자에게 부담을 준다.<BR/>
검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터는 부담이 더욱 커졌다.<BR/>
API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우라면 이 정도 부담쯤은 받아들일 수 있다.<BR/>
그러나 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는게 좋다.<BR/>

검사 예외, 비검사 예외 중 어느 것을 선택해야 할지는 프로그래머가 그 예외를 어떻게 다룰지 생각해보면 알 수 있다. 아래와 같은 상황에선 비검사 예외를 선택해야 한다.<BR/>

```
} catch(TheCheckedException e){
    throw new AssertionError();  //일어날 수 없다.
}


} catch(TheCheckedException e) {
    e.printStackTrace();
    System.exit(1);
}
```

더 나은 방법이 없다면 비검사예외를 사용하라.<BR/>
검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다.<BR/>

검사 예외를 회피하는 방법<BR/>
1. 적절한 결과 타입을 담은 옵셔널을 반환하라<BR/>
이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.<BR/>
반면에 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다.<BR/>

2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.<BR/>

```
// 검사 예외 던지기 - 리팩터링 전
try {
    obj.action(args);
} catch (TheCheckException e) {
  ... // 예외 상황에 대처한다.     
}

// 상태 검사 메서드와 비검사 예외를 던지는 메서드 - 리팩터링 후
if(obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // 예외 상황에 대처한다.
}
```

러팩터링 후의 API가 딱히 더 아름답지는 않지만, 더 유연한 것은 확실하다.<BR/>
프로그래머가 이 메서드가 성공하리라는 걸 안다거나, 실패 시 스레드 중단하길 원한다면 다음처럼 한줄로 작성해도 무방하다.<BR/>

```
obj.action(args);
```

<h3>핵심정리</h3>
꼭 필요한 곳에서만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 api를 낳는다.<BR/>


<h2>아이템 72. 표준 예외를 사용하라.</h2>

숙련된 프로그래머는 그렇지 못한 프로그래머보다 더 많은 코드를 재사용한다.<BR/>
예외도 마찬가지로 재사용하는 것이 좋으며, 자바 라이브러리는 대부분 API에서 쓰기 충분한 수의 에외를 사용한다.<BR/>

<h3>표준 예외의 장점</h3>
- api가 다른 사람이 익히고 사용하기 쉬워진다.<BR/>
- 낯선 예외를 사용하지 않게 되어 읽기 쉬워진다.<BR/>
- 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스 적재하는 시간도 적게 된다.<BR/>

ex) IllegalArgumentException : 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외. 반복 횟수 지정하는 매개변수에 음수를 건넬 때.<BR/>
IllegalStateException : 대상 객체의 상태가 호출된 메서드를 수행하시에 적합하지 않을 때 주로 사용. 제대로 초기화되지 않은 객체를 사용하러 할때.<BR/>
인수 값이 무엇이었든 어차피 실패했을 때.<BR/>
NullPointerException : null 값을 허용하지 않는 메서드에 null을 건낼 때.<BR/>
IndexOutOfBoundsException : 시퀀스의 허용 범위를 넘는 값을 건낼 때.<BR/>
ConcurrentModificationException : 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때. 알려주는 정도의 역할.<BR/>
UnsupportedOperationException : 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때.<BR/>


Exception, RuntimException, Throwable, Error는 직접 재사용하지 말자.<BR/>
여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.<BR/>


<h2>아이템 73. 추상화 수준에 맞는 예외를 던지라</h2>

수행하려는 일과 관련 어 보이는 예외가 튀어나오면 당황스러울 것이다.<BR/>
메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다.<BR/>
내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.<BR/>

<h3>예외 번역(exceptin translation)</h3>
상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 

```
// 예외 번역
try {
    ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);    
}
```

<h3>예외 연쇄(exception chanining)</h3>
예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.<BR/>
별도의 접근자 메서드를 통해 필요하면 언제든 저수준 예외를 꺼내볼 수 있다.<BR/>

```
// 예외 번역
try {
    ... // 저수준 추상화를 이용
} catch (LowerLevelException cause) {
    //저수준 예외를 고수준 예외에 실어 보낸다. 
    throw new HigherLevelException(cause);    
}

// 예외 연쇄용 생성자
class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있다. <BR/>
그렇지 않은 예외라도 Throwable의 initCause 메서드를 이용해 '원인'을 직접 못박을 수 있다. <BR/>
고수준 예외의 생성자는 (예외 연쇄용으로 설계된) 상위 클래스의 생성자에 '원인'을 건네주어, 최종적으로 Throwable(Throwable) 생성자까지 건네지게한다.<BR/>



