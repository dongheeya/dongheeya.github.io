<h1>6장. 스프링 클라우드와 주울로 서비스 라우팅</h1>
<ul>
  <li>6.1 서비스 게이트웨이란?</li>
  <li>6.2 스프링 클라우드와 넷플릭스 주울 소개</li>
  <li>6.3 주울에서 경로 구성</li>
  <li>6.4 주울의 진정한 힘! 필터</li>
  <li>6.5 상관관계 ID를 생성하는 주울의 사전 필터 작성</li>
  <li>6.6 상관관계 ID를 잔덜받는 사후 필터 작성</li>
  <li>6.7 동적 경로 필터 작성</li>
  <li>6.8 요약</li>
</ul>


<H3>서비스 게이트웨이 배경</H3>
마이크로서비스 같은 분산형 아키텍처에서는 여러 서비스 호출 사이에서 발생하는 보안과 로깅, 사용자 추적 등 주요 행위를 확인하는 시점이 필요.<BR/>
그 기능을 구현할 때 공통적인 프레임워크나 라이브러리를 사용해서 서비스마다 도입해야한다.<BR/>

그래서 서비스 게이트웨이는 서비스 클라이언트가 서비스를 직접 호출하지 않고 단일한 정책 시행 시점 역할을 하는 서비스 게이트웨이로 모든 호풀을 경유시켜 최종 목적지로 라우팅이 필요.<BR/>

주울은 넷플릭스의 오픈 소스 서비스 게이트웨이를 구현한 것이다.<BR/>

<H2>6.1 서비스 게이트웨이란?</H2>

![6-1](https://user-images.githubusercontent.com/87962572/153710163-ddff27b9-fcbd-4667-ba72-008e7fb739ea.PNG)

지금까지는 웹 클라이언트 개별 서비스를 직접 호출하거나 유레카 같은 서비스 디스커버리 엔진을 이용해 프로그램 방식으로 호출하였다.<BR/>

서비스 게이트웨이는 서비스 클라이언트와 호출될 서비스 사이에서 중개 역할을 한다.<BR/>
서비스 클라이언트는 서비스 게이트웨이가 관리하는 하나의 URL을 통해 통신한다.<BR/>
서비스 클라이언트 호출에서 보낸 경로를 추려 내고 서비스 클라이언트가 호출하려는 서비스를 판별한다.<BR/>

따라서 마이크로서비스 호출로 유입되는 모든 트래픽에 대해서 게이트키퍼 역할을 한다.<BR/>
서비스 게이트웨이가 구축되면 서비스 클라이언트는 개별 서비스의 URL를 직접 호출하지 않고 서비스 게이트웨이로 모든 호출을 보낸다.<BR/>

![6-2](https://user-images.githubusercontent.com/87962572/153710278-0a54e1dc-04d6-429e-a916-56bc52d3a394.PNG)

<H3>서비스 게이트웨이에서 구현할수 있는 횡단 관심사</H3>
  - 정적 라우팅 : 서비스 게이트웨이는 단일 서비스 URL과 API 경로로 모든 서비스를 호출하게 된다.<BR/>
  - 동적 라우팅 : 서비스 게이트웨이가 서비스 요청을 주사하고 데이터 기반으로 기능형 라우팅을 수행한다.<BR/>
  - 인증과 인가 : 모든 서비스 호출은 서비스 게이트웨이로 호출되므로 서비스 호출자가 자신을 인증하고 서비스를 호출한 권한 여부를 확인할 수 있다.<BR/>
  - 측정 지표 수집과 로깅 : 서비스 호출이 서비스 게이트웨이로 통과할 떄 측정 지표와 로그 정보를 수집할 수 있는 장소가 된다. (서비스 호출 횟수, 응답시간 등)<BR/>

<H2>6.2 스프링 클라우드와 넷플릭스 주울 소개</H2>
주울(Zuul)은 스프링 클라우드 애너테이션으로 설정하고, 사용하기 쉬운 서비스 게이트웨이다.<BR/>
- 애플리케이션의 모든 경로를 단일 URL로 매핑 (모든것을 그렇게 처리해야만하는 것은 아님)<BR/>
- 게이트웨이로 유입되는 요청을 검사하고 대응할 수 있는 필터 작성 <BR/>

<H3>6.2.1 주울 스프링 부트 프로젝트 설정</H3>
pom.xml에 추가

```
<dependency>
 <groupId>org.springframework.cloud</groupId>
 <artifactId>spring-cloud-starter-zuul</artifactId>
</dependency>
```

<h3>6.2.2 주울 서비스를 위한 스프링 클라우드 애너테이션</h3>
메이븐 의존성을 추가한 후 부트 스트랩 클래스에서 주울 서비스를 위한 애너테이션이 추가되어야 한다.

@EnableZuulProxy 추가

```
package com.thoughtmechanix.zuulsvr;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableZuulProxy                 -- 서비스를 주울 서버로 사용한다.
public class ZuulServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ZuulServerApplication.class, args);
  }
}
```

<h3>6.2.3 유레카와 통신하는 주울 구성</h3>
마지막으로 주울 서버의 application.yml을 수정해 유레카 서버를 가리키도록 하는 것이다.

```
eureka:
 instance:
  preferIpAddress: true
 client:
  registerWithEureka: true
  fetchRegistry: true
  serviceUrl:
    defaultZone: http://localhost:8761/eureka/
```

<h2>6.3 주울에서 경로 구성</h2>

주울은 리버스 프록시다.<BR/>
- 리버스 프록시 : 자원에 접근하려는 클라이언트와 자원 사이에 위치한 중개 서버다.<BR/>
- 클라이언트는 프록시가 아닌 다른 서버와 통신하는 것조차 알 수 없고, 리버스 프록시는 클라이언트의 요청을 받은 후 클라이언트를 대신해 원격 자원을 호출한다.<BR/>

주을이 하위 클라이언트와 통신하려면 유입되는 호출을 어떻게 하위 경로로 매핑할지 알아야 한다.<BR/>
- 서비스 디스커버리를 이용한 자동 경로 매핑<BR/>
- 서비스 디스커버리를 이용한 수동 경로 매핑<BR/>
- 정적 URL을 이용한 수동 경로 매핑<BR/>

<H3>6.3.1 서비스 디스커버리를 이용한 자동 경로 매핑</H3>

주을은 zuulsvr/src/main/resources/application.yml 경로를 정의해서 모든 경로를 매핑한다.
특별한 구성 없이도 서비스 ID를 기반으로 요청을 자동 라우팅할 수 있다.

EX) organizationservice를 호출하고 주울로 자동화된 라우팅을 사용하고자 한다면, 클라이언트가 다음 URL 엔드포인트로 주울 서비스 인스턴스를 호출하면 된다.

```
// 서비스 엔드포인트 경로 첫 부분에 호출하려는 서비스인 organizationservice를 표시
http://localhost:5555/organizationservice/v1/organizations/e254f8c-c442-4ebea82a-e2fc1d1ff78a
```

![6-3](https://user-images.githubusercontent.com/87962572/153710723-566420ed-1bdb-4b24-884d-4135b0580afe.PNG)

유레카와 주을을 함께 사용하면 호출할 수 있는 단일 엔드포인트를 제공할 뿐만 아니라 주울 수정 없이도 인스턴스를 추가하고 제거할 수 있다.<BR/>
예를 들어 유레카에 새로운 서비스를 추가하면 주울은 자동으로 이 서비스 인스턴스에 라우팅하는데, 서비스 엔드포인트의 실제 물리적 위치를 유레카와 소통하고 있어 가능하다.<BR/>

주울 서버가 관리하는 경로를 보고 싶다면 주울 서버에 /routes 엔드포인트로 경로에 접근할 수 있다.<BR/>

```
http://localhost:5555/actuator/routes
```

![6-4](https://user-images.githubusercontent.com/87962572/153711757-47c96893-8a72-4b71-8dec-d07cfde4a1ab.PNG)

왼쪽에는 유레카 기반으로 자동으로 생성된 주울에 등록된 서비스 경로 / 오른쪽에는 경로에 매핑된 실제 유레카 서비스 ID 이다.<BR/>

<H3>6.3.2 서비스 디스커버리를 이용한 수동 경로 매핑</H3>
주울을 이용하면 명시적으로 매핑 경로를 정의할 수 있다.<BR/>

EX) 조직 서비스의 기본 경로인 /organizationservice/v1/organizations/{organization-id} 경로를 단순화하고 싶다면?<BR/>
 -> /organization/v1/organizations/{organization-id}<BR/>
 

```
// application.yml 수정 
zuul:
 ignored-service : 'organizationservice' <- 자동 생성한 유레카 서비스 ID 경로를 제외해겠다! (만약에 모든 서비스를 제외하고 싶다면 '*' 로 명시 필요)
 routes:
  organizationservice: /organization/**
```

![6-5](https://user-images.githubusercontent.com/87962572/153711886-05ff7dea-7e7f-4e14-a66c-e420015f4da6.PNG)

서비스 게이트 웨이의 일반적인 패턴은 모든 서비스 호출 안에  /api를 레이블을 붙여서 API와 콘텐츠 경로를 구별한다.

![6-7](https://user-images.githubusercontent.com/87962572/153711960-15d4c3dd-121a-404f-b5d4-74258ac685d8.PNG)

```
zuul:
 ignored-services: '*' 
 prefix: /api  -- 정의한 모든 서비스에 /api 접두어가 경로에 붙는다.
 routes:
  organizationservice: /organization/** 
```

![6-6](https://user-images.githubusercontent.com/87962572/153711999-db71e544-153f-4925-a30d-ba4d583fbb4b.PNG)


<h3>6.3.3 정적 URL을 이용한 수동 경로 매핑</H3>

유레카로 관리하지 않는 서비스를 라우팅하는 데 주울을 사용할 수 있다.<BR/>
주울은 고정 URL에 직접 라우팅하도록 설정할 수 있다.<BR/>

EX) 라이선싱 서비스가 파이썬으로 작성되었고 주울로 프록시한다고 가정.<BR/>

```
zuul:
 routes:
 licensestatic: 
   path: /licensestatic/**    -- 라이선싱 서비스에 대한 정적 경로
   url: http://licenseservice-static:8081   -- 유레카를 통하지 않고 직접 호출할 라이선싱 서비스의 정적 인스턴스를 설정한다.
```

만약에 리본을 유레카와 통합하지 않고 전송할 경로가 여러개라면, 부하 분산할 대상을 주울에 설정할 수 있다.

```
zuul:
 routes:
 licensestatic: 
   path: /licensestatic/** 
   serviceId: licensestatic 
ribbon:
 eureka:
   enabled: false  -- 리본에서 유레카 지원을 끈다.
licensestatic:
 ribbon:
  listOfServers: http://licenseservice-static1:8081, http://licenseservice-static2:8082  -- 요청을 라우팅하는 데 사용한 서비 목록이다.
```

<h3>6.3.4 경로 구성을 동적으로 로딩 </h3>
주울 서버를 재활용하지 않고도 경로 매핑을 변경할 때 사용하면 좋고, <BR/>
기존 경로를 신속하게 수정하고 새로운 경로를 추가하면 환경 내 각 주울 서버를 재활용해야 한다.<BR/>

<h3>주을과 서비스 타임아웃</h3>

주을은 넷플릭스의 히스트릭스와 리본 라이브러리를 사용해 오래 수행되는 서비스 호출이 서비스 게이트웨이의 성능에 영향을 미치자 않도록 한다.<BR/>
기본적으로 주울을 요청을 처리하는데 1초 이상 걸린다면, 모든 호출을 종료하고 HTTP 500 에러를 반환한다.<BR/>


```
zuul.prefix: /api
zuul.routes.organizationservice: /organization/**
zuul.routes.licensingservice: /licensing/**
zuul.debug.request: true
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 2500 -- 히스트릭스 타임아웃을 1 -> 2.5초로 변경
```

예를들어 특정 서비스만 타임아웃 시간을 변경하고 싶다면, 구성파일에서 다음과 같이 변경한다.

```
hystrix.command.licensingservice.execution.isolation.thread.timeoutInMilliseconds: 3000
```

<h2>6.4 주울의 진정한 힘! 필터</h2>
주울의 진정한 능력은 게이트웨이를 통과하는 모든 서비스 호출에 대해 사용자 정의 로직을 작성할 때 드러난다.<BR/>
사용자 정의 로직 대부분은 모든 서비스에 대한 보안과 로깅 및 추적처럼 일관된 애플리케이션 정책을 시행하는 데 사용된다.<BR/>

주울에서는 주울 게이트웨이 안에 필터로 사용자 정의 로직을 만들 수 있다.<BR/>

<h3>주울의 필터 종류</h3>
- 사전 필터 : 주울에서 목표 대상에 대한 실제 요청일 발생하기 전에 호출된다. (사용자의 인증, 인가(수행 권한 부여) 확인 및 서비스의 일관된 메세지 형식 확인)<BR/>
- 사후 필터 : 응답을 클라이언트로 전송한 후 호출된다. (서비스의 응답을 로깅, 예외 처리, 민감한 정보에 대한 응답 감시)<BR/>
- 경로 필터 : 대상 서비스가 호출되기 전에 호출을 가로채는 데 사용 (ex. 사용자별 새로운 기능 노출시에 사용가능)<BR/>

![6-11](https://user-images.githubusercontent.com/87962572/153712756-1b41c56e-67cf-4dc5-8d1e-81cabd6e74d2.PNG)

1. 사전 필터는 요청이 주울 게이트웨이에 유입되면 호출된다. HTTP 요청이 실제 서비스에 도달하기 전에 요청을 검사하고 수정한다.<BR/>
2. 주울은 유입된 요청에 대해 사전 필터를 실행한 후 정해진 경로 필터로 실행한다.<BR/>
3. 경로 필터는 주울 서버가 전송하도록 구성된 경로가 아닌 다른 경로로 서비스 호출 리다이렉션을 하는 것도 가능하다.<BR/>
4. 경로 필터가 호출자를 새로운 경로로 동적 라다이렉션하지 않는다면 주울 서버는 원래 대상 서비스의 경로로 보낸다.<BR/>
5. 대상 서비스가 호출되었다면 주울의 사후 필터가 호출된다.<BR/>

EX) EagleEye 서비스 요청 처리하는데 어떻게 작용하는 지 보여준다.

![6-12](https://user-images.githubusercontent.com/87962572/153712868-f786162d-12f8-4929-b36d-257d9960ba76.PNG)

1. TrackingFilter : 유입되는 모든 요청을 검사하고 http 헤더에 상관관계 ID가 없다면 생성한다.<BR/>
  - 상관관계 ID를 사용하면 특정 호출이 일련의 마이크로서비스를 통과할 때 발생하는 모든 이벤트 체인을 추적할 수 있다.<BR/>
2. SpecialRouterFilter : 특정 경로의 비율 일부를 다른 서비스로 전송할 지 여부를 결정한다.<BR/>
  - 유입된 경로를 확인하고 해당 경로에서 A/B 테스팅 수행여부를 결정한다.<BR/>
  - A/B는 동일한 서비스 기반을 둔 다른 두 버전의 서비스를 무작위로 제시할 수 있다.<BR/>
  - 이로 인해, 새로운 기능을 출시하기 전에 테스할 수 있다.<BR/>
4. ResponseFilter : 서비스호출과 연관된 상관관계 ID를 클라이언트로 회신하는 HTTP 응답 헤더에 삽입하는 사후 필터이다. <BR/>
 이것으로 클라이언트는 호출한 요청과 연관된 상관관계 ID에 엑세스할 수 있다.<BR/>
 
