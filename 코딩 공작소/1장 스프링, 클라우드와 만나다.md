<h1>1장 스프링, 클라우드와 만나다</h1>

<ol>
<li>1.1 마이크로서비스란?</li>
<li>1.2 스프링은 무엇이고 마이크로 서빗와 어떤 관련이 있을까?</li>
<li>1.3 책에서 다루는 내용</li>
<li>1.4 대상 독자</li>
<li>1.5 스프링 부트로 마이스로서비스 구축</li>
<li>1.6 애플리케이션 구축 방식을 바꾸는 이유</li>
<li>1.7 클라우드란 정확히 무엇인가?</li>
<li>1.8 왜 클라우드와 마이크로서비스인가</li>
<li>1.9 마이크로서비스는 코드 작성 이상을 의미</li>
<li>1.10 스프링 클라우드로 마이크로서비스 구축</li>
<li>1.11 예제로 배우는 스프링 클라우드</li>
<li>1.12 예제와 관련성 확인</li>
</ol>

<h2>마이크로서비스란?</h2>
마이크로서비스 개념이 발전하기 전, 대부분의 웹 기반 애플리케이션은 모놀리식 아키텍처 형태로 개발되었다.

< 모놀리식 아케텍처의 특징 > <br/>
1. 모놀리식 아키텍처에서 애플리케이션은 "배포 가능한 단일 소프트웨어 산출물"로 전달되었다.<br/>
2. UI 및 비즈니스 로직, 데이터베이스 엑세스 로직 모두가 "하나의 애플리케이션 산출물"로 패키징되고 애플리케이션 서버에 배포되는 것이다.<br/>
3. 애플리케이션은 단일 작업 단위로 배포할 수 있지만, 실제로는 여러 개발 팀이 한 애플리케이션에서 작업할 때가 더 많다.<br/>
4. 일반적으로 각 개발 팀은 특정 고객에서 제공하는 애플리케이션의 개발 기능을 담당한다.<br/>
5. 단점은 모놀리식 애플리케이션이 크고 복잡해지면 애플리케이션을 담당하는 각 팀의 의사소통과 조정 비용이 증가하는데, 이 비용을 고려하지 못했다는 것이다.<br/>
따라서, 변경시마다 애플리케이션을 전체 다시 빌드하고 테스트해서 배포해야한다.<br/>

![1-1](https://user-images.githubusercontent.com/87962572/145671593-e68d9f3d-28c6-43c9-bad6-360a38a9c369.PNG)

< 마이크로서비스 개념 >
1. 느슨한 결합된 작은 분산 서비스<br/>
2. 대형 애플리케이션의 관리 용이 제한된 책임을 담당하는 컴포넌트로 분해할 수 있다.<br/>
3. 마이크로서비스는 코드 베이스를 명확히 정의한 작은 조각으로 분리해서 대형 코드 베이스에서 발생하는 전통적인 복잡성 문제를 해결한다.<br/>
4. 애플리케이션의 기능을 완전히 분리해서 완전히 상호 독립적이어야 한다.<br/>

![1-2](https://user-images.githubusercontent.com/87962572/145671690-5e7152c4-035b-4adb-84c5-cc2ad93d910e.PNG)

그림에서 보여주듯이 각 팀의 서비스 코드와 서비스 인프라스트럭처를 완전히 소유하고 있음을 알 수 있다.<br/>
각 팀은 독립적으로 빌드, 테스트, 배포를 할 수 있다.<br/>

< 마이크로서비스 특징 >
- 애플리케이션 로직을 각자 책임이 명확한 작은 컴포넌트로 분해하고 이들을 조합해서 솔루션을 제공한다.<br/>
- 각 컴포넌트는 작은 책임 영역을 담당하고 완전히 상호 독립적으로 배포한다.<br/>
- 여러 애플리케이션에서 재사용할 수 있어야 한다.<br/>
- 서비스 소비자와 서비스 제공자 사이의 데이터 교환을 위해 HTTP와 JSON같은 경량 통신 프로토콜을 사용한다.<br/>
- 다양한 언어와 기술로 구축할 수 있다.<br/>
- 작고 독립적이며 분산된 마이크로서비스를 사용해 조직은 명확히 정의된 책임 영역을 담당하는 소규모 팀을 보유할 수 있다.<br/>
- 따라서 자기가 개발한 서비스만 책임질 수 있으며 서비스 인트턴스를 쉽게 시작할 수 있고 확장성을 높일 수 있다.<br/>


<h2>1.2 스프링은 무엇이고 마이크로 서빗와 어떤 관련이 있을까?</h2>

스프링은 자바 기반 애플리케이션을 구축하는 사실상 표준 개발 프레임워크가 되었다.
스프링은 의존성 주입이라는 핵심 개념에 기반을 둔다.
따라서 애플리케이션 안에서 관련 있는 객체가 서로 상대에 관한 정보를 하드 코딩하지 않고, 관례와 애너테이션으로 객체 간 관계를 외부화할 수 있으므로 대규모 자바 프로젝트를 
더 쉽게 관리할 수 있다.

스프링 부트는 스프링 프레임워크를 재구성한 것이다. 스프링의 핵심 기능은 수용하지만 많은 '엔터프라이즈'기능을 제거하고 그 대신 자바 기반의 REST지향 마이크로서비스 프레임워크를 
제공한다. 단순한 애너테이션으로 자바 개발자는 외부 애플리케이션 컨테이너 없이도 패키지하고 배포할 수 있는 REST 마이크로서비스를 신속하게 구축할 수 있다.

스프링 클라우드 프레임워크를 사용하면 사설(private) 및 공용(public) 클라우드에 마이크로서비스를 쉽게 운영하고 배포할 수 있다.
스프링 클라우드는 널리 사용되는 클라우드 관리용 마이크로서비스 프레임워크를 공통 프레임워크에 포함하고, 코드에서 애너테이션을 다는 것처럼 이러한 기술을 쉽게 사용하고 배포할 수
있게 한다.


<h2>1.5 스프링 부트로 마이크로서비스 구축</h2>

![1-3](https://user-images.githubusercontent.com/87962572/145672136-d7f13974-cfbf-408d-9490-f8232b92f7d5.PNG)

```
package com.thoughtmechanix.simpleservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.PathVariable;

@SpringBootApplication            // 스프링 부트 프레임워크에 이 클레스가 스프링 부트 서비스의 진입점이라고 지정한다.
@RestController                   // 스프링 부트에 이 클래스의 코드를 스프링 RestController 클래스로 노출하도록 지정한다.
@RequestMapping(value="hello")    // 이 애플리케이션에서 노출된 URL은 /hello가 앞에 붙는다.
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @RequestMapping(value="/{firstName}/{lastName}" // 스프링 부트는 두 매개변수인 firstName과 lastName을 입력받는 
                                                  ,method = RequestMethod.GET)   //GET기반의 REST 앤드포인트로 노출한다.
    public String hello( @PathVariable("firstName") String firstName,       // URL에 전달된 firstName과 lastName 매개변수를 hello 하수에 전달하는 두 변수에 매핑한다.
                         @PathVariable("lastName") String lastName) {

        return String.format("{\"message\":\"Hello %s %s\"}", firstName, lastName);    // 직접 간단한 JSON 문자열을 만들어 반환한다.
    }
}

```


<h2>1.6 애플리케이션 구축 방식을 바꾸는 이유</h2>
배경 : 자국 시장에서 서비스하던 기업들은 글로벌 고객 기반을 확보할 수 있다는 사실을 꺠닫고 있다. 그래서 글로벌 고객들까지 고객층이 확대되면서 경쟁도 치열해진다. <br/>
1. 복잡성의 증가 : 고객은 조직의 모든 부분이 자신을 인식하기를 기대한다. 단 하나의 데이터베이스와 통신하고 다른 애플리케이션과 통합하지 않는 단절된 애플리케이션은 더 이상 표준이
아니다. 오늘날 애플리케이션은 회사 데이터센터 내부의 여러 서비스와 데이터베이스뿐만 아니라 인터넷으로 외부 서비스 제공자와도 통신해야 한다.<br/>
2. 고객은 더 빠른 출시일을 원한다. : 고객은 더 이상 SW 패키지를 연 단위로 릴리스하거나 버전을 올리기를 기대하지 않는다. 기다리지 않고 새로운 기능이 몇 주나 며칠 안에
릴리스되길 기대한다.<br/>
3. 성능 및 확장성 : 글로벌 애플리케이션에서는 애플리케이션이 처리해야 할 트랜잭션 양과 유입될 시점을 매우 예측하기 어렵다. 애플리케이션은 여러 서버로 신속하게 확장한 후 확장이
필요하지 않게 된다면 다시 축소해야 한다.<br/>
4. 고객은 애플리케이션을 항상 사용할 수 있기를 기대한다. : 고객은 한 번의 클릭만으로 경쟁사로 이탈할 수 있으르모 회사의 애플리케이션은 회복성이 높아야 한다. 애플리케이션의 
한 부분에서 에러나 문제가 있어도 애플리케이션 전체가 다운되서는 안된다.<br/>

구축방식을 바꾸게 되면 얻을 수 있는 특징<br/>
1. 유연성 : 새로운 기능을 신석하게 제공하도록 분리된 서비스를 구성하고 재배치할 수 있다. 테스트하는 시간도 줄일 수 있다.<br/>
2. 회복성 : 분리된 서비스란 더 이상 애플리케이션 한 부분의 저하로 전체가 망가지는 진흙덩이 애플리케이션이 아니라는 의미다. 실패는 작은 부분에 국한되어 전체 장애로 확대되기 전에 
억제된다.<br/>
3. 확장성 : 분리된 서비스를 여러 서버에 수평적으로 쉽게 분산할 수 있어 기능 및 서비스를 적절히 확장할 수 있다.<br/>

<h2>클라우드란 정확히 무엇인가?</h2>
클라우드의 기본 3가지 모델<br/>
- Iaas(Infrastructure as a Service) : 클라우드 공급자는 기본적인 인프라스트럭처를 제공하지만 기술 선택과 최종 솔루션 구측은 개발자의 몫<br/>
- PasS(Platform as a Service) : 핵심 업무는 공급자에게 의존<br/>
- SaaS(Software as a Service) : 공급자가 제공하는 서비스의 수동적 소비자이며 기술 선택이나 애플리케이션을 위한 인프라이스트럭처를 유지 보수할 책임이 없다.<br/>

<h2>왜 클라우드와 마이크로서비스인가?</h2>

마이크로서비스를 작성한 개발자는 서비스를 다음 중 어디에 배포할 지 결정해야 할 것이다. <br/>
- 물리적 서버 : 물리적 머신에 마이크로서비스를 빌드하고 배포할 수 있지만 물리적 서버는 제한이 있어 이를 사용하는 조직이 거의 없다. 물리적 서버는 빠르게 용량을 늘릴 수 없고,
여러 물리적 서버로 마이크로서비스를 수평 확장하는 데 상당한 비용이 든다.<br/>
- 가상 머신 이미지 : 마이크로서비스의 주요 이점 중 하나는 확장하고 실패 이벤트를 받을 때 신속하게 마이크로서비스 인스턴스를 시작하고 종료할 수 있다는 것이다. 가상 머신은 주요 
클라우드 공급자의 마음이자 정신이다/ 마이크로서비스를 가상 머신 이미지에 패키징한 후 서비스의 여러 인스턴스를 신속하게 IaaS 형 사설 및 공용 클라우드에 배포하고 시작할 수 있다.
- 가상 컨테이너 : 가상 컨테이너는 가상 머신 이미지 기반의 마이크로서비스 배포를 자연스럽게 확장한 것이다/ 서비스를 완전한 가상 머신에 배포하는 대신 많은 개발자가 도커 컨테이너로 
자기 서비스를 클라우드에 배포한다. 가상 컨테이너는 가상 머신 안에서 실행된다. 가상 컨테이너를 사용하면 하나의 가상 머신을 같은 가상 머신 이미지를 공유하는 완전 자립형 프로세스로 
분리할 수 있다.

클라우드에 기반을 둔 마이크로서비스의 장점은 탄력성 개념을 중신으로 한다.
클라우드 서비스 공급자를 통해 몇 분 안에 새로운 가상 머신과 컨테이너틀 빠르게 가동시킬 수 있다.
서비스 용량이 감소한다면 추가 비용을 드리지 않고도 가상 서버를 줄일 수 있다.
클라우드 공급자를 사용해 마이크로서비스를 배포하면 애플리케이션을 위해 훨씬 더 높은 수준의 수평 확장성을 얻는다.
서버 탄력성은 애플리케이션 또한 회복력이 높다는 것을 의미한다.

마이크로서비스에서 사용되는 일반적인 배포 토폴로지(topology)이다.

- 간소화된 인프라스트럭처 관리 : IaaS 클라우드 공급자는 서비스를 최대한 통제할 수 있는 역략을 제공한다.  <br/>
간단한 API 호출로 새로운 서비스를 시작하고 정지할 수 있다. IaaS 클라우드 솔루션은 사용한 인프라 비용만 지불하면 된다.<br/>
- 엄청난 수평 확장성 : IaaS 클라우드 공급자를 사용하면 하나 이상의 서비스 인스턴스를 신속하고 간결하게 시작할 수 있다. 이 기능을 이용해 서비스를 재빨리 확장하고 오작동하거나 고장 난
서버를 우회할 수 있다.
- 지리적 분산을 이용한 높은 중복성 : IaaS 공급자를 필요에 따라 다수의 데이터센터를 보유한다. IaaS 클라우드 공급자가 마이크로서비스를 배포하면 데이터센터의 클러스터보다 더 높은
수준의 중복성을 얻을 수 있다.

<h2>1.9 마이크로서비스는 코드 작성 이상을 의미</h2>

![1-7](https://user-images.githubusercontent.com/87962572/145708316-969e8af1-ea21-4301-837e-0efd687d08a1.PNG)
- 적정 크기 : 마이크로서비스가 과도한 책임을 맡지 않도록 어떻게 적절한 크기로 만들 수 있을까? 한 가지 책임 영역에 집중하게 하는 방법은 무엇인가?
- 위치 투명성 : 서비스 클라이언트에 영향을 주지 않고 서비스 인스턴스를 추가/삭제할 수 있도록 물리적 위치를 어떻게 관리하는가?
- 회복성 : 서비스에 문제가 생겼을 때 서비스 클라이언트가 '빨리 실패'하게하는 방법은 무엇인가? 어떻게 마이크로서비스 소비자를 보호하고 애플리케이션의 전반적 무결성을 유지할 것인가?
- 반복성 : 새로운 서비스 인스턴스가 시작할 떄마다 운영 환경의 다른 서비스 인스턴스 구성과 코드 베이스를 동일하게 만드는 방법은 무엇인가?
- 확장성 : 서비스 간 의존성을 최소화하면서 애플리케이션이 신혹히 확장할 수 있는 방법은 무엇인가?

< 마이스코서비스 패턴 >
- 핵심 개발 패턴
- 라우팅 패터
- 클라이언트 회복성 패턴
- 보안 패턴
- 로깅 및 추적 패턴
- 빌드 및 배포 패턴

<h2>마이크로서비스 핵심 개발 패턴</h2>
마이크로서비스 핵심 개발 패턴은 마이크로서비스 구축에 대한 기본 사항을 다룬다.

![1-8](https://user-images.githubusercontent.com/87962572/145712696-3732717c-f2a4-429f-b151-b7e0bd4fa60e.PNG)

서비스 세분성 : 서비스가 담당해야 할 적정한 책임 수준은 얼마인가?
통신 프로토콜 : 클라이언트와 서비스가 데이터를 교환하는 방법
인터페이스 설계 : 서비스 엔드포인트를 클라이언트에 공개하는 방법
구상 관리 : 서비스가 애플리케이션별 구성을 관리해 코드와 구성이 독립적인 개체가 되는 방법
이벤트 프로세싱 : 이벤트를 사용해 서비스 간 상태 및 데이터 변경 사항을 통신하는 방법

<h2>마이크로서비스 라우팅 패턴</h2>
망크로서비스 라우팅 패턴 : 마이크로서비스를 사용하려는 클라이언트 애플리케이션 서비스의 위치를 발견하고 라우팅하는 방법이다.
클라우드 기반 애플맄이션에는 수백 개의 마이크로서비스 인스턴스가 실행 중일 수 있다.
서비스의 물리적 IP 주소를 추상화하고 서비스 호출에 대한 단일 진입점을 만들어야 모든 서비스 호출에 대한 일관된 보안과 콘텐츠 정책을 보장할 수 있다.

![1-9](https://user-images.githubusercontent.com/87962572/145712862-ff0816fd-5ccf-4a5b-b3a0-99546c24d1f6.PNG)

서비스 라우팅 : 마이크로서비스 클라이언트에 인가 및 인증 콘텐츠 검사 등 저액 시행 지점으로 사용되고 연결되는 논리적 단일 URL을 제공한다.
서비스 디스커버리 : 클라이언트에서 서비스의 물리적 위치를 추상화한다. 확장하기 위해 새 마이크로서비스 인스턴스가 추가되고 비정상 서비스 인스턴스는
투명하게 서비스에서 제거된다.

<h2>마이크로서비스 클라이언트 회복성 패턴</h2>

![1-10](https://user-images.githubusercontent.com/87962572/145712918-b8984ed9-0fb3-4f10-bca2-b6479de9543e.PNG)

- 클라이언트 측 부하 연산 : 서비스 디스커버리에서 검색한 마이크로 서비스 앤드인트를 캐시하고 인스턴스 간 서비스의 호출 부하를 분산한다.
- 회로 차단기 : 서비스 클라이언트가 실패한 서비스를 반복적으로 호출하지 않게 된다. 그 대신 클라이언트를 보호하기 위해 차단기가 빨리 실패했다.
- 폴백 : 클라이언트가 실패할 때 데이터를 검색하거나 조치를 취할 수 있는 대체 경로가 있는가?
- 벌크헤드 : 오작동하는 서비스 하나가 클라이언트의 모든 리소스를 차지하지 않도록 클라이언트에서 다른 서비스 호출을 어떻게 격리하는가?

<h2>마이크로서비스 보안 패턴</h2>

![1-11](https://user-images.githubusercontent.com/87962572/145713026-df9bb761-6180-48ff-9802-c8b54ab46d47.PNG)

- 인증 : 서비스를 호출하는 서비스 클라이언트가 자신이라는 것을 어떻게 알 수 있는가?
- 인가 : 마이크로서비스를 호출하는 서비스 클라이언트가 수행하려는 작업을 수행할 자격이 있는지 어떻게 알 수 있는가?
- 자격 증명 관리와 전파 : 서비스 클라이언트가 한 트랜잭션과 관련된 여러 서비스 호출에서 자격 증명을 항상 제시하지 않아도 될 방법은 무엇인가?

보호하려는 서비스다 -> 자원소유자는 인증 서비스를 통해 자원을 엑세스할 수 있는 애플리케이션과 사용자를 그랜트한다.
-> 사용자가 보호 서비스에 엑세스하려면 인증 서비스에서 인증과 토큰을 받아야 한다.
-> 토큰 서버는 사용자를 인증하고 전달된 토큰의 유효성을 검증한다.

<h2>마이크로서비스 로깅 및 추적 패턴</h2>

모놀리식 애플리케이션이 작은 기능 단위로 분해되어 독립적으로 배포된다는 것이다.
마이크로서비스의 단점은 애플리케이션과 서비스 안에서 어떤 일이 일어나고 있는지 디버깅과 추적이 훨씬 더 어렵다는 것이다.

![1-12](https://user-images.githubusercontent.com/87962572/145713375-94837184-4499-4f37-96e7-20b9269a6155.PNG)

로그 상관관계 : 단일 트래잭션과 연관된 로그 항목을 연결하는 상관관계 ID가 모든 서비스 로그 항목에 출력된다.
로그 수집 : 수집 매커니즘은 모든 서비스 인스턴스에서 생성된 로그를 수집한다.
중앙 데이터 저장소 : 수집되는 데이터는 인덱싱되어 검색 가능한 형식으로 저장된다.

<h2>마이크로서비스 빌드 및 배포 패턴</h2>

마이크로서비스 아키텍처의 핵심 부분 중 하나는 마이크로서비스의 각 인스턴스가 모두 동일해야한다는 것이다.
서버가 배포된 이후의 변경 떄문에 발생하는 '구성 편차'는 애플리케이션 안정성을 해치므로 허용될 수 없다.

빌드 프로세스 일부로 마이크로서비스가 실행되는 가상 서버 이미지를 빌듷고 컴파일해야 한다.
그리고 마이크로서비스를 배포할 때 서버가 실행될 머신 이미지를 배포할 수 있다.

![1-13](https://user-images.githubusercontent.com/87962572/145713489-13a9a577-099c-42ad-8e28-3623dcf857c9.PNG)

코드형 인프라스트럭처 : 코드를 작성하고 마이크로서비스에 대한 테스트를 수행하지만 인프라스트럭처를 코드로 취급한다.
마이크로서비스가 컴파일과 패키징되면 마이크로서비스가 설치된 가상 서버 또는 컨테이너의 이미지를 바로 생성하고 프로비저닝한다

불변 서버 : 이미지가 생성되어 배포되는 순간 개발자나 시스템 관리자가 서버를 수정할 수 없다.
환경 간 승격할 때 컨테이너 또는 이미지는 서버가 처음 시작할 떄 전달된 환경별 변수를 사용해 시작한다.

피닉스 서버 : 지속적 통합 프로세스 일부로 실제 서버는 지속적으로 파괴되므로 새로운 서버들을 시작되고 파괴된다. 이 패턴은 환경 간 구성 편차를 크게 감소시킨다.

<h2>스프링 클라우드로 마이크로서비스 구축</h2>

![1-14](https://user-images.githubusercontent.com/87962572/145713662-5bf8c065-30ab-4006-9da0-9bafa8f1879b.PNG)

<h3>스프링 부트</h3>
스프링 부트는 마이크로서비스 구현에 필요한 핵심 기술이다.
스프링 부트에서는 HTTP 형식의 동사(GET 및 PUT, POST, DELETE)를 URL에 매핑하고 JSON 프로토콜을 자바 객체로 직렬화할 뿐만 아니라 자바 예외를 표준 HTTP 에러 코드에 
매핑하는 작업도 아주 간편한다.

<h3>스프링 클라우드 컨피그</h3>
스프링 클라우드 컨피그는 중앙 집중식 서비스로 애플리케이션 구성 데이터 관리를 담당하고 애플리케이션 데이터를 마이크로서비스와 완전히 분리한다.
따라서 마이크로서비스 인스턴스가 아무리 많더라도 항상 동일한 구성을 유지할 수 있다.
- git : 모든 유형의 텍스트 파일에 대한 변경 사항을 관리하고 추적할 수 있는 오픈 소스 버전 제어 시스템이다.
- 콘설 : 콘설은 서비스 인스턴스를 서비스에 등록하 수 있는 오픈 소스 서비스 디스커버리 도구다.
- Eureka : 콘설과 유사한 서비스 디스커버리 기능을 제공하는 넷플릭스의 오픈 소스 프로젝트다.

<h3>스프링 클라우드 서비스 디스커버리</h3>
스프링 클라우드의 서비스 디스커버리를 사용하면 서비스를 사용하는 클라이언트에 서버가 배포된 물리적 위치를 추상화할 수 있다.
서비스 소비자는 물리적 위치보다 논리적 이름을 사용해 서버의 비즈니스 로직을 호출한다.

<h3>스프링 클라우드/넷플리스 히스트릭스와 리본</h3>
넷플릭스 히스트릭스 라이브러리를 사용하면 회로 차단기와 벌크헤드 같은 서비스 클라이언트의 회복성 패턴을 신속하게 구현할 수 있다.
유레카와 같은 서비스 디스커버리 에이전트를 단순하게 통합할 뿐만 아니라 서비스 소비자가 서비스 호출에 대한 클라이언트 측 부하 분산 기능도 제공한다.
이러한 기능을 이용해 서비스 디스커버리 에이전트가 일시적으로 가용하지 않을 때도 클라이언특 계속 서비스를 호출할 수 있다.

<h3>스프링 클라우드/넷플릭스 주울</h3>
스프링 클라우드는 넷플릭스 주울를 사용해 마이크로서비스 애플리케이션을 우한 서비스 라우팅 기능 제공한다.
주울은 서비스 요청을 대리해서 마이크로서비스에 대한 모든 호풀이 현관문처럼 한곳을 통해 대상 서비스에 도달하게하는 서비스 게이트웨이다.
이렇게 서비스 호출을 집중화하면 보안 인가 및 인증, 콘텐츠 필터링, 라우팅 규칙 등 표준 서비스 정책을 시행할 수 있다.

<h3>스프링 클라우드 스트림</h3>
마이크로서비스에 경량 메세지 프로세싱을 쉽게 통합할 수 있는 기술이다.

<h3>스프링 클라우드 슬루스</h3>
스프링 클라우드 슬루스는 애플리케이션 안에서 사용되는 HTTP  호출과 메세지 채녈에 고유 추적되는 식별자를 통합할 수 있다.
여러 서비스를 순회하는 트랜잭션을 추적할 수 있다.
이러한 추적 ID는 마이크로서비스에서 생성하는 모든 로그에 자동적으로 추가된다.

<h3>스프링 클라우드 시큐리티</h3>
서비스에 엑세스할 수 있는 사람과 어떤 일을 할 수 있는지 통제할 수 있는 인증 및 인가 프레임워크다.
토큰에 기반을 두며 인증 서버가 발행한 토큰으로 서비스는 서로 통신한다.
호출받는 서비스 모두 HTTP 호출에서 전달된 토큰을 확인해 사용자 신원과 서비스 접근 권한을 검증한다.

<h3>프로비저닝</h3>
프로비저닝을 구현하기 위해서는 스프링 말고 다른 기술을 사용해야 한다.
스프링 프레임워크는 애플리케이션 개발에 맞추어져 있고 스프링 클라우드처럼 '빌드와 배포' 파이크라인을 생성할 수 있는 도구가 없다.
'빌드와 배포' 파이프라인을 구현하기 위해 2가지 도구, 즉 빌드 도구  Travis CI와 마이크로서비스가 포함된 최종 서버 이미지를 만들기 위해 도커를 사용할 것이다.

<h2>예제로 배우는 스프링 클라우드</h2>

```
package com.thoughtmechanix.simpleservice;

// 간결한 코드를 위해 삭제
import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;

@SpringBootApplication 
@RestController 
@RequestMapping(value="hello") 
@EnableCircuitBreaker      ▶ 1. 서비스가 히스트릭스와 리본 라이브러리를 사용한다.
@EnableEurekaClient        ▶ 2. 유레카의 서비스 디스커버리 에이전트에 서비즈 사진을 등록하고 서비스 디스커버리를 사용해 원격 서비스의 위치를 검색하도록 지정한다.
public class Application {
    public static void main(String[] args) { 
        SpringApplication.run(Application.class, args);
    }
    
    @HystrixCommand(threadPoolKey = "helloThreadPool")  ▶ helloRemoteServiceCall 메서드에 대한 호출을 히스트릭스 회로 차단기로 감싼다.
    public String helloRemoteServiceCall(String firstName, String lastName){
        ResponseEntity<String> restExchange = restTemplate.exchange(
        "http://logical-service-id/name/        ▶ 논리적 서비스 id를 받도록 수정된 RestTemplate클래스를 사용하고 내부적으로 유레카로 서비스의 물리적 위치를 검색한다.
        [ca]{firstName}/{lastName}", 
        HttpMethod.GET,
        null, String.class, firstName, lastName);
        return restExchange.getBody();
    }
    
    @RequestMapping(value="/{firstName}/{lastName}",
    method = RequestMethod.GET)
    public String hello( @PathVariable("firstName") String firstName, 
        @PathVariable("lastName") String lastName) {
            return helloRemoteServiceCall(firstName, lastName)
    }
}
```
1. @EnableCircuitBreaker 스프링 마이크로서비스에 이 애플리케이션에서 넷플릭스 히스트릭스 라이브러리가 사용된다고 알려준다.
2. @EnableEurekaClient 마이크로서비스 자신을 유레카 서비스 디스커버리 에이전트를 등록하고 서비스 디스커버리를 사용해 코드에서 원격 REST서비스의 엔드포인트를 검색할 것을 지정한다.

3. @HystrixCommand 는 helloRemoteServiceCall 메서드가 호출될 때 직접 호출되지 않고 히스트릭스가 관리하는 스레드 풀에 위임한다.
호출에 너무 오래걸리면 (기본값 1초) 히스트릭스가 개입하고 호출을 중단한다. (회로 차단기 패턴의 구현)
히스트릭스가 관리하는 helloThreadPool이라는 스레드 풀을 만드는 것이다. 
helloRemoteServiceCall 메서드에 대한 모든 호출은 이 스레드 풀에서만 발생하며, 수행 중인 다른 원격 서비스 호출과 격리된다.

4. helloRemoteServiceCall 메서드 내부에서는 @EnableEurekaClient 가 있으면 스프링 부트에 REST 서비스를 호출할 때 수정된 RestTemplate 클래스를 사용하도록 지정한다.
이 RestTemplate 클래스로 호출하려는 서비스의 논리적 서비스 ID를 전달할 수 있다.

```
ResponseEntity<String> restExchange = restTemplate.exchange(
        "http://logical-service-id/name/[ca]{firstName}/{lastName}"
```

내부적으로 RestTemplate 클래스는 유레카 서비스에 접속해 1개 이상의 logical-service-id 서비스 인스턴스에 대한 물리적 위치를 검색한다.
서비스 소비자의 코드는 해당 서비스 위치를 전혀 알 필요가 없다.

RestTemplate 클래스는 넷플릭스의 리본 라이브러리에서도 사용한다.
리본은 서비스와 관련된 모든 물리적 엔드포린트 목록을 검색한다.
클라이언트가 서비스를 호풀할 떄마다 중앙 집중식 부하 분산기를 거치지 않고 모든 서비스 인스턴그를 '라운드로빈' 방식으로 호출한다.
중앙 집중식 로드 밸런서를 제거해 클라이언트 측에 옮김으로써 애플리케이션 인프라스트럭처에서 장애점 하나를 제거하는 셈이다.
