<h1>2장 스프링 부트로 마이크로서비스 구축</h1>
<ul>
  <li>2.1 아키텍트의 이야기: 마이크로서비스 아키텍처 설계</li>
  <li>2.2 마이크로서비스를 사용하지 않아야 할 때</li>
  <li>2.3 개발자 이야기: 스프링 부트와 자바로 마이크로서비스 생성</li>
  <li>2.4 데브옵스 이야기: 혹독한 런타임 구축</li>
  <li>2.5 모든 관점에서</li>
</ul>

매머드급 프로젝트는 모든 애플리케이션의 요구 사항과 설계를 프로젝트 초반에 정의할 것을 주장하는 전통적인 대규모 폭포수(waterfall) 개발 방법론을 따르는 경향이 있었다.<br/>
소프트웨어의 모든 명세가 철두철미하길 지나치게 강조한 나머지 새로운 비즈니스 요구 사항을 충족하거나 리팩토링할 여지나 개발 토기 단계에서 저지른 실수에서 배울 여유가 없었다.<br/>

전통적인 폭포수 개발 방법론을 사용하기 어려워진 것은 이들 프로젝트의 소프트웨어 산출물이 가진 세분화 정도에 따라 다음과 같은 단점이 발생할 것이다.<br/>

- 강한 결합(tightly coupled) : 비즈니스 로직 호출은 SOAP나 REST 같은 구현 기술에 중립적인 프로토콜 수준이 아닌 프로그래밍 언어 수준에서 이루어진 것이다. <br/>
따라서 애플리케이션 컴포넌트를 조금만 수정해도 그 애플리케이션의 다른 부분을 꺠뜨리거나 새로운 버그를 생산할 가능성이 매우 높다.<br/>
- 누설(leaky) : 대규모 소프트웨어 애플리케이션의 대부분은 다양한 유형의 데이터를 취급한다. 전통적인 모델에서 데이터는 같은 데이터 저장소 안에서 같은 데이터 모델을 유지한다.<br/>
데이터 사이에 명확한 경계가 있지만 한 영역에 속한 팀이 다른 팀의 데이터에 직접적으로 접근하고 싶은 유혹을 너무 자주 받는다. 그래서 다른 영역의 데이터에 쉽게 접근하게 되면,<br/>
보이지 않는 의존성이 생겨나고 컴포넌트의 내부 데이터 구조에 대한 구현이 애플리케이션 전체에 유출이 될 수 있다. 그리고 테이블 하나를 조금만 변경해도 애플리케이션 전번에 걸처 엄청난<br/>
코드 수정과 회귀 테스팅이 필요할 수 있다.<br/>
- 모놀리식 : 전통적인 애플리케이션에서 대부분의 컴포넌트는 여러 팀에서 공유되는 단일 코드 베이스에 저장하므로 코드를 변경할 때마다 전체 애플리케이션을 재컴파일하고, 전체 테스팅 주기를
재수행하며 재배포한다.애플리케이션 코드 베이스를 조금만 변경해도 비용이 많이 들며 오랜 시간이 소요된다.<br/>

마이크로서비스 기반 아키텍처는 기능을 제공하는 데 위와 다른 접근법을 취한다. 구체적인 특성은 다름와 같다.<br/>
- 제한(constrained) : 마이크로서비스는 하나의 책임 집합을 가지며 범위가 좁다.<br/>
- 느슨한 결합(looselu coupled) : 마이크로서비스 기반 애플리케이션은 작은 버시스 집합이며, HTTP와 REST처럼 비독점적 호출 프로토콜을 사용하는 구현 기술에 중립적인 인터페이스로 서로 소통한다.<br/>
서비스에 대한 인터페이스가 변하지 않는 한 마이크로서비스 소유자는 전통적인 애플리케이션 아키텍처보다 서비스를 더 자유롭게 수정할 수 있다.<br/>
- 추상화(abstract) : 마이크로서비스는 자신의 데이터 구조와 데이터 소스를 완전히 소유한다. 마이크로서비스가 소유한 데이터는 해당 서비스만 수정할 수 있다.<br/>
- 독립적(independent) : 마이크로서비스 애플리케이션 안의 모든 마이크로서비스는 서로 독립적으로 컴파일하고 배포할 수 있다. 모놀리식 애플리케이션보다 변경 사항을 휠씬 쉽게 분리하고 테스트할 수 있는 것을 의미한다.<br/>

클라우드에 기반을 둔 개발에 왜 이러한 마이크로서비스 아키텍처의 일반적인 특징은 다음과 같이 3가지다.<br/>
- 사용자층이 다양하며 대규모다. : 마이크로서비스는 작은 범위를 담당하고, 명확히 정의된 인터페이스를 통해 접근하므로 기능을 신속히 제공할 수 있다.<br/>
- 상당한 작동 시간이 요구된다 : 마이크로서비스 자체의 분산적 특성 떄문에 애플리케이션 전체를 중단하지 않고도 고장과 문제를 더 쉽게 격리할 수 있다.<br/>
- 볼륨이 균일하지 않다 : 독립적인 배포가 가능한 작은 컴포넌트로 분리되어 있기 때문에 부하를 받는 컴포넌트를 조명하고 여러 서버에 수평 확장하기도 휠씬 쉽다.<br/>

<h2>2.1 아키텍처의 이야기 : 마이크로서비스 아키텍처 설계</h2>
마이크로서비스 아키텍처를 구축할 떄 프로젝트의 아키텍트는 다음 3가지 일에 집중한다.<br/>
1. 비즈니스 문제의 분해<br/>
2. 서비스 세분화의 확정<br/>
3. 서비스 인터페이스의 정의<br/>

<h3>비즈니스 문제의 분해</h3>

마이크로서비스 아키텍처에서 아키텍트는 비즈니스 문제를 각 화동 영역에 대표하는 덩이들로 분해하고 비즈니스 영역의 특정 부분과 연관된 비즈니스 규칙과 데이터 로직을 이 덩이들 안에 
캡슐화한다.<br/>

하지만, 항상 실현 가능한 것이 아니다. 한 트랜잭션 전체를 완료하지 위해 비즈니스 영역의 다양한 부분과 동작하는 마이크로서비스가 필요한 상황을 자주 겪는다.<br/>
아키텍트는 데이터 영역이 서로 어울리지 않는다면 마이크로서비스들의 서비스 경계를 나눈다.<br/>

마이크로서비스 후보로 분해하는 데 다음 지침을 사용하기 추천한다.<br/>
1. 비즈니스 문제를 기술하고 그 문제를 기술하는 데 사용한 명사를 주목하라.<br/>
  - 즉, 문제를 기술하는 데 동일한 명사가 반복해서 사용되면 대개 핵심 비즈니스 영역과 마이크로서비스로 만들 기회가 드러난다.<br/>
2. 동사에 주목하라<br/>
  - 동사는 행위를 부각하고 문제가 되는 영역의 윤곽을 자연스럽게 드러낸다.<br/>
3. 데이터 응집성을 찾아라.<br/>
  - 비즈니스 문제를 각 부분으로 분해할 떄 서로 연관성이 높은 데이터 부분들을 찾는다. 마이크로서비스는 자기 데이터를 완전히 소유해야한다. 따라서 대화 중 갑자기 지금껏 논의했던 내용과<br/>
  - 근몬적으로 다른 데이터를 읽거나 업데이트한다면 아마도 또 다른 서비스 후보가 필요할 수 있다.<br/>

먼저 EagleEye는 애플리케이션의 모든 사용자를 인터뷰하고 EagleEye와 상호 작용하고 사용하는 방법을 논의할 것이다.<br/>
사용자가 어떻게 애플리케이션과 상호 작용하고 어떻게 애플리키에시녀의 데이터 모델이 분해되는지 살펴보면서 문제 영역을 다음과 같은 마이크로서비스 후보로 나눌 수 있다.<br/>

비즈니스 사용자의 대화에서 언급된 명사와 동사가 여러 개 강조되었다. EagleEyes는 현재 사용 중인 애플리케이션이므로 애플리케이션을 먼저 살펴보고 주요 명사를 물리적 데이터 모델의 <br/>
데이터를 매핑할 수 있다.<br/> 현재 사용 중인 애플리케이션에 수백 개의 테이블이 존재하더라도 각 테이블은 대개 논리 개체들의 단일 집합으로 매핑된다.<br/>

2-1 EagleEye사용자와 인터뷰하고 일상 업무를 이해한다.
![2-1](https://user-images.githubusercontent.com/87962572/147091871-370f306a-2dd0-443c-b6a7-79085ae8b42c.PNG)

아래는 고객과 나눈 대화를 바탕으로 단순화된 데이터 모델을 보여준다.<br/>
비즈니스 인터뷰와 모델에 기초해 마이크로서비스가 될 후보는 조직, 라이선스, 계약과 자산 서비스다.<br/>

2-2 단순화된 데이터 모델
![2-2](https://user-images.githubusercontent.com/87962572/147092035-0b7e0545-60e0-4b4f-823b-7e3e4c798d6f.PNG)

<h2>서비스 세분화의 확정</h2>
데이터 모델을 단순화했다면 이제 애플리케이션이 필요한 마이크로서비스를 정의할 던계다.<br/>
위에 그림 2-2의 데이터 모델을 근거로 다음 요소들에 기반을 둔 4개의 마이크로서비스를 만들 수 있다.<br/>

목표는 이러한 주요 기능을 가져와 서로 독립적으로 빌드하고 배포할 수 있는 자체 완비형 유닛을 추출하는 것이다.<br/>
데이터 모델에서 서비스를 추출하는 일은 단순히 코드를 여러 프로젝트로 재패키징하는 것보다 더 많이 요구된다. <br/>
서비스가 접근하는 실제 데이터베이스 테이블을 서비스에 따라 정리하는 각 서비스가 특정 도메인의 테이블만 엑세스하게하는 일도 필요하다.<br/>

아래와 같이 관련된 애플리케이션 코드와 데이터 모델을 한곳에 묶어 개별 조각으로 나누는 것을 볼 수 있다.

![2-3](https://user-images.githubusercontent.com/87962572/147094711-d1197012-ce5c-41d7-ae82-e2c5f554d62a.PNG) 
위에 모놀리식 애플리케이션에서 독립적으로 배포가능한 작은 개별 서비스로 분해한다.<br/>
그리고 각 서비스는 자기 영역의 모든 데이터를 소유하고, 모든 서비스가 자기 데이터베이스를 보유한다는 것이 아니라 해당 영역을 소유하는 서비스만 그 영역의 데이터베이스에 엑세스할 수 
있는 의미다.<br/>

이렇게 나뉘어진 마이크로서비스에는 여러가지 특징이 있다. 그리고 그 개념을 사용해 올바르게 해결책을 구할 수 있다.<br/>
1. 큰 마이크로서비스에서 시작해 작게 리팩토링하는 것이 더 낫다. : 문제 여역을 한 번에 작은 서비스들로 분해하는 것은 마이크로서비스가 그저 단순한 데이터 서비스로 전락하기 때문에
너무 일찍 복합함을 겪게 된다.<br/>
2. 서비스 간 교류하는 방식에 먼저 집중한다. : 이는 큰 단위의 인터페이스를 만드는 데 도움이 된다. 큰 것을 작게 리팩토링하는 것이 더 쉽다.<br/>
3. 문제 영역에 대한 이해가 깊어짐에 따라 서비스 책임도 계속 변한다. : 마이크로서비스는 단일 서비스에서 시작해 여러 서비스로 분화되며 성장하는데, 원래 서비스는 <br/>
새로운들을 오케스트레이션하고 애플리케이션의 다른 부분에서 새 서비스들의 기능을 캡슐화한다. <br/>
<br/>
마이크로서비스 아키텍처는 처음부터 올바르게 설계하기가 어렵기 떄문에 진화론적 사고 과정으로 개발해야한다. <br/>
이것이 잘게 나뉜 서비스보다 굵게 나뉜 서비스에서 시작하는 거시 더 좋은 이유다.<br/>

독단적인 설계를 하지 않는 것도 중요하다. 분리된 두 서비스 사이에 너무 많은 호출이 발생하므로 데이터를 합치는 집합 서비스로 별도로 만들거나 서비스 영역의 명확한 겅계선이 없는<br/>
서비스에서 물리적 제약이 발생할 수 있다.<br/>

끝으로 완벽한 설계를 위해 시간을 낭비하고 노력에 비해 보여 줄 것이 없는 것보다는 실용적 접근 방식을 취하고 결과물을 전달하자.<br/>

<h3>서비스 사이의 대화: 서비스 인터페이스</h3>

일반적으로 서비스 인터페이스 설계를 고려할 때 다음 지침을 사용할 수 있다.
1. REST 철학을 수용하라 : 서비스에 대한 REST방식은 서비스의 호출 프로토콜로 HTTP를 수용하고 표준 HTTP 동사(GET, PUT, POST, DELETE)를 사용하는 것이 핵심이다.<br/>
HTTP 동사를 기반으로 기반 행동 양식을 모델링한다.<br/>
2. URI를 사용해 의도를 전달하라 : 서비스의 앤드포인트로 사용되는 URI는 문제 영역에 존재하는 다양한 자원을 기술하고 자원 관계에 대한 기본 매커니즘을 제공해야 한다.<br/>
3. 요청과 응갑에 JSON을 사용하라 : JSON은 초경량 데이터 직렬화 프로토콜이며 XML보다 훨씬 사용하기 쉽다.<br/>
4. HTTP 상태 코드로 결과를 전달하라 : HTTP 프로토콜에는 서비스 성공과 실패를 명시하는 풍부한 표준 응답 코드가 있다. 상태 코드를 익히고 코든 서비스에 일관되게 사용하는 것이 매우 중요하다.<br/>

<h2>2.2 마이크로서비스를 사용하지 않아야 할 때</h2>
언제 마이크로서비스를 사용하면 안 되는가?

```
1. 분산 시스템 구축의 복잡성
2. 가상 서버/컨테이너의 스프롤
3. 애플리케이션 유형
4. 데이터 변환과 일관성
```

<h3>분산 시스템 구축의 복잡성</h3>
마이크로서비스는 잘게 나뉘고 분산되어있어 모놀리식 애플리케이션에서 없던 복잡성을 가져온다.<br/>
마이크로서비스 아키텍처에는 높은 수준의 운영 성숙도 필요하다.<br/>
따라서 고도로 분산된 애플리케이션을 성공시키는 데 필요한 자동화와 운영 작업에 투자할 의사가 없는 조직이라면 마이크로서비스를 고려하지 않는 것이 좋다.<br/>

<h3>서버 스프롤(Server sprawl)</h3>
* 스프롤이란 : IT 업계에서 사용되는 용어로 활용도가 낮은 여러 서버가 실제 작업량보다 더 많은 공간과 리소스를 차지하는 현상을 의미한다.<br/>
마이크로서비스의 가장 일반적인 배포 모델 중 하나는 한 서버에 하나의 마이크로로서비스 인스턴스를 배포하는 것이다.<br/>
대규모 마이크로서비스 기반 애플리케이션의 운영 환경에서만 구축 및 관리가 필요한 서버나 컨데이터가 (일반적으로) 50~100개 있을 수 있다.<br/>
 * 클라우드에서 이들 서비스를 실행하는 데 드는 비용은 저렴하더라도 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡해질 수 있다.<br/>
(마이크로서비스의 유연성은 모든 서버를 운영하는 데 드는 비용과 함께 따져 보아야 한다.)<br/>

<h3>애플리케이션 유형</h3>
마이크로서비스는 재사용을 추구하며 높은 회복성과 확장성이 필요한 대규모 애플리케이션의 구축에 매우 유용하다.<br/>
이 때문에 많은 클라우드 기반 기업에서 마이크로서비스 기반 기업에서 마이크로서비스를 채택한다.<br/>

만약에 소형 애플리케이션이나 소수 사용자를 위한 애플리케이션이라면 마이크로서비스 구축에 따른 복잡성이 분산 구축으로 얻게 될 가치보다 더 클 수 있다.<br/>

<h3>데이터 변환과 일관성</h3>

마이크로서비스를 검토할 떄 서비스의 데이터 사용 패턴과 서비스 소비자가 어떻게 서비스를 사용하는지 고민해야 한다.<br/>
 * 애플리케이션이 여러 데이터 소스에서 복잡한 데이터를 취합하고 변환해야 할 경우 마이크로서비스의 분산된 특성 때문에 작업이 어려워진다.<br/>
마이크로서비스는 변함없이 과도한 책임을 떠안고 성능 문제에서 취약해질 것이다.<br/>

마이크로서비스 사이에 트랜잭션을 처리하는 표준이 없다는 사실도 잊지 말자.<br/>
트랜잭션 관리가 필요하면 직접 만들어야 하고, (7장) 메세지를 사용해 서로 통신할 수 있다.<br/>
 * 메세징에서는 데이터를 업데이트할 때 지연 시간이 발생한다. 따라서 업데이트한 데이터가 즉시 나타나지 않을 수도 있어 애플리케이션은 최종 일관성을 유지해야한다.<br/>


<h2>개발자 이야기: 스프링 부트오 자바로 마이크로서비스 생성</h2>
EagleEye도메인 모델에서 라이선싱 마이크로서비스를 구축할 떄 개발자 우선순위를 살펴보자.<br/>
라이선싱 서비스는 스트링 부트를 사용해 작성한다.<br/>
스프링 부트는 표준 스프링 라이브러리보다 추상화된 레이어로, 개발자가 전통적인 스프링 애플리케이션보다 훨씬 적은 형식과 구성으로 그루비와 자바 기반의 웹 애플리케이션과 마이크로서비스를
신속히 구축하게 된다.<br/>

앞으로 다룰 여러절에서는 다음 단계를 공통적으로 수행할 것이다.<br/>
1. 마이크로서비스의 기본 골격과 메이븐 스크립트를 빌드해 애플리케이션을 빌드한다.<br/>
2. 마이크로서비스용 스프링 컨테이너를 시작할 스프링 부트스트랩 클래스를 구현하고 이 클래스으 초기화 작업을 시작한다.<br/>
3. 서비스의 앤드포인트를 노출하기 위해 앤드포인트를 매핑하는 스프링 부트 컨트롤러클래스를 구현한다.<br/>

<h3>기본 골격 프로젝트로 시작</h3>
- controllers <br/>
- model<br/>
- services<br/>
- resources<br/>
- licensing-service<br/>
- src/model/java/com/thoughtmechanix/licenses<br/>

프로젝트의 pom.xml 파일은 각 프로젝트의 root 디렉토리에 존재한다.

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.thoughtmechanix</groupId>
 <artifactId>licensing-service</artifactId>
 <version>0.0.1-SNAPSHOT</version>
 <packaging>jar</packaging>
 
 <name>EagleEye Licensing Service</name>
 <description>Licensing Service</description>
 
 <parent>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-parent</artifactId>  ▷ 메이븐에 스트링 부트 스타터 의존성을 추가하도록 지시한다.
     <version>1.4.4.RELEASE</version>
     <relativePath/>
 </parent>
 
 <dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>  ▷ 메이븐에 스프링 부트 웹 의존성을 추가하도록 지시한다.
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>  ▷ 메이븐에 스프링 엑추에이터 의존성을 추가하도록 지시한다.
    </dependency>
 </dependencies>
 
 <build>
     <plugins>
         <plugin>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-maven-plugin</artifactId>  ▷ 메이븐에 스프링부트 애플리케이션의 빌드와 배포를 위한 스프링 전용 메이븐 플러그인을 포함하도록 지시한다.
         </plugin>
     </plugins>
 </build>
</project>
```

스프링 부트 팀에서는 개발자 편의를 위해 관련된 의존 프로젝트를 다양항 starter 키트에 모아놨다.<br/>
그리고 여기에서는 첫번째 부분에 스프링 부트 프레임워크 2.0.3 버전을 끌어오도록 명시하였다.<br/>

두 세번째 부분에서는 스프링 웹과 액추에이터 스타터 키드를 끌어오도록 명시했다.<br/>
이 부분은 모든 스프링 부트의 REST 기반 서비스의 핵심이다.<br/>
서비스에 더 많은 기능을 추가하면 의존성이 있는 프로젝트 목록도 늘어난다.<br/>

스프링 소스는 스프링 부트로 만든 애플리케이션 빌드와 배포를 단순화한 메이블 플러그인들이 제공해왔다.<br/>
네 번째 부분에서는 메이븐 빌드 스크립트가 최신 스프링 부트용 메이븐 플러그인을 설치하도록 명시되었다.<br/>
이 플러그인은 메이븐과 스프링 부트의 사용을 도와주는 부가 기능을 포함한다.<br/>

<h3>스프링 부트 애플리케이션 부팅 : Bootstrap 클래스 작성</h3>
스프링 부트로 간단한 마이크로서비스를 시작한 후 반복하며 기능을 전달하는데 다음 2개의 클래스를 생성해야한다.<br/>

- 스프링 부트가 애플리케이션을 시작하고 초기화하는 데 사용되는 Spring Bootstrap 클래스<br/>
- 마이크로서비스에서 호출할 수 있는 HTTP 앤드포인트를 노출하는 Spring Controller 클래스<br/>

스프링 부트는 애너테이션을 사용해 서비스 설정과 구성을 단순화하는데 2-2의 bootstrap클래스를 살펴보면 분명히 알 수 있다.<br/>

```
package com.thoughtmechanix.licenses;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication    ▷ @SpringBootApplication 애너테이션은 스프링 부트 프레임워크에 이 클래스가 프로젝트의 부트스트랩 클래스라고 지시한다.
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);    ▷ 스프링 부트 서비스를 시작하기위해 호출한다. 
    }
}
```

@SpringBootApplication 애너테이션이 붙은 클래스는 스프링에서 정의하는 빈(Bean)의 출처라고 스프링 컨테이너에 지시한다.<br/>
스프링 부트 애플리케이션의 스프링 빈(Spring Bean)은 다음 클래스를 사용해 정의할 수 있다.<br/>
1. @Component 또는 @Service, @Repisitory 애너테이션이 붙은 클래스를 정의한다.<br/>
2. @Configuration 애너테이션이 붙은 클래스에 스프링 빈을 생성하기 위해 @Bean 생성자 메서드를 정의한다.<br/>

@SpringBootApplication 애니테이션은 내부에서 Application 클래스를 구성 클래스로 지정하고, 자바 클래스 경로에 다른 스프링 빈이 있는지 찾기 위해 모든 클래스를 자동으로 스캔한다.<br/>

Application 클래스의 main() 메서드다. 이 메서드에서 SpringApplication.run(Application.class, args) 호출은 스프링 컨테이너를 시작하고 스프링 ApplicationContext 객체를 반환한다.<br/>

중요한 것은,  @SpringBootApplication 애너테이션과 해당 Application 클래스를 마이크로서비스의 부트스트립 클래스로 만든다는 점이다.<br/>
따라서 서비스 초기화를 위하 핵심 로직을 이 클래스에 두어야한다.<br/>

<h3>마이크로서비스의 출입구 만들기 :스프링 부트 컨트롤러</h3>
위에서 간단한 스프링 부트의 부트스트랩 클래스를 구현했으므로 '어떤 일을 수행할 첫 번쨰 코드를 작성할 준비가 되었다.' → Controller 클래스가 된다.<br/>
스프링 부트 애플리케이션에서 Controller 클래스는 서비스의 앤드포인트를 노출하고 유입되는 HTTP 요청 데이터를 이 요청을 처리할 자바 메서드와 매핑한다.<br/>

아래의 Controller는 LicenseServiceController.java이고 해당 클래스는 POST, GET, PUT, DELETE 동사에 매핑되는 4개의 HTTP 앤드포인트를 노출한다.<br/>
Controller 는 스프링 부트가 최소 노력으로 서비스의 앤드포인트를 노출하고 비즈니스 로직 구축에 집중할 수 있게 도와주는 애너테이션의 제공 방법을 알아보자.<br/>

```
package com.thoughtmechanix.licenses.controllers;
import … // 간결한 코드를 위해 삭제

@RestController ▷ @RestController 애너테이션은 REST 기반 서비스라 명시하고 서비스 요청 및 응답을 JSON으로 자동으로 직렬화 및 역직렬화한다.
@RequestMapping(value="/v1/organizations/{organizationId}/licenses") ▷ 이 클래스의 모든 HTTP 앤드포인트는 /v1/organizations/{organizationId}/licenses 경로로 기반으로 노출한다.
public class LicenseServiceController {
    // 간결한 코드를 위해 클래스 내용 삭제
}
```

---
REST 이해
책의 모든 마이크로서비스는 서비스 구축을 위해 REST 접근법을 따른다. 목적에 맞게 만드러진 마이크로서비스는 다음 특징이 있다.

- 서비스 호출 프로토콜 HTTP를 사용한다. : 서비스는 HTTP 앤으포인트로 노출되고 HTTP 프로토콜을 사용해서 서비스와 데이터를 교환한다.
- 서비스의 행동 양식과 HTTP 표준 동사에 매핑한다: REST는 서비스의 행동 양식을 HTTP 동사인 POST, GET, PUT, DELETE에 매핑할 것을 강조한다. 이 동사는 대부분의 서비스에 있는 CRUD 함수에 
매핑된다.
- 서비스 끼리 교환되는 모든 데이터의 직렬화 형식으로 JSON을 사용한다. :JSON은 마이크로서비스에서 입출력 데이터의 직렬화를 위한 공용어가 되었다. XML을 사용할 수도 있지만 많은 REST기반 
애플리케이션은 자바스크립트와 JSON을 더 많이 사용한다. JSON은 자바스크립트 기반 웹 프런트앤드와 서비스에 사용되는 데이터의 직려로하 및 역직렬화를 위한 원시 형식이다.
- HTTP 상태 코드를 사용해 서비스 호출 상태를 전달한다 : REST 기반 서비스는 HTTP 상태 코드와 리버스 프록시나 캐시처럼 웹 기반 인프라스트럭처를 활용해 마이크로서비스와 비교적 쉽게 통합
할 수 있다.

HTTP 는 웹 언어이며, 서비스 구축을 위한 철학적 프레임워크로 HTTP를 사용하는 것은 클라우드에서 서비스를 구축하는 핵심이다.

---

@RestController 애너테이션은 클래스 구준의 자바 애너테이션으로 스프링 컨테이너에 자바 클래스가 REST 기반 서비스에 사용된다고 알리는 역할이다.<br/>
서비스에 JSON이나 XML로 전달된 데이터의 직렬화를 자동으로 처리한다. <br/>
@RestController 를 사용하면 ResponseBody 클래스로 반환할 필요없다. (ResponseBody를 포함하는 RestController 애너테이션에 의해 모두 처리되기 때문이다.<br/>

@RequestMapping 애너테이션은 클래스 또는 메서드 수준의 애너테이션으로 스프링 컨테이너에 해당 서비스가 HTTP앤드포인트를 외부에 공개한다고 알리는 데 사용된다.<br/>
클래스 수준의 @RequestMapping 애너테이션을 사용하면 그 컨트롤러가 노추하는 모든 앤드포인트의 최상위 URL을 설정할 수 있다.<br/>

위에서는 클래스에 @RequestMapping(value="/v1/organizations/{organizationId}/licenses") 를 사용했으므로 Controller 클래스가 노출하는 모든 앤드포인트에 대한 최상위 URL을 설정한다.<br/>
따라서 이 Controller 클래스의 모든 앤드포인트는 /v1/organizations/{organizationId}/licenses 에서 시작된다.<br/>
{organizationId}는 모든 호출에서 전달된 organizationId가 매개변수화된 url에 사용될 것을 암시하는 자리 표시이다.<br/>

```
// 개별 GET HTTP 앤드포인트 노출(LicenseServiceController.java)
@RequestMapping(value="/{licenseId}",method = RequestMethod.GET)   ▷ /v1/organizations/{organizationId}/licenses/{licenseId}로 GET 앤드포인트를 생성한다.
public License getLicenses( 
    @PathVariable("organizationId") String organizationId, 
    @PathVariable("licenseId") String licenseId) {   ▷ URL의 두 매개변수(organizationId와  licenseId)를 매서드 매개변수로 매핑한다.
     return new License()
     .withId(licenseId)
     .withProductName("Teleco")
     .withLicenseType("Seat")
     .withOrganizationId("TestOrg"); 
 }
```

여기에서는 @RequestMapping 을 추가해 value와 method라는 두 매개변수를 전달한 것이다.<br/>
메서드 수즌의 @RequestMapping 을 사용하면 그 클래스에 정의된 최상위 수준의 애너테이션을 기반으로 앤드포인트를 구성해, 컨드롤러 클래스에 유입되는 모든 HTTP 요청을 <br/>
/v1/organizations/{organizationId}/licenses/{licenseId} 앤드포인트에 맞춘다.<br/>

@RequestMapping 애너테이션의 두 번쨰 매개변수인 method는 메서드에 대응되는 HTTP 동사를 지정한다. (여기서는 RequestMethod.GET 열거셩으로 대응했다.)<br/>

@PathVariable 애너테이션은 유입된 URL에 전달된 매개변수 (parameterName 구문으로 표시한 변수)를 메서드의 매개변수로 매핑하는 데 사용한다.<br/>
위에서는 두 매개변수인 organizationId와 licenseId를 메서드의 매개변수 수준의 변수로 매핑한다.<br/>

<h2>데브옵스 이야기 : 혹독한 런타임 구축</h2>
데브옵스(DevOps)엔지니어에게 마이크로서비스 설계란 양산(실운영) 이후의 서비스 관리에 관한 설계다.<br/>
데브옵스는 다양하며 새롭게 부상하는 IT 분야지만, 책에서는 다음 네 가지 원칙으로 마이크로서비스 개발을 시작하고 실행해 볼 것이다.<br/>

1. 마이크로서비스는 단일 소프트웨어 산출물을 사용해 여러 서비스 인스턴스를 시작하거나 제거할 수 있도록 자체 완비형이며 독립적으로 배포가능해야 한다.<br/>
2. 마이크로서비스는 구성가능(configurable)해야한다. 서비스 인스턴스가 시작될 때 구성에 필요한 데이터를 중앙에서 읽어 들이거나 환경 변수로 전달된 구성 정보를 받아야 한다.<br/>
 그리고 서비스 구성하는 데 사람의 개입은 필요하지 않다.
3. 마이크로서비스 인스턴스는 클라이언트가 위치를 알지 못하도록 투명해야 한다. 클라이언트는 서비스의 정확한 위치를 알고 있어서는 안 된다. <br/>그 대신 마이크로 서비스 클라이어언트는 마이크로
서비스 인스턴스의 물리적인 위치를 모르더라도 애플리케이션이 알 수 있도록 서비스 디스커버리 에이전트와 통신해야 한다.<br/>
4. 마이크로서비스는 자신의 상태를 전달해야 한다. 이는 클라우드 아키텍처에서 매우 중요한 부분이다.<br/> 마이크로서비스 인스턴스들은 고장 날 수 있으며 클라이언트는 잘못된 서비스 인스턴스를 피해 
라우팅해야 한다.

이 4가지 원칙들은 마이크로서비스 개발에서 발생하는 역설을 드러낸다.<br/>
마이크로서비서의 크기와 범위가 줄어들어도 이 마이크로서비스들을 사용하면 애플리케이션에서는 동작 부분이 더 많아지는데, 마이크로서비스가 자체 분산 컨테이너에 분산되어 서로 독립적으로 <br/>
실행되기 떄문에 이러한 현상은 더 심해진다.<br/>

데브옵서 관점에서 마이크로서비스와 관련된 운영상의 요구 사항을 해결하고,<br/>
이러한 네 가지 원칙을 마이크로서비스를 빌드하고 환경에 배포할 떄마다 발생하는 표준 수명 주기 이벤트로 변환해야 한다.<br/>

4가지 원칙은 운영상의 수명 주기 단계로 대응된다.<br/>
1. 서비스 어셈블리(service assembly) : 동일한 서비스 코드와 런타임을 정확히 같은 방식으로 배포하기 위해 반복성과 일관성을 보장하는 서비스 패키징과 배포 방식은 무엇인가?<br/>
2. 서비스 부트스트래핑(service bootstrapping) : 사람이 개입하지 않아도 모든 환경에 마이크로서비스 인스턴스를 신속하게 시작하고 배포하기 위해 애플리케이션과 환경별 구성 코드를 런타임
코드와 분리하는 방법은 무엇인가?<br/>
3. 서비스 등록 및 디스커버리(service registration/discovery) : 새로운 마이크로서비스 인스턴스가 배포될 때 다른 애플리케이션 클라이언트가 발견할 수 있게 만다는 방법은 무엇인가?<br/>
4. 서비스 모니터링(service monitoring) : 마이크로서비스 환경에서 매우 높은 가용성을 요구하기 때문에 동일 서비스를 여러 인스턴스로 실행하는 것이 일반적이다. <br/>데브옵스 관점에서 마이크로
인스턴스를 모니터링하고 마이크로서비스 고장을 회피하는 라우팅과 비정상 서비스 인스턴스를 제거하는지 확인해야 한다.<br/>

![2-6](https://user-images.githubusercontent.com/87962572/147409719-98e51279-58e7-44f2-aa94-5b1beaad7463.jpg)

<h3>1. 서비스 어셈블리: 마이크로서비스의 패키징과 배포</h3>

데브옵스 관점에서 볼 떄 마이크로서비스 아키텍처의 핵심 개념 중 하나는 애플리케이션의 환경변화에 대응해 마이크로서비스의 여러 인스턴스를 신속하게 배포할 수 있다는 것이다.

이 개념을 충족하기 위해 마이크로서비스는 필요한 의존성을 모두 담아 단일 산출물로 패키징하고 설치될 수 있어야 한다.
일관된 구축, 패키징 및 배포하는 이 과정을 서비스 어셈블리라고 한다.

![KakaoTalk_20211226_223849955](https://user-images.githubusercontent.com/87962572/147409934-306bb997-1d61-4472-8f1c-474886c30cec.jpg)

거의 모든 자바 마이크로서비스 프레임워크는 코드와 함께 패키징하고 배포할 수 있는 런타임 엔진을 포함한다.<br/>
내장형 런타임 엔진을 포함하는 단일 산출물로 배포하면 이러한 구성 편차 문제를 상당 부분 제거한다.<br/>

<h3>2. 서비스 부트스트래핑 : 마이크로서비스의 구성 관리</h3>
서비스 부트스트래핑은 마이크로서비스가 처음 가동할 때 시작하며 애플리케이션 구성 정보를 로드한다.<br/>

애플리케이션 실행 중 행동 양삭을 구성해야 할떄 이러한 작업은 일반적으로 애플리케이션과 함께 배포된 프로퍼티 파일에서 애플리케이션 구성 데이터를 읽거나 관계형 데이터베이스 같은
데이터 저장소에서 데이터를 읽어오는 작업이다.

![2-8](https://user-images.githubusercontent.com/87962572/147410081-fb4355ce-f775-4835-a591-ee834d27e2a0.jpg)

마이크로서비스에는 대개 동일한 형태의 구성 요구 사항이 있다. 클라우드에서 실행되는 마이크로서비스 애플리케이션에는 수백 개 또는 수천 개의 마이크로서비스 인스턴스를 실행할 수 있다는 
 점에서 서비스가 전 세계로 확장되었을 때 복잡성이 더 커지게 된다.
 
이러할 떄 구성 데이터는 구조가 단순한 편이고 일반적으로 자주 읽지만 자주 쓰지는 않는다. 데이터베이스는 단순한 키-값 짝보다 더 복잡한 데이터 모델을 관리할 목적으로 설계되었다.
그래서 이러한 상황에서는 관계형 데이터베이스를 쓰는 것은 과도하다.

<h3>3. 서비스 등록과 디스커버리 : 클라이언트가 마이크로서비스와 통신하는 방법</h3>
클라우드 기반 환경에서 서버는 일시적이므로 위치 투명성을 가져야한다.
클라우드 기반 서비스는 실행될 서버에 완전히 새로운 IP를 할당받고 신속히 시작하고 제거될 수 있다.
그래서 마이크로서비스 아키텍처는 많은 서비스 인스턴스를 실행하며 고수준의 확장성과 가용성을 얻을 수 있었다.

그러다보니 끊임없이 서비스의 시작과 종료를 반복하는 과정에서 서비스를 대량으로 수동 또는 직접 관리하면서 장애가 발생할 수 있다. 

마이크로서비스 인스턴스는 제 3자 에이전트에 스스로 등록해야 하는데 이 등록 과정을 서빗 디스커버리(discovery)라고한다.
인스턴스의 물리적인 IP 주소 또는 도메인 주소와 애플리케이션이 서비스 검색에 사용할 논리적인 서비스 이름, 이 2가지 정보를 에이전트에 전달한다.

어떤 서비스 디스커버리 에이전트는 상태 확인을 하는 데 필요한 URL 을 등록하려는 서비스에 요구하기도 한다.

![2-9](https://user-images.githubusercontent.com/87962572/147410660-e832637a-6c04-405c-ba37-90d74ee01487.jpg)

<h3>4. 마이크로서비스의 상태 전달</h3>

클라우드 기반 애플리케이션에서는 종종 어떤 서비스의 많은 인스턴스가 실행될 수 있고 언젠가 그 서비스 인스턴스 중 하나가 고장날 것이다.
서비스 디스커버리 에이전트는 등록된 각 서비스 상태를 모니터링하고 클라이언트가 고장 난 서비스를 호출하지 않도록 자신의 라우팅 테이블에서 문제가 된 서비스 인스턴스를 제거한다.

![2-10](https://user-images.githubusercontent.com/87962572/147410732-3b029089-6ebc-4332-9283-0060290fae4a.jpg)

서비스 디스커버리 에이전트는 해당 서비스가 가용한지 확인하기 위해 상태 확인 인터페이스를 계속 모니터링하고 핑 한다.
일관된 상태 확인 인터페이스를 구축하면 여러 클라우드 기반 모니터링 도구를 사용해 문제를 감지하고 적절히 대응할 수 있다.

REST 기반 마이크로서비스 환경에서 상태 확인 인터페이스를 만드는 가장 단순한 방법은 JSON 페이로드와 HTTP 상태 코드를 반환하는 HTTP 엔드포인트를 노출하는 것이다.
메이븐 빌드 파일을 수정해 스프링 액추에이터 모듈만 추가하면 된다.
스프링 액추에이터는 서비스 상태를 이해하고 관리하는 데 도움이 되는 엔드포인트를 기본 기능으로 제공한다.
메이븐 빌드 파일에 다음 의존성을 추가하면된다.



```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

http://localhost:8080/health

엔드 포인트에 요청을 보내면 상태 정보가 반환된다.
```

<h2>모든 관점에서</h2>

클라우드에서 마이크로서비스는 언뜻 보기에 단순해 보이지만 성공하려면 여러 화합된 비전을 이루는 관점의 통합이 필요하다.
1. 아키텍트 : 비즈니즈 문제의 실제 윤곽을 잡는다. 비즈니스 문제 영역을 기술하고 이야기되는 스토리를 경청하고, 출현할 마이크로서비스 후보에 주시하자. 처음부터 잘게 나뉜 많은 서비스에서 
시작하는 것보다 굵게 나뉜 마이크로서비스에서 시작해서 작은 서비스로 리팩토링하면 더 낫다는 것도 기억하자.
2. 소프트웨어 엔지니어 : 서비스가 작다는 사실이 좋은 설꼐 원칙을 포기하라는 것은 아니고, 서비스 안의 각 계층이 개별 책임을 맡는 계층적 서비스를 구축하는 데 집중한다.
코드 내 프레임워크를 만드려면 유혹을 피하고 완전히 독립적인 마이크로서비스를 지향한다.
3. 데브옵스 엔지니어 : 서비스는 외부와 단절된 것이 아니다. 서비스 수명 주기를 일찍 수립하고, 데브옵스 관접에서 서비스 빌드와 배포를 자동화하는 방법뿐 아니라 서비스 상태를 모니터링하고
문제가 발생할 때 대응하는 방법에도 집중해야 한다.






