<h1>2장 스프링 부트로 마이크로서비스 구축</h1>
<ul>
  <li>2.1 아키텍트의 이야기: 마이크로서비스 아키텍처 설계</li>
  <li>2.2 마이크로서비스를 사용하지 않아야 할 때</li>
  <li>2.3 개발자 이야기: 스프링 부트와 자바로 마이크로서비스 생성</li>
  <li>2.4 데브옵스 이야기: 혹독한 런타임 구축</li>
  <li>2.5 모든 관점에서</li>
</ul>

매머드급 프로젝트는 모든 애플리케이션의 요구 사항과 설계를 프로젝트 초반에 정의할 것을 주장하는 전통적인 대규모 폭포수(waterfall) 개발 방법론을 따르는 경향이 있었다.<br/>
소프트웨어의 모든 명세가 철두철미하길 지나치게 강조한 나머지 새로운 비즈니스 요구 사항을 충족하거나 리팩토링할 여지나 개발 토기 단계에서 저지른 실수에서 배울 여유가 없었다.<br/>

전통적인 폭포수 개발 방법론을 사용하기 어려워진 것은 이들 프로젝트의 소프트웨어 산출물이 가진 세분화 정도에 따라 다음과 같은 단점이 발생할 것이다.<br/>

- 강한 결합(tightly coupled) : 비즈니스 로직 호출은 SOAP나 REST 같은 구현 기술에 중립적인 프로토콜 수준이 아닌 프로그래밍 언어 수준에서 이루어진 것이다. <br/>
따라서 애플리케이션 컴포넌트를 조금만 수정해도 그 애플리케이션의 다른 부분을 꺠뜨리거나 새로운 버그를 생산할 가능성이 매우 높다.<br/>
- 누설(leaky) : 대규모 소프트웨어 애플리케이션의 대부분은 다양한 유형의 데이터를 취급한다. 전통적인 모델에서 데이터는 같은 데이터 저장소 안에서 같은 데이터 모델을 유지한다.<br/>
데이터 사이에 명확한 경계가 있지만 한 영역에 속한 팀이 다른 팀의 데이터에 직접적으로 접근하고 싶은 유혹을 너무 자주 받는다. 그래서 다른 영역의 데이터에 쉽게 접근하게 되면,<br/>
보이지 않는 의존성이 생겨나고 컴포넌트의 내부 데이터 구조에 대한 구현이 애플리케이션 전체에 유출이 될 수 있다. 그리고 테이블 하나를 조금만 변경해도 애플리케이션 전번에 걸처 엄청난<br/>
코드 수정과 회귀 테스팅이 필요할 수 있다.<br/>
- 모놀리식 : 전통적인 애플리케이션에서 대부분의 컴포넌트는 여러 팀에서 공유되는 단일 코드 베이스에 저장하므로 코드를 변경할 때마다 전체 애플리케이션을 재컴파일하고, 전체 테스팅 주기를
재수행하며 재배포한다.애플리케이션 코드 베이스를 조금만 변경해도 비용이 많이 들며 오랜 시간이 소요된다.<br/>

마이크로서비스 기반 아키텍처는 기능을 제공하는 데 위와 다른 접근법을 취한다. 구체적인 특성은 다름와 같다.<br/>
- 제한(constrained) : 마이크로서비스는 하나의 책임 집합을 가지며 범위가 좁다.<br/>
- 느슨한 결합(looselu coupled) : 마이크로서비스 기반 애플리케이션은 작은 버시스 집합이며, HTTP와 REST처럼 비독점적 호출 프로토콜을 사용하는 구현 기술에 중립적인 인터페이스로 서로 소통한다.<br/>
서비스에 대한 인터페이스가 변하지 않는 한 마이크로서비스 소유자는 전통적인 애플리케이션 아키텍처보다 서비스를 더 자유롭게 수정할 수 있다.<br/>
- 추상화(abstract) : 마이크로서비스는 자신의 데이터 구조와 데이터 소스를 완전히 소유한다. 마이크로서비스가 소유한 데이터는 해당 서비스만 수정할 수 있다.<br/>
- 독립적(independent) : 마이크로서비스 애플리케이션 안의 모든 마이크로서비스는 서로 독립적으로 컴파일하고 배포할 수 있다. 모놀리식 애플리케이션보다 변경 사항을 휠씬 쉽게 분리하고 테스트할 수 있는 것을 의미한다.<br/>

클라우드에 기반을 둔 개발에 왜 이러한 마이크로서비스 아키텍처의 일반적인 특징은 다음과 같이 3가지다.<br/>
- 사용자층이 다양하며 대규모다. : 마이크로서비스는 작은 범위를 담당하고, 명확히 정의된 인터페이스를 통해 접근하므로 기능을 신속히 제공할 수 있다.<br/>
- 상당한 작동 시간이 요구된다 : 마이크로서비스 자체의 분산적 특성 떄문에 애플리케이션 전체를 중단하지 않고도 고장과 문제를 더 쉽게 격리할 수 있다.<br/>
- 볼륨이 균일하지 않다 : 독립적인 배포가 가능한 작은 컴포넌트로 분리되어 있기 때문에 부하를 받는 컴포넌트를 조명하고 여러 서버에 수평 확장하기도 휠씬 쉽다.<br/>

<h2>2.1 아키텍처의 이야기 : 마이크로서비스 아키텍처 설계</h2>
마이크로서비스 아키텍처를 구축할 떄 프로젝트의 아키텍트는 다음 3가지 일에 집중한다.
1. 비즈니스 문제의 분해
2. 서비스 세분화의 확정
3. 서비스 인터페이스의 정의

<h3>비즈니스 문제의 분해</h3>

마이크로서비스 아키텍처에서 아키텍트는 비즈니스 문제를 각 화동 영역에 대표하는 덩이들로 분해하고 비즈니스 영역의 특정 부분과 연관된 비즈니스 규칙과 데이터 로직을 이 덩이들 안에 
캡슐화한다.<br/>

하지만, 항상 실현 가능한 것이 아니다. 한 트랜잭션 전체를 완료하지 위해 비즈니스 영역의 다양한 부분과 동작하는 마이크로서비스가 필요한 상황을 자주 겪는다.<br/>
아키텍트는 데이터 영역이 서로 어울리지 않는다면 마이크로서비스들의 서비스 경계를 나눈다.<br/>

마이크로서비스 후보로 분해하는 데 다음 지침을 사용하기 추천한다.
1. 비즈니스 문제를 기술하고 그 문제를 기술하는 데 사용한 명사를 주목하라.
  - 즉, 문제를 기술하는 데 동일한 명사가 반복해서 사용되면 대개 핵심 비즈니스 영역과 마이크로서비스로 만들 기회가 드러난다.
2. 동사에 주목하라
  - 동사는 행위를 부각하고 문제가 되는 영역의 윤곽을 자연스럽게 드러낸다.
3. 데이터 응집성을 찾아라.
  - 비즈니스 문제를 각 부분으로 분해할 떄 서로 연관성이 높은 데이터 부분들을 찾는다. 마이크로서비스는 자기 데이터를 완전히 소유해야한다. 따라서 대화 중 갑자기 지금껏 논의했던 내용과
  - 근몬적으로 다른 데이터를 읽거나 업데이트한다면 아마도 또 다른 서비스 후보가 필요할 수 있다.

먼저 EagleEye는 애플리케이션의 모든 사용자를 인터뷰하고 EagleEye와 상호 작용하고 사용하는 방법을 논의할 것이다.<br/>
사용자가 어떻게 애플리케이션과 상호 작용하고 어떻게 애플리키에시녀의 데이터 모델이 분해되는지 살펴보면서 문제 영역을 다음과 같은 마이크로서비스 후보로 나눌 수 있다.<br/>

비즈니스 사용자의 대화에서 언급된 명사와 동사가 여러 개 강조되었다. EagleEyes는 현재 사용 중인 애플리케이션이므로 애플리케이션을 먼저 살펴보고 주요 명사를 물리적 데이터 모델의 
데이터를 매핑할 수 있다.<br/> 현재 사용 중인 애플리케이션에 수백 개의 테이블이 존재하더라도 각 테이블은 대개 논리 개체들의 단일 집합으로 매핑된다.<br/>

2-1 EagleEye사용자와 인터뷰하고 일상 업무를 이해한다.
![2-1](https://user-images.githubusercontent.com/87962572/147091871-370f306a-2dd0-443c-b6a7-79085ae8b42c.PNG)

아래는 고객과 나눈 대화를 바탕으로 단순화된 데이터 모델을 보여준다.<br/>
비즈니스 인터뷰와 모델에 기초해 마이크로서비스가 될 후보는 조직, 라이선스, 계약과 자산 서비스다.<br/>

2-2 단순화된 데이터 모델
![2-2](https://user-images.githubusercontent.com/87962572/147092035-0b7e0545-60e0-4b4f-823b-7e3e4c798d6f.PNG)

<h2>서비스 세분화의 확정</h2>
데이터 모델을 단순화했다면 이제 애플리케이션이 필요한 마이크로서비스를 정의할 던계다.<br/>
위에 그림 2-2의 데이터 모델을 근거로 다음 요소들에 기반을 둔 4개의 마이크로서비스를 만들 수 있다.<br/>

목표는 이러한 주요 기능을 가져와 서로 독립적으로 빌드하고 배포할 수 있는 자체 완비형 유닛을 추출하는 것이다.<br/>
데이터 모델에서 서비스를 추출하는 일은 단순히 코드를 여러 프로젝트로 재패키징하는 것보다 더 많이 요구된다. <br/>
서비스가 접근하는 실제 데이터베이스 테이블을 서비스에 따라 정리하는 각 서비스가 특정 도메인의 테이블만 엑세스하게하는 일도 필요하다.<br/>

아래와 같이 관련된 애플리케이션 코드와 데이터 모델을 한곳에 묶어 개별 조각으로 나누는 것을 볼 수 있다.

![2-3](https://user-images.githubusercontent.com/87962572/147094711-d1197012-ce5c-41d7-ae82-e2c5f554d62a.PNG) 
위에 모놀리식 애플리케이션에서 독립적으로 배포가능한 작은 개별 서비스로 분해한다.<br/>
그리고 각 서비스는 자기 영역의 모든 데이터를 소유하고, 모든 서비스가 자기 데이터베이스를 보유한다는 것이 아니라 해당 영역을 소유하는 서비스만 그 영역의 데이터베이스에 엑세스할 수 
있는 의미다.<br/>

이렇게 나뉘어진 마이크로서비스에는 여러가지 특징이 있다. 그리고 그 개념을 사용해 올바르게 해결책을 구할 수 있다.<br/>
1. 큰 마이크로서비스에서 시작해 작게 리팩토링하는 것이 더 낫다. : 문제 여역을 한 번에 작은 서비스들로 분해하는 것은 마이크로서비스가 그저 단순한 데이터 서비스로 전락하기 때문에
너무 일찍 복합함을 겪게 된다.<br/>
2. 서비스 간 교류하는 방식에 먼저 집중한다. : 이는 큰 단위의 인터페이스를 만드는 데 도움이 된다. 큰 것을 작게 리팩토링하는 것이 더 쉽다.<br/>
3. 문제 영역에 대한 이해가 깊어짐에 따라 서비스 책임도 계속 변한다. : 마이크로서비스는 단일 서비스에서 시작해 여러 서비스로 분화되며 성장하는데, 원래 서비스는 <br/>
새로운들을 오케스트레이션하고 애플리케이션의 다른 부분에서 새 서비스들의 기능을 캡슐화한다. <br/>
<br/>
마이크로서비스 아키텍처는 처음부터 올바르게 설계하기가 어렵기 떄문에 진화론적 사고 과정으로 개발해야한다. <br/>
이것이 잘게 나뉜 서비스보다 굵게 나뉜 서비스에서 시작하는 거시 더 좋은 이유다.<br/>

독단적인 설계를 하지 않는 것도 중요하다. 분리된 두 서비스 사이에 너무 많은 호출이 발생하므로 데이터를 합치는 집합 서비스로 별도로 만들거나 서비스 영역의 명확한 겅계선이 없는<br/>
서비스에서 물리적 제약이 발생할 수 있다.<br/>

끝으로 완벽한 설계를 위해 시간을 낭비하고 노력에 비해 보여 줄 것이 없는 것보다는 실용적 접근 방식을 취하고 결과물을 전달하자.<br/>

<h3>서비스 사이의 대화: 서비스 인터페이스</h3>

일반적으로 서비스 인터페이스 설계를 고려할 때 다음 지침을 사용할 수 있다.
1. REST 철학을 수용하라 : 서비스에 대한 REST방식은 서비스의 호출 프로토콜로 HTTP를 수용하고 표준 HTTP 동사(GET, PUT, POST, DELETE)를 사용하는 것이 핵심이다.<br/>
HTTP 동사를 기반으로 기반 행동 양식을 모델링한다.<br/>
2. URI를 사용해 의도를 전달하라 : 서비스의 앤드포인트로 사용되는 URI는 문제 영역에 존재하는 다양한 자원을 기술하고 자원 관계에 대한 기본 매커니즘을 제공해야 한다.<br/>
3. 요청과 응갑에 JSON을 사용하라 : JSON은 초경량 데이터 직렬화 프로토콜이며 XML보다 훨씬 사용하기 쉽다.<br/>
4. HTTP 상태 코드로 결과를 전달하라 : HTTP 프로토콜에는 서비스 성공과 실패를 명시하는 풍부한 표준 응답 코드가 있다. 상태 코드를 익히고 코든 서비스에 일관되게 사용하는 것이 매우 중요하다.<br/>

<h2>2.2 마이크로서비스를 사용하지 않아야 할 때</h2>
언제 마이크로서비스를 사용하면 안 되는가?

```
1. 분산 시스템 구축의 복잡성
2. 가상 서버/컨테이너의 스프롤
3. 애플리케이션 유형
4. 데이터 변환과 일관성
```

<h3>분산 시스템 구축의 복잡성</h3>
마이크로서비스는 잘게 나뉘고 분산되어있어 모놀리식 애플리케이션에서 없던 복잡성을 가져온다.<br/>
마이크로서비스 아키텍처에는 높은 수준의 운영 성숙도 필요하다.<br/>
따라서 고도로 분산된 애플리케이션을 성공시키는 데 필요한 자동화와 운영 작업에 투자할 의사가 없는 조직이라면 마이크로서비스를 고려하지 않는 것이 좋다.<br/>

<h3>서버 스프롤(Server sprawl)</h3>
* 스프롤이란 : IT 업계에서 사용되는 용어로 활용도가 낮은 여러 서버가 실제 작업량보다 더 많은 공간과 리소스를 차지하는 현상을 의미한다.<br/>
마이크로서비스의 가장 일반적인 배포 모델 중 하나는 한 서버에 하나의 마이크로로서비스 인스턴스를 배포하는 것이다.<br/>
대규모 마이크로서비스 기반 애플리케이션의 운영 환경에서만 구축 및 관리가 필요한 서버나 컨데이터가 (일반적으로) 50~100개 있을 수 있다.<br/>
 * 클라우드에서 이들 서비스를 실행하는 데 드는 비용은 저렴하더라도 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡해질 수 있다.<br/>
(마이크로서비스의 유연성은 모든 서버를 운영하는 데 드는 비용과 함께 따져 보아야 한다.)<br/>

<h3>애플리케이션 유형</h3>
마이크로서비스는 재사용을 추구하며 높은 회복성과 확장성이 필요한 대규모 애플리케이션의 구축에 매우 유용하다.<br/>
이 때문에 많은 클라우드 기반 기업에서 마이크로서비스 기반 기업에서 마이크로서비스를 채택한다.<br/>

만약에 소형 애플리케이션이나 소수 사용자를 위한 애플리케이션이라면 마이크로서비스 구축에 따른 복잡성이 분산 구축으로 얻게 될 가치보다 더 클 수 있다.<br/>

<h3>데이터 변환과 일관성</h3>

마이크로서비스를 검토할 떄 서비스의 데이터 사용 패턴과 서비스 소비자가 어떻게 서비스를 사용하는지 고민해야 한다.
 * 애플리케이션이 여러 데이터 소스에서 복잡한 데이터를 취합하고 변환해야 할 경우 마이크로서비스의 분산된 특성 때문에 작업이 어려워진다.
마이크로서비스는 변함없이 과도한 책임을 떠안고 성능 문제에서 취약해질 것이다.

마이크로서비스 사이에 트랜잭션을 처리하는 표준이 없다는 사실도 잊지 말자.
트랜잭션 관리가 필요하면 직접 만들어야 하고, (7장) 메세지를 사용해 서로 통신할 수 있다.
 * 메세징에서는 데이터를 업데이트할 때 지연 시간이 발생한다. 따라서 업데이트한 데이터가 즉시 나타나지 않을 수도 있어 애플리케이션은 최종 일관성을 유지해야한다.


<h2>개발자 이야기: 스프링 부트오 자바로 마이크로서비스 생성</h2>
EagleEye도메인 모델에서 라이선싱 마이크로서비스를 구축할 떄 개발자 우선순위를 살펴보자.
라이선싱 서비스는 스트링 부트를 사용해 작성한다.
스프링 부트는 표준 스프링 라이브러리보다 추상화된 레이어로, 개발자가 전통적인 스프링 애플리케이션보다 훨씬 적은 형식과 구성으로 그루비와 자바 기반의 웹 애플리케이션과 마이크로서비스를
신속히 구축하게 된다.

앞으로 다룰 여러절에서는 다음 단계를 공통적으로 수행할 것이다.
1. 마이크로서비스의 기본 골격과 메이븐 스크립트를 빌드해 애플리케이션을 빌드한다.
2. 마이크로서비스용 스프링 컨테이너를 시작할 스프링 부트스트랩 클래스를 구현하고 이 클래스으 초기화 작업을 시작한다.
3. 서비스의 앤드포인트를 노출하기 위해 앤드포인트를 매핑하는 스프링 부트 컨트롤러클래스를 구현한다.

<h3>기본 골격 프로젝트로 시작</h3>
- controllers <br/>
- model<br/>
- services<br/>
- resources<br/>
- licensing-service<br/>
- src/model/java/com/thoughtmechanix/licenses<br/>

프로젝트의 pom.xml 파일은 각 프로젝트의 root 디렉토리에 존재한다.

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.thoughtmechanix</groupId>
 <artifactId>licensing-service</artifactId>
 <version>0.0.1-SNAPSHOT</version>
 <packaging>jar</packaging>
 
 <name>EagleEye Licensing Service</name>
 <description>Licensing Service</description>
 
 <parent>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-parent</artifactId>  ▷ 메이븐에 스트링 부트 스타터 의존성을 추가하도록 지시한다.
     <version>1.4.4.RELEASE</version>
     <relativePath/>
 </parent>
 
 <dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>  ▷ 메이븐에 스프링 부트 웹 의존성을 추가하도록 지시한다.
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>  ▷ 메이븐에 스프링 엑추에이터 의존성을 추가하도록 지시한다.
    </dependency>
 </dependencies>
 
 <build>
     <plugins>
         <plugin>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-maven-plugin</artifactId>  ▷ 메이븐에 스프링부트 애플리케이션의 빌드와 배포를 위한 스프링 전용 메이븐 플러그인을 포함하도록 지시한다.
         </plugin>
     </plugins>
 </build>
</project>
```

스프링 부트 팀에서는 개발자 편의를 위해 관련된 의존 프로젝트를 다양항 starter 키트에 모아놨다.
그리고 여기에서는 첫번째 부분에 스프링 부트 프레임워크 2.0.3 버전을 끌어오도록 명시하였다.

두 세번째 부분에서는 스프링 웹과 액추에이터 스타터 키드를 끌어오도록 명시했다.
이 부분은 모든 스프링 부트의 REST 기반 서비스의 핵심이다.
서비스에 더 많은 기능을 추가하면 의존성이 있는 프로젝트 목록도 늘어난다.

스프링 소스는 스프링 부트로 만든 애플리케이션 빌드와 배포를 단순화한 메이블 플러그인들이 제공해왔다.
네 번째 부분에서는 메이븐 빌드 스크립트가 최신 스프링 부트용 메이븐 플러그인을 설치하도록 명시되었다.
이 플러그인은 메이븐과 스프링 부트의 사용을 도와주는 부가 기능을 포함한다.

<h3>스프링 부트 애플리케이션 부팅 : Bootstrap 클래스 작성</h3>
스프링 부트로 간단한 마이크로서비스를 시작한 후 반복하며 기능을 전달하는데 다음 2개의 클래스를 생성해야한다.

- 스프링 부트가 애플리케이션을 시작하고 초기화하는 데 사용되는 Spring Bootstrap 클래스
- 마이크로서비스에서 호출할 수 있는 HTTP 앤드포인트를 노출하는 Spring Controller 클래스

스프링 부트는 애너테이션을 사용해 서비스 설정과 구성을 단순화하는데 2-2의 bootstrap클래스를 살펴보면 분명히 알 수 있다.

```
package com.thoughtmechanix.licenses;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication    ▷ @SrpingBootApplication 애너테이션은 스프링 부트 프레임워크에 이 클래스가 프로젝트의 부트스트랩 클래스라고 지시한다.
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);    ▷ 스프링 부트 서비스를 시작하기위해 호출한다. 
    }
}
```

