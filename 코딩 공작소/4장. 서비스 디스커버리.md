<h1>4장 서비스 디스커버리</h1>

<ul>  
  <li>4.1 서비스 위치 찾기</li>
  <li>4.2 클라우드에서 서비스 디스커버리</li>
  <li>4.3 스트링 유레카 서비스 구축</li>
  <li>4.4 스프링 유레카에 서비스 등록</li>
  <li>4.5 서빗 디스커버리를 사용한 서비스 검색</li>
  <li>4.6 요약</li>
</ul>


<h3>서비스 디스커버리의 배경</h3>
서비스 디스커버리는 분산 아키텍처에서는 시스템의 물리적 위치 주소를 찾아야된다는 needs로부터 시작되었다.<br/>
서비스 디스커버리는 애플리케이션에서 사용하는 모든 원격 서비스의 주소가 퐆함된 프로퍼티 파일을 관리하는 것처럼 단순하거나, UDDI 저장호처럼 정형화되고 복잡한 것일수 있다.<br/>

서비스 디스커버리의 핵심은 다음 2가지이다.<br/>
1. 애플리케이션팀은 서비스 디스커버리를 사용해 해당 환경에서 실행하는 서비스 인스턴스 개수를 신속하게 수평 확장하거나 축소할 수 있어야 한다.<br/>
서비스 디스커버리를 통해 서비스의 물리적 위치는 서비스 소비자에게는 드러나지 않는다.<br/>
서비스 소비자는 실제 서비스 틴스턴스의 물리적 위치를 모르기 때문에 서비스 풀에서 새로운 인스턴스의 추가나 삭제가 자유롭다.<br/>

2. 애플리케이션 회복성을 향상하는 데 도움이 된다는 것이다.<br/>
서비스 디스커버리 엔진이 사용할 수 없는 서비스를 피해 라우팅하므로 다운된 서비스가 야기한 피해를 최소화한다.<br/>

<H2>4.1 서비스 위치 찾기</H2>
애플리케이션에서 여러 서버로 분산된 자원을 호출할 때마다 해당 자원의 물리적 위치를 찾아야 한다.<br/>
클라우드가 아닌 환경에서 이 서비스의 위치 확인은 대개 DNS와 네트워크 로드 밸런서로 해결되었다.<br/>

아래는 DNS와 로드밸러서를 사용하는 전통적인 서비스 위치 확인 모델이다.
![4-1](https://user-images.githubusercontent.com/87962572/151788507-50ec1c04-44d4-4bf5-a359-3a4ec57871d9.PNG)

1. 애플리케이션은 일반 DNS와 서비스별 경로를 사용해 서비스를 호출한다.
2. 로드 밸런서는 서비스를 호스팅하는 서버의 물리적 위치를 찾는다
3. 영구적인 서버에서 실행되는 애플리케이션 컨테이너에 배포된 서비스다.
4. 보조 로드 밸런서는 주 로드 밸런서 상태를 확인하고 필요하면 교체한다.

이처럼 애플리케이션은 다른 조직에 잇는 서비스를 호출해야 한다.
애플리케이션이 호출하려던 서비스를 대표하는 고유 경로와 함게 일반적인 DNS 이름을 사용해 서비스 호출을 시도한다.

로드 밸런서는 사용자가 엑세스하려는 경로를 기반으로 라우팅 테이블에서 물리적 주소 항목을 찾는다.
로드 밸런서는 서버 목록에서 하나를 선택해 요청을 전달한다.

서비스의 각 인스턴스는 여러 애플리케이션 서버에 배포된다.

고가용성을 위해 보조 로드 밸런서가 유휴 상태로 대기하고 주 로드 밸런서가 정상인지 핑(ping)으로 확인한다.
정상이 아니면 보조 로드 밸런서가 활성화되고 주 로드 밸런서의 ip 주소를 인수해 요청을 처리하기 시작한다.

<h3>로드 밸런서의 단점</h3>
로드 밸런서는 대부분의 애플리케이션이 중앙 집중화된 네트워크 인프라스트럭처를 이용해 처리될 수 있는 크기와 규모가 있는 기업 환경에서 잘 동작한다.
하지만 대용량의 트랜잭션과 중복성을 처리해야 하는 클라우드에서 중앙 집중식 네트워크 인프라스트럭처는 효율적으로 확장되지 않고 비용 효율도 낮아서 결국 제대로 동작하지 못한다.

<h2>4.2 클라우드에서 서비스 디스커버리</h2>
클라우드 기반 미이크로서비스 환경에 대한 솔루션은 다음 기능을 갖춘 서비스 디스커버리 메커니즘을 사용한다.

1. 고가용성 
2. p2p  : 서비스 디스커버리 클러스터의 각 노드는 서비스 인스턴스의 상태를 공유한다.
3. 부하 분산 : 서비스 디스커버리는 요청을 동적으로 부하 분산해서 서비스 디스커버리가 관리하는 모든 서비스 인스턴스에 분배해야 한다.
4. 회복성 :서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐시해야 한다.
5. 장애 내성 : 서비스 디스커버리는 서비스 인스턴스의 비정상을 탐지하고 가용 서비스 목록에서 인스턴스를 제거해야 한다.

<h3>4.2.1 서비스 디스커버리 아키텍처</h3>
서비스 디스커버리 인스턴스는 대개 고유하고 로드 밸런서를 앞에 두지 않는다.

![4-2](https://user-images.githubusercontent.com/87962572/151789775-f69ef70e-9988-4efc-927a-c3789eba4f3d.PNG)

서비스 인스턴스가 추가/제거될 때 서비스 디스커버리 에이전트를 업데이트하고 사용자 요청을 처리할 수 있는 상태가 된다.

1. 서비스 디스커버리 에이전트를 이용해 논리적 이름으로 서비스 위치를 검색할 수 있다.
2. 서비스가 온라인 상태가 되면 자기 IP 주소를 서비스 검색 에이전트에 등록한다.
3. 서비스 디스커버리 노드는 서비스 인스턴스의 상태 정보를 서로 공유한다.
4. 서비스는 서비스 디스커버리 에이전트에 상태 정보를 보낸다. 서비스가 종료되면 서비스 디스커버리 계층에서 종료된 인스턴스의 IP주소를 제거한다.

서비스가 서비스 디스커버리 서비스에 등록되면 그 서비스의 기능을 사용해야 하는 애플리케이션이나 다른 서비스에서 사용할 준비가 된 것이다.
클라이언트가 서비스를 발견하기 위한 다른 모델도 존재한다.
클라이언트는 서비스 디스커버리 엔진에만 의존해 서비스가 호출될 때마다 서비스 위치를 확인한다.

이 방법을 사용하면 클라이언트가 서비스를 찾고 호출하기 위해 서비스 디스커버리 엔진에 전적으로 의존하므로 취약하다.

더 견고한 방식은 클라이언트 측 부하 분산이라는 방법을 사용하는 것이다.

![4-3](https://user-images.githubusercontent.com/87962572/151790508-711c1ffd-c397-4031-be65-62e01a367e4c.PNG)

클라이언트 측 부하 분산 방식은 서비스 클라이언트가 호출할 때마다 서비스 디스커버리를 연결할 필요가 없도록 서비스 위치를 캐시한다.

1. 서비스 클라이언트가 서비스 호출해야 할 때 로컬 캐시에서 서비스 인스턴스 IP주소를 확인한다.
해당 서비스에서 서비스 인스턴스 간 부하를 분산한다.

2. 클라이언트가 캐시에서 찾은 서비스 IP주로를 사용하고, 찾지 못하면 서비스 디스커버리에서 검색한다.
3. 클라이언트 측 ㅐ시는 서비스 디스커버리 계층을 통해 주기적으로 업데이트한다.

<h3>4.2.2 스프링과 넷플릭스 유레카를 사용한 서비스 디스커버리</h3>

스프링 클라우드 프로젝트에서 이러한 설정은 대수롭지 않다.
우리는 스프링 클라우드와 넷플릭스의 유레카 서비스 디스커버리 엔진을 사용해 서비스 디스커버리 패턴을 구현하고, 
클라이언트 측 부하 분산을 위해 스프링 클라우드와 넷플릭스의 리본 라이브러리를 사용할것이다.

![4-4](https://user-images.githubusercontent.com/87962572/151791118-4e7f6b84-ca56-4918-8a74-3f7b95afed0d.PNG)

1. 서비스 인스턴스가 시작할 때 자기 IP 주로슬 유레카에 등록한다.
이 등록 과정에서 서비스 ID와 함께 각 서비스 인스턴스의 물리적 위치, 포트 번호를 유레카에 알려 준다.
2. 라이선싱 서비스가 조직 서비스를 호출할 때 리본을 사용해 조직 서비스들의 IP 주소가 로컬에 캐싱되었는지를 확인한다.
3. 주기적으로 넷플릭스 리본 라이브러리는 유레카 서비스를 핑해서 로컬 캐시의 서비스 위치를 새로고침한다.

조직 서비스의 새 인스턴스를 라이선싱 서비스가 로컬에서 볼 수 있고, 비정상 인스턴스는 로컬 캐시에서 제거된다.

<h3>4.3 스프링 유레카 서비스 구축</h3>
메이븐 pom.xml 파일에서 시작하자.

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://
www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://
maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>
 <groupId>com.thoughtmechanix</groupId>
 <artifactId>eurekasvr</artifactId>
 <version>0.0.1-SNAPSHOT</version>
 <packaging>jar</packaging>
 
 <name>Eureka Server</name>
 <description>Eureka Server demo project</description>
 
<!--Not showing the maven definitions for using Spring Cloud Parent-->
 <dependencies>
   <dependency>
   <groupId>org.springframework.cloud</groupId>
   <artifactId>spring-cloud-starter-eureka-server</artifactId> 
   </dependency>
 </dependencies>
Rest of pom.xml removed for conciseness
....
</project> 
```

유레카 서비스를 독립 실행 모드로 설정하는 데 필요한 구성으로 application.yml을 다음 코드처럼 설정해야 한다.

```
server:
 port: 8761     // 유레카 서버가 수신 대기할 포트
 
eureka:
 client: 
  registerWithEureka: false         // 유레카 서비스에 등록하지 않는다.
  fetchRegistry: false     // 레지스트리 정보를 로컬에 캐싱하지 않는다
 server:
  waitTimeInMsWhenSyncEmpty: 5    // 서버가 요청을 받기 전 대기할 초기 시간 
```

유레카 서비스를 구축하는 마지막 작업은 유레카 서비스를 시작하는 데 사용되는 애플리케이션 부트스트랩 클래스에 애너테이션을 추가하는 것이다.

```
@SpringBootApplication 
@EnableEurekaServer    // 스프링 서비스에서 유레카 서버 활성화
public class EurekaServerApplication {
 public static void main(String[] args) {
 SpringApplication.run(EurekaServerApplication.class, args);
 }
}
```

