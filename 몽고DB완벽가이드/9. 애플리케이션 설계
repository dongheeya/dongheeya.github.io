9. 애플리케이션 설계

9.1 스키마 설계 고려 사항
 - 데이터 표현의 핵심은 데이터가 도큐먼트에서 표현되는 방식인 스키마 설계다.
 * 가장 best방식은 애플리케이션에서 원하는 방식대로 데이터를 표현하는것이다!
 
 [스키마 설계를 할때 고려할 주요 요소.]
 1. 제약사항 : 하드웨어 제약사항을 이해해야된다. 도큐먼트의 최대 크기는 16메가 바이트이며, 전체 도큐먼트를 읽고 쓴다.
 갱신은 전체 도큐먼트를 다시 쓰며, 원자성 갱신은 도큐먼트 단위이다.
 
 2. 쿼리 및 쓰기의 접근 패턴 : 애플리케이션 및 더 넓은 시스템의 워크로드를 식별하고 정량화해야한다.
 여기서 워크로드는 애플리케이션의 일기과 쓰기를 모두 포함.
 쿼리가 실행되는 시기와 빈도를 알면  일반적인 쿼리를 식별 가능.
 쿼리를 식별 -> 쿼리 수 최소화 -> 함께 쿼리되는 경우에는 동일한 도큐먼트에 저장되도록 설계하면 좋음.
 반대로, 쿼리에 사용되지 않는 데이터라면 다른 컬렉션에 넣는 것이 좋음
 
 3. 관계 유형 : 애플리케이션 요구사항과 도큐먼트 간 관계 측면에서 어떤 데이터가 관련되어있는 지 고려해야함.
 그런 다음에는 데이터나 도큐먼트를 내장할 것인지 참조할 것인지를 선택
 쿼리하지 않고 도큐먼트를 참조해야되는 방법을 파악하는 것이 좋음
 관계가 변경될 시에 갱신되는 도큐먼트의 개수는 확인 필요.
 
 4. 카디널리티 : 도큐먼트와 데이터가 어떤 관계인지 확인하공 관계의 카디널리티를 고려해야한다.
 (1:1, 1:N, N:M) 그리고 일대 수백만인지 다대수십 억인지 고려하여 모델링에 최선의 형식을 사용해야한다.
 또한, 개별적으로 접근되는 것인지 아니면 상위 객체의 컨텍스트에서만 접근되는 지 고려해야한다.
 
 읽기 : 갱신의 비율을 고려하여 정규화 VS 비정규화를 결정
 
 9.1.1 스키마 설계 패턴
 몽고DB의 스키마 설계는 애플리케이션 성능에 직접 영향을 미친다.
 
 - 다형성 패턴 : 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 적합
 - 속성 패턴 : 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 잇는 경우, 정렬하려는 필드가 도큐먼트에 서브셋에만 있는 경우 또는 두 조건이 모두해당하는 경우에 적합
    데이터를 키/값 쌍의 배열로 재구성하여 인덱스를 만드는 작업을 포함한다. 이 패턴은 한정자를 부가 필드로 추가하여 도큐먼트 당 많은 유사한 필드를 대상으로 지정하기 때문에
    인덱스가 적어지고 쿼리 작성이 더 간단해진다.
 - 버킷 패턴 : 데이터가 일정 기간 동안 스 트림으로 유입되는 시계열 데이터에 적합. 
    특정 시간 범위의 데이터를 각각 보유하는 도큐먼트 셋으로 버킷화를하면 시간/데이터 포인트의 포인트당 도큐먼트를 만들때보다 효율적
 - 이상치 패턴 : 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어 날 때 적합. 인기도가 중요한 상황을 위해 설계
 - 계산된 패턴 : 데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 일기 집약적 일때 적합. 동일 계산의 반복을 줄이고, 계산없이 근사치를 제공
 - 서브셋 패턴 : 장비의 램 용량을 초과하는 작업 셋이 있을때 적합
  (ex. 자주 사용하는 데이터와 그렇지 않은 데이터를 두개의 개별 컬렉션으로 분할 -> 필요시에만 그렇지 않은 컬렉션을 조회한다.)
 - 확장된 참조 패턴 : 각각의 고유한 컬렉션이 있는 여러 논리 엔티티 또는 사물이 있고, 특정 기능을 위해 엔티티들을 모을때 사용
  (ex. 자주 접근하는 필드를 식별하고 주문 도큐먼트를 복제해서 주문을 보여줄 때에는 평소에 주문 도큐먼트만 보여주다가, 배송이 될 시에만 주문에 매핑된
  사용자의 데이터를 조합한다.)
 - 근사 패턴 : 리소스가 많이 드는 (시간, 메모리, CPU사이클) 계산이 필요하지만, 정확도가 반드시 필요하지는 않는 상황에 적합
  (ex. 조회수가 9999만 1234 여도 9999만까지만 근사치 적용해서 추천이나 조회수를 보여준다.)
 - 트리 패턴 : 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을때 적용. 일반적으로 쿼리되는 데이터를 한데 저장하는 방식을 따름.
  (ex. 하드 드라이브는 그 자체로 범주지만 기억장치 혹은 전자 제품 - 컴퓨터 부품이라는 범주에도 포함된다. ㅇ때, 전체 계층 구조 필드는 다중키 인덱스를
  사용하여 해당 범주와 직접 관련된 모든 항목을 검색할 수 있게 한다.)
  
 - 사전 할당 패턴: 빈 구조를 사전에 할당
 - 도큐먼트 버전 관리 패턴 : 도큐먼트의 이전 버전을 유지하는 매커니즘을 제공
 
9.2 정규화 vs 비정규화
 정규화? 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업
 각 데이터 조각은 여러 도큐먼트로 참조해야하지만 하나의 컬렉션에 들어있다.
 데이터를 변경시에는 한 도큐먼트만 갱신하면됨.
 (+) 쓰기를 빠르게 
 
 비정규화? 모든 데이터를 하나의 도큐먼트에 내장함 <-> 정규화
 여러 도큐먼트가 최종 데이터 사본에 참조를 갖는 대신 데이터 사본을 가짐.
 데이터 변경시에 여러 도큐먼트가 갱신되어야함.
 하나의 쿼리로 모든 데이터 가져올 수 있음.
 (+) 읽기를 빠르게.
 
 9.2.1 데이터 표현의 예제 
  학생(student)과 학생이 수강중인 과목(calsses)에 대한 정보를 저장한다. -> 학생과  과목 합침(studentClasses)
 > db.studentClasses.findOne({"studentId":id})
 {
  "_id" : OjbectId("1")
  , "studentId" : ObjectId("a")
  , "classes" : [
    ObjectId("과목1"),
    ObjectId("과목2"),
    ObjectId("과목3"),
    ObjectId("과목4")
  ] 
 }

이때 John Doe가 듣고있는 강좌의 이름을 알고싶다면,
  Student뒤져서 이름을 찾고 -> 그 id로 StudentClasses 찾아서 classes배열가지고 -> Classes의 강좌명 찾아야함. (3번)
이를 2번으로 줄이고 싶으면, 

{
  "_id" : OjbectId("1")
  , "name" : "John Doe" <- 아예 이름을 가지고 있으면  Student뒤져서 이름을 찾고(x) ->  StudentClasses 찾아서 classes배열가지고 -> Classes의 강좌명 찾아야함. (2번)
  , "classes" : [
    ObjectId("과목1"),
    ObjectId("과목2"),
    ObjectId("과목3"),
    ObjectId("과목4")
  ] 
 }
 
 이를 좀더 비정규화하게 된다면 다음과 같다.
 {
  "_id" : OjbectId("1")
  , "name" : "John Doe"
  , "classes" : [
     { "class":"Physics", "credits":3,"room":"159"}, {"class":"women in Literature", "credits":3,"room":"14b"},  .................. }
  ] 
 } 
 
 (+) class정보를 다 가지고 있으므로 한번에 데이터를 다 얻을 수 있다.
 (-) 공간을 많이 차지하고, 동기화가 어려움
 
 ex) 물리학의 학점이 3학점이 아니라 2학점이라면, 물리학을 공부하는 모든 학생의 도큐먼트를 갱신해야함.
 
 이를 앞에 언급한 내장과 참조를 혼합해 "확장 참조" 패턴을 사용하게 된다면,
 자주 사용하는 정보로 서브두큐먼트의 배열로 지정 & 추가적인 정보는 실제 도큐먼트를 참조하게함.
 
  {
  "_id" : OjbectId("1")
  , "name" : "John Doe"
  , "classes" : [
     { "_id":  ObjectId("과목1"), "class":"Physics"}, {"_id":  ObjectId("과목2"), "class":"women in Literature"},  .................. }
  ] 
 } ; 자주 조회하는 class명은 냅두고 나중에 필요시에만 해당 클래스의 학점 등을 검색할 수 있도록 _id를 추가함.
 (+) 한 페이지에 정보를 많거나 적게 포함하려면 도큐먼트 내 정보를 많거나 적게 내장하도록 하면된다.
 
 * 정보가 읽히는 빈도에 비해 얼마나 자주 변경되는 지 중요하게 고려해야함!
 정보가 갱신 빈도 ↑ > 정규화 
 갱신 빈도 ↓ > 비정규화 (하나의 도큐먼트에 내장)
 
 ex) 사용자와 주소 같은 경우, 사용자의 주소는 자주 바뀌지 않으므로 사용자 도큐먼트에 주소를 내장하는 것이 좋다(반정규화)
 
 만약에, 내장 도큐먼트를 사용하기로 결정하고 도큐먼트를 갱신해야되는 경우에는 cron 작업을 설정해야한다.
 
 - 계정 설정 : 해당 사용자 도큐먼트에만 관련 있으며 도큐먼트 내 다른 정보와 함께 노출되므로 계정설정은 일반적으로 내장.
 - 최근 활동 : 최근 활동의 증가량과 변화량에 따라 다르다. 크기가 만약에 고정되어 10개라면 내장하는 것이 유용.
 - 친구 : 일반적으로 내장 X, 완전히 내장하지 말아야한다. 
 - 사용자가 생성한 모든 내용 : 내장 X
 
 9.2.2 카디널리티 : 컬렉션이 다른 컬렉션을 얼마나 참조하고 잇는지를 나타내는 개념.
 어떤 데이터가 많은 지를 파악하는 것이 좋음.
 많고 적음의 관계를 결정하면 무엇을 내장하고 무엇을 내장할지 결정하는데 도움이 된다.
 적음 관계는 내장이 더 적합하며,
 많음 관계는 참조가 더 적합.
 
 9.2.3 친구, 팔로워 그리고 불편한 관계
 SNS에 대한 고려사항을 다루자.
 긴밀하게 연결된 정보를 내장할지 혹은 참조할지 적절히 결정하는데 까다롭다.
 
 구독을 구현하는 전형적인 방법3가지.
 ex1) 게시자를 구독자의 도큐먼트에 넣는 방법.
 {
  "_id" : ObjectId("a"), 
  "username":"batman",
  "email" : "batman@waynetech.com",
  "following" : [
    ObjectId("following1"),   --joker(ex2)
   ObjectId("following2")
 } ;  batman이라는 구독자가 여러명을 구독하고 있음.
 
 (-) 대신에 새로 게시된 활동에 관심있는 사람을 모두 찾으려면 모든 사용자에 걸쳐 following을 쿼리해야함
 
 ex2) 게시자 도큐먼트에 팔로워들을 추가 
 {
  "_id" : ObjectId("b"), 
  "username":"joker",
  "email" : "joker@mailinator.com",
  "followers" : [
    ObjectId("follower1"),   --batman
   ObjectId("follower2")
 } ; joker에게 새로운 게시물을 생길때 알람을 받아야되는 followers들.
 
 (+) joker가 새로운 알람을 보내야할 모든 사용자를 바로 알수있음.
 (-) 팔로우하는 사람을 찾으려면 users컬렉션 모두 다 뒤져야함(ex1와 반대상황)
 
 -> 두가지 모두 추가적인 단점이 있으며, 사용자의 도큐먼트는 더욱 크고 자주 바뀌게 된다!(정규화 필요)
 그리고 followers혹은 following들이 필요없는 경우가 많다. (자주 필요하지않음 ; 정규화하면 좋음)
 
 ex3) 정규화 (사용자와 followers를 나눔)
 {
  "_id" : ObjectId("b"), 
  "followers" : [
    ObjectId("follower1"),   --batman
   ObjectId("follower2")
 } ; 팔로워 정보를 얻어야된다면 추가 쿼리가 필요함.
 
 
 유명인 사용자로 인한 영향에 대처하기.
 - 어떤 전략을 사용하든 내장이 작동하는 서브도큐먼트와 참조의 수는 제한된다.
 - 유명인 사용자의 팔로워를 저장하는 방식은 도큐먼트를 넘칠 수 있음
 - '연속 도큐먼트'를 사용하여 이상치 패턴을 사용.
 
 9.3 데이터 조작을 위한 취적화
 - 애플리케이션을 최적화하기 위해서는 읽기와 쓰기 성능을 분석해 어느 것이 병목 현상을 일으키는지 우선적으로 알아야한다.
 - 읽기 최적화는 일반적으로 올바른 인덱스를 사용하여 하나의 도큐먼트에서 가능한 많은 정보를 반환하는 것과 관련있다.
 - 쓰기 최적화는 보통 갖고 있는 인덱스 개수를 최소화하고 갱신을 가능한 효율적으로 수행하는 것과 관련있다.
 - 빠른 쓰기에는 최적화된 스키마와 빠른 읽기에 최적화된 스키마 사이에는 종종 트레이드 오프가 존재하므로 -> 무엇이 더 중요한지 결정 필요!
 ex) 쓰기 1번에 읽기가 수천번 -> 읽기를 최적화하는 것이 좋음!
 
 9.3.1 오래된 데이터 제거
  - 어떤 데이터는 짧은 시간 동안만 중요.
  
  1) 제한 컬렉션 사용
   - 크기를 크게 설정하고 오래된 데이터를 끝으로 밀려나게 한다.
  2) TTL 컬렉션 사용 
   - 제거할 때 미세하게 조절할 수 있다.
   - 쓰기를 매우 많이 수행하는 컬렉션에서는 충분히 빠르지 않음
  3) 여러 컬렉션 사용
   - 한 달에 하나의 컬렉션을 사용하고 달이 바뀔 때마다 비어있는 달 컬렉션을 사용하고 현재와 이전달의 컬렉션에서 데이터를 찾기 시작한다.
   - 특정 시간보다 (ex.6개월) 오래되면 삭제할 수 있다.
   
 9.4 데이터베이스와 컬렉션 구상
  도큐먼트의 형태를 구상하고 나면, 어떤 컬렉션 또는 데이터베이스에 넣을지를 결정해야한다.
  일반적으로 스키마가 유사한 도큐먼트는 같은 컬렉션에 보관해야한다.
  
  컬렉션에서 락과 저장을 중요하게 고려해야한다.
  --directoryperdb옵션을 사용하면 데이터베이스는 각자의 디렉터리에 있으므로 서로 다른 데이터베이스를 다른 볼륨에 마운트할 수 있다.
  
  구성 요소를 중요도에 다라 3개의 데이터베이스(logs,activities,users)로 나눌 수 있다.
  -> 가장 중요한 뎅터가 가장 적은 데이터라는 장점이 있다.
  
 9.5 일관성 관리
  애플리케이션의 읽기에 필요한 일관성이 어느 정도인지 파악해야한다.
  이를 위해서는 몽고DB가 내부에서 무엇을 수행하는 지 이해가 필요.
  - 서버는 각 연결에 대한 요청 큐를 보관
  - 클라이언트가 요청을 보내면 요청은 연결 큐의 가장 마지막에 위치
  - 이전에 큐에 추가된 작업이 진행된 후에 발생
  - 항상 일관성을 가지며 자신의 쓰기를 항상 읽을 수 있다.
  
  셸이 2개 열면, 데이터베이스에 대한 연결이 2개가 된다.
  - 하나의 셸에서 삽입을 수행하면 이후에 다른 셸에서 발생하는 쿼리는 삽입된 도큐먼트를 반환하지 못한다.
  - 하지만, 단일 셸에서 삽입 작업 후에 쿼리하면 삽입된 도큐먼트가 반환된다.
  - 교차 삽입과 쿼리가 발생할 수 있고 이러한 현상은 한 스레드에서 데이터를 삽입한 후 다른 스레드에서 해당 삽입의 성공여부를 확인할때 일어나다.
  - 잠시 동안은 데이터가 삽입되지 않은 것처럼 보였다가 갑자기 데이터가 나타난다.
  
  이는 모두 커넥션 풀링을 사용하기 때문이다.
  드라이버의 효율성을 위하 서버에 대한 여러 연결을 열고 요청을 분산한다.
  하지만 일련의 요청이 하나의 연결에 의해 처리되도록 보장하는 매커니즘을 가진다.
  
 9.6 스키마 마이그레이션
  규모가 커지고 요구 사항이 변할수록 스키마 또는 커지고 변환해야한다.
  스키마를 애플리케이션의 요구에 맞춰 구조적으로 처리하는 방식은 각 도큐먼트에 version이라는 필드를 추가하는 것이다.
  애플리케이션이 도큐먼트 구조를 위해 무엇을 받아들일지 판단하는데 사용한다.
  
