[10. 복제 셋 설정]
 10.1 복제 소개
  - 복제 : 데이터의 동일한 복사본을 여러 서버상에서 보관하는 방법이며 실제 서비스를 배포할 때 권한한다.
  - 한대 또는 그 이상의 서버에 이상이 발생하더라도 복제는 애플리케이션이 정상적으로 동작하게 하고 데이터를 완전하게 보존한다.
  - 몽고 DB를 이용하면 복제 셋을 생성함으로써 복제할 수 있다.
  - 복제 셋은 클라이언트 요청을 처리하는 프라이머리 서버 한대와 프라이머리 데이터 복사본을 갖는 세컨더리 서버 여러 대로 이뤄진다.
  - 프라이머리 서버에 장애가 발생하면 세컨더리 서버는 자신들 중에서 새로운 프라이머리 서버를 선출 가능.
 
 10.2 복제 셋 절성 - 1장
  - 단일 장비에 3-노트 복제셋을 설정하는 방법을 보여준다.
  - 몽고 DB가 고가용성과 재해복구를 처리하는 방법을 이해할 수 있다.
  - 복제 셋을 설정하고 실행하기 위해 스크립팅한 후, mongo셸에서 관리 명령을 실행하거나 네트워크 파티션 또는 서버 오류를 시뮬레이션한다.
  - 복원력을 제공하려면 DNS Seedlist d연결 형식을 사용해 애플맄케이션 복제 셋에 연결한느 방법을 지정해야한다.
  
  - 테스트 복제 셋을 시작하기에 앞서 각 노드에 대해 별도의 데이터 디렉터리를 생성
  $mkdir -p ~/data/rs{1,2,3}
  > md c:/data/rs1 c:/data/rs2 c:/data/rs3
  
  그러면 ~/data/rs1, ~/data/rs2, ~/data/rs3 디렉터리가 생성된다.
  
  리눅스나 맥 os에서는 다음 명령을 각 별도의 터미널에서 실행한다.
  $monogod --replSet mdbDefGuide --dbpath ~data/rs1 --port 27017 \ --smaillfiles --oplogSize 200
  $monogod --replSet mdbDefGuide --dbpath ~data/rs2 --port 27017 \ --smaillfiles --oplogSize 200
  $monogod --replSet mdbDefGuide --dbpath ~data/rs3 --port 27017 \ --smaillfiles --oplogSize 200
  
 10.3 네트워크 고려 사항
  - 복제 셋의 모든 멤버는 같은 셋 내 다른 멤버와 연결할 수 잇어야한다.
  - 만약 이미 작동 중인 다른 멤버에 연결할 수 없다는 오류가 발생하면 연결이 이뤄지도록 네트워크 구성을 바꿔야한다.
  - 별도의 서버에서 쉽게 실행할 수 있다.
  - 몽고db 3.6이 출시되면서 mongod 는 기본적인 로컬호스트 127.0.0.1에만 바인딩 한다.
  - 복제 셋의 각 멤버가 다른 멤버와 통신하려면 다른 멤버가 연결할 수 잇는 ip 주소에도 바인딩해야한다.
  
  ex)  ip주소가 198.51.100.1인 네트워크 인터페이스가 있는 서버에서 monogod 인스턴스를 실행중이다.
  인스턴스를 각기 다른 서버의 멤버와 함께 봅제 셋의 멤버로 실행하려면, 명령행 매개변수 --bind_ip를 지정하거나 인스턴스 구성파일에 있는 bind_ip를 사용한다.
  
 10.4 보안 고려 사항.
  - localhost이외의 ip주소에 바인딩하기 전 복제 셋을 구성할 때, 권한 제어를 활성화하고 인증 메커니즘을 지정해야한다
  - 디스크의 데이터를 암호화하고 복제 셋 멤버 간 통신 및 셋과 클라이언트 간 통신을 암호화하면 좋다.
  
 10.5 복제 셋 설정 -2장
 - 지금가지 수행한 작업으로는 아직 각 mongod가 다른 mongod의 존재를 알지 못한다.
 - 네 번째 터미널에서 실행 중인 mongod 인스턴스 중 하나에 연결하는 mongo 셸을 시작한다.
 - 다른 명령을 입력해 수행할 수 있다.
 
 명령은 포트 27017에서 실행 중인 mongod에 연결한다.
 $ mongod --port 27017
 그런 다음 mongo셸에서 구성 도큐먼트를 만들고 rs.initiate()보조자에 전달해 복사 셋을 시작한다.
 >  rsconf = {
  _id : "mdbDefGuide",
  members : [
   {_id:0,host:"localhost:27017"},
   {_id:1,host:"localhost:27018"},
   {_id:2,host:"localhost:27019"}
  ]}
  rs.initate(rsconf)
  
  구성의 _id는 명령행에 전달한 복제 셋의 이름이다.
  도큐먼트의 다음 부분은 셋 멤버의 배열이다.
  각 멤버에는 2개의 필드 즉, _id와 호스트명이 필요하다
  _id는 정수이며 복제 셋 멤버 간에 고유해야한다.
  
  여기서는 셋 멤버의 호스트명으로 localhost를 사용하는데 
  몽고db에서는 로컬호스트 복제 셋을 로컬에서 테스트할 수 있지만, 구성에서 로컬 및 비로컬호스트 서버를 혼합하려고하면 문제가 생긴다.
  
  tip) 서버를 재시작하고 셋을 초기화하기 위한 다운타임없이는 복제셋으로 변환할 수 없다. 따라서 시작할 서버가 하나뿐이더라도
  단일 멤버 복제 셋으로 구성할 수 있다. 그러면 다운타임 없이 멤버를 더 추가할 수 있다.
  
  새로운 셋을 시작한다면 셋 내 어떤 멤버로든 구성을 보낼 수 있다.
  시작하고 나면 완전히 기능하는 복제 셋이 있어야한다. 
  복제 셋은 프라이머리를 선출해야한다. 복제 셋의 상태는 rs.status()를 사용해서 볼수 있는데 출력은 복제 셋에 대해
  꽤 많은 것을 알려준다.
  
  *rs 보조자 함수
  - rs는 보조자 함수를 포함하는 전역 변수다. 이 함수들은 거의 항상 데이터베이서 명령을 감싸는 래퍼다.
  보조자 대신 명령 양식을 사용하는 것이 더 쉬울 떄도 있으므로 보조자와 기본 명령 둘 다 익히면 좋다.
 
 10.6 복제 관찰
  - 복제 셋이 포트 27017에 있는 mongod를 프러이머리로 선출했다면, 복제 셋을 시작하는데 사용된 mongo셸이 현재 프라이머리에 연결돼있다.
  
  다음과 같이 프롬프트가 변경되어야한다.
  mdDefGuide:PRIMARY>
  
  이는 _id가 mdbDefGuide 인 복제 셋 프라이머리에 연결되었음을 뜻한다.
  
  복제 셋이 다른 노드를 프라이머리로 선출했다면, 셸을 종료하고 이전에 mongo셸을 시작할때 했던 것처럼 명령행에서 올바른 포트 번호를 지정해
  프라이머리 노드에 연결한다
  
  $mongo --port 27018
  
  셸을 종료하고 세컨더리의 포트 번호를 사용해 연결하면 작업을 수행할 수 있다.
  실행 중인 셸 내에서 Mongo생성자를 사용해 연결 객체를 인스턴스화 하면 세컨더리에 대한 연결을 쉽게 얻을 수 있다.
  
  먼저 프라이머리 테스트 데이터베이스에 대한 연결을 사용해 isMaster명령어 실행하고 
  rs.status()보다 훨씬 더 간결한 형태로 복제 셋의 상태를 보여준다.
  또한 애플리케이션 코드를 작성하거나 스트립팅할때 어느 멤버가 프라이머리인지 판별하는 편리한 방법이다.
  
  > db.isMater()
  
  어느 시점이든 선출이 호출되거 연결돼 있던 mongod가 세컨더리가 되면 isMaster명령을 사용해 어느 멤버가
  프라이머리가 됐는지 확인할 수 있다.
  용도에 따라 둘 중 하나를 사용할수 있음을 알려준다.
  localhost : 27019 에 대한 연결을 인스턴스화 해보자.
  
  > secondaryConn = new Mongo("localhost:27019");
  > secondaryDB = secondaryConn.getDB("test");
  
  이때 세컩더리로 복제된 컬렉션에 읽기를 시도하면 오류가 발생한다.
  > secondaryDB.coll.find()
  
  세컨더리는 프라이머리보다 뒤처지며 데이터가 최신이 아닐 수 있다.
  세컨더리는 애플리케이션이 실수로 실효 데이터를 읽지 않도록 기본적으로 읽기 요청을 거부한다.
  따라서 세컨더리를 쿼리하려고함녀 프라이머리가 아니라는 오류가 표시 된다.
  그래서 세컨더리에 대한 쿼리를 허용하려면 다음과 같은 '플래그'를 설정해야된다
  > secondaryConn.setSlaveOk()
  > secondaryDB.coll.find()
  
  slaveOk는 데이터베이스가 아니라 연결에 설정된다.
  모든 도큐면트가 있음을 확인할 수 있다.
  세컨더리에 쓰기를 해보자.
  
  > secondaryDB.coll.insert({"count":10001})
  이때 쓰기가 받아들여지지 않는다.
  세컨더리는 클라이언트가 아닌 복제를 통해 가져오는 쓰기만 수행한다.
  
  자동 장애 조치라는 흥미로은 기능도 시도해보자.
  프라이머리가 중단되면 세컨더리 중 하나가 자동으로 프라이머리로 선출된다.
  테스트하려면 프라이머리를 중지해보자.
  > db.adminCommand({"shutdowm":1})
  
  명령을 실행하면 연결된 멤버에서 실행중인 mongod가 종료되고 사용중인 셸의 연결이 끊어지게 된다.
  이는 문제가 되지 않으며 셸의 크래시를 야기하지 않는다.
  계속해서 세컨더리에서 isMaster를 실행해 어느 멤버가 프라이머리가 됐는지 확인해보자
  > secondaryDB.isMaster()
  
  프라이머리 서버가 27018로 전환됐다.
  실행할 때마다 다른 서버가 프라이머리가 될수 있다.
  프라이머리의 중단을 가장 먼저 발견한 세컨더리가 선출된다.
  
  [정리]
  - 클라이언트는 독립 실행형 서버에 보낼 수 있는 모든 작업을 프라이머리 서버에 보낼 수 있다.
  - 클라이언트는 세컨더리에 쓰기를 할 수 없다.
  - 기본적으로 클라이언트는 세컨더리로부터 읽을 수 없다. '세컨더리에서 일고 있음을 알고 있다'를 뜻하는 설정을 연결해
  명시적으로 설정하면 읽기를 활성화할 수 있다.
  
 10.7 복제 셋 구성 변경
  - 복제 셋 구성은 언제든지 변경할 수 있으며 멤버 추가, 삭제, 변경이 가능하다.
  새로운 멤버를 추가할 때는 rs.add를 사용한다.
  > rs.add("localhost:27020")
  
  멤버를 삭제할떄에는,
  > rs.remove("localhost:27020")
  
  재구성 성공 여부는 셸에서 rs.config()를 실행해 확인 할 수 있다.
  구성을 변경할 떄마다 version 필드값이 증가한다.
  필드는 1부터 시작한다.
  수정을 하려면 셸에서 구성 도큐먼트를 만들고 rs.reconfig를 호출한다.
  
 10.8 복제 셋 설계 방법
  - 복제 셋을 설계하기 전에 앞서 과반수 개념을 알아둬야한다.
  프라이머리를 선출하려면 멤버의 과반수 이상이 필요하고, 프라이머리는 과반수 이상이어야만 프라이머리 자격을 유지할 수 있다.
  과반수는 복제 셋의 구성에 따라 산정되므로 얼마나 많은 멤버가 다운되거나 사용할 수 없는 상태인지 중요하지 않다.
  
  예를들어 복제 셋이 멤버가 5이고, 그 중 세 개가 다운된다면 2개가 살아있다. 두 멤버는 복제 셋의 과반수에 미치지 않으므로 프라이머리를 선출할 수 없다.
  만약 둘 중 하나가 프라이머리였다면, 두 멤버가 과반수에 미치지 않는다는 것을 알자마자 프라이머리 자격을 내려놓ㄴ는다.
  몇 초 후 확인해보면 복제 셋은 두 개의 세컨더리와 세 개의 통신이 안되는 멤버로 구성된다.
  
  남은 두 멤버로는 왜 프라이머리를 선출할 수 없는지 의문이 생길 수 있다. 문제는 다른 세 멤버가 완전히 다운되지 않았을 가능성이 있다는 점이다.
  멤버가 아니라 네트워크가 다운되지 않았을 가능성이 있다는 점.
  멤버가 아니라 네트워크가 다운됐을 수도 있다. 
  이때 세 멤버는 복제 셋의 과반수에 미치므로 프라이머리를 선출한다.
  
  * 그림[10-2]처럼 하나으 ㅣ데이터 센터에 복제 셋의 과반수가 있는 구성, 프라이머리 데이터 센터가 있고, 그 안에 복제 셋의
  프라이머리를 위치시킬떄 적합한 설계다. 프라이머리 데이터 센터가 정상이면 프라이머리를 갖지만, 
  데이터 센터가 이용 불가능한 상태가 되면 세컨더리 데이터 센터는 새로운 프라이머리를 선출하지 못하게된다.
  
  * 각 데이터 센터 내 서버 개수가 동일하고, 또 다른 위치에 동점 상황을 판가름할 서버가 있는 경우, 
  일반적으로 양쪽 데이터 센터 내 서버에서 복제 셋의 과반수를 확인할 수 있으므로 두 데이터 센터의 선호도가 동일할 떄 적합한 설계이다.
  하지만 이때 각 서버는 세 개의 분리된 위치에 있어야한다.
  
  프라이머리를 하나 이상 갖도록 몽고 db가 지원한다면 모든 복잡성이 해결될 것이다.
  하지만 다중 마스터는 그 자체로 복잡성을 수반한다.
  프라이머리가 두 개가 되면 쓰기 충돌을 처리해야 할 수도 있다.
  
  따라서 단일 프라이머리만 지원한다.
  
 10.8.1 어떻게 선출하는가
  - 세컨더리가 프라이머리가 되지 못하면 다른 멤버들에 이를 알리고 자신을 프라이머리로 선출 할 것을 요청
  요청 받은 멤버는 다ㅁ음과 같은 항목을 토대로 검사를 수행
   - 요청받은 멤버가 프라이머리에 도달할 수 있는가?
   - 선출되고자 하는 멤버의 복제 데이터가 최신인가?
   - 대신 선출돼야 하는 우선순위가 더 높은 멤버가 없는가?
   
  - 복제 셋 멤버는 2초마다 서로 다른 하트미트를 보낸다. 10초 이내에 멤버가 하트비트가 반환하지 않으면 다른 멤버가 그 불량 멤버를
  접근할수 없음으로 표시한다.
  - 선출 알고리즘은 우선순위가 가장 높은 세컨더리가 선출을 호풀하도록 최선의 노력을 한다.
  - 멤버 우선순위는 선출 시기와 결과에 영향을 미친다.
  - 우선순위가 더 높은 세컨더리가 더 낮은 세컨더리보다 상대적으로 더 빨리 선출되며 이길 가능성도 더 높다.
  - 복제 셋 멤버들은 우선순우기ㅏ 가장 높은 멤ㅁ버가 프라이머리가 될떄 까지 계속해서 선출 호풀한다.
  - 어떤 멤버가 프라이머리로 선출되려면 복제 데이터가 최신이어야 한다.
  
 10.9 멤버 구성 옵션
  - 멤버들이 동일하게 구성이 되지 않기를 원할 떄도 있다. 특정 멤버가 우선적으로 프라이머리가 되게 하거나, 클라이언트가 보이지 않게 해 읽기 요청이 라이팅
  되지 않도록 할 수 있따.
  
  10.9.1 우선순위
   - 우선순위는 특정 멤버가 얼마나 프라이머리가 되기를 원하는지 나타내는 지표이다.
   - 0~100까지의 값으로 지정하고 default= 1이다.
   - priority를 0으로 지정하면 그 멤버는 절대 프라이머리가 될 수 없다.
   - 수동적 멤버라고 한다.
   
   우선순위가 높은 멤버는 언제가 프라이머리로 선출된다.
  
 10.9.2 숨겨진 멤버
  - 클라이언트는 숨겨진 멤버에 요청을 라우팅하지 않으며, 숨겨진 멤버는 복제 소스서 바랍직하지 않다.
  숨기고 싶다면, hidden:true필드를 구성해 추가해야한다.
  > var config = rs.config()
  > config.memvers[2].hidden = true
  > config.memvers[2].priority = 0
   
  - rs.config이나 rs.status에서 여전히 멤버를 보여주며 isMaster()에서만 멤버가 사라진다.
  
 
 10.9.3 아비터 선출
  - 2-멤버 복제 셋은 대부분 요구 사항에서 명확한 단점이 있다.
  - 소규모로 배포하는사람들은 데이터 복사본을 세개가 보관하기는 꺼린다.
  - 복사본은 2개면 충분하다고 판단하기 떄문
  
  이러한 배포에 대해 몽고 db는 프라이머리 선출에 참여한느 용도로만 쓰이는 아비터라는 특수한 멤버를 지원한다.
  아비터는 데이터를 가지지 않으며 클라이언트에 의해 사용도지 않는다
  오로지 2-멤버 복제 셋에서 과반수를 구성하는데 사용된다.
  * 일반적으로 아비터가 없는 배포가 바람직하다/
  - 아비터는 일반적으로 몽고db에 사용하는 서버보다 사양이 낮은 서버에서 경량화 프로세스로 실행 할 수 있다.
  
  >rs.addArb() 보조자를 이용하면 아비터를 복제 셋에 추가할 수 있다.
  
  마찬가지로 멤버 구성에 arbiterOnly옵션을 지정할 수 있다.
  
  
  
  
