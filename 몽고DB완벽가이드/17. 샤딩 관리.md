<h1>Chapter 17. 샤딩 관리</h1>

복사 셋과 마찬가지로 샤드 클러스터를 관리하는 여러 옵션들이 있다.<br/>
수동 관리는 하나의 옵션이다.<br/>
요즘은 다양한 클러스터 관리 (옵스 매니저, 클라우드 매니저, 아틀라스 서비스형 데이터베이스) 등 도구가 점점 보편화 되고있다.<br/>
이번 장에서는 샤드 클러스터를 수동으로 관리하는 방법을 다룬다.<br/>

<h2>현재 상태 확인</h2>
데이터의 위치, 샤드 구성, 클러스터 실행 작업을 조회할 수 있는 몇가지 보조자가 있다.<br/>

<h3>sh.status()를 사용해 요약 정보 얻기</h3>
sh.status()를 샤드, 데이터베이스, 샤딩된 컬렉션의 개요를 제공한다.<br/>
청크의 개수가 적다면 어느 청크가 어디에 위치하는지도 출력한다.<br/>
단순히 컬렉션의 샤드 키와 각 샤드가 갖는 청크 개수를 보고한다.<br/>

```
> sh.status() ▶ 청크가 여러 개면 각 청크를 출력하기보다는 청크 상태를 요약한다.
              ▶ config 데이터베이스에서 수집한 정보를 모두 보여준다.
              
> sh.status(true) ▶ 모든 청크를 보려면 true를 넣는다. true를 입력하면 상세한 정보를 출력한다.
```

<h3>구성 정보 확인하기</h3>
클러스터에 대한 모든 구성 정보는 구성 서버의 config 데이터베이스 내 컬렉션에 보관된다.<br/>
셸 보조자를 사용하면 구성 정보를 더 읽기 쉽게 볼 수 있다. 하지만, 클러스터에 대한 메타데이터를 조회하려면 언제든지 config 데이터베이스를 직접 쿼리할 수 있다.<br/>

```
> use config
```

일반적으로 config 데이터베이스에 들어 있는 데이터는 직접 수정하면 안된다.<br/>
무언가를 수정하고 나면 모든 mongos 서버를 재시작해야 변경 사항이 적용된다.<br/>

다음은 config 데이터베이스는 몇 가지 컬렉션이 있다.<br/>

<h3>config.shards</h3>

shards 컬렉션은 클러스터 내 모든 샤드를 추적한다.

```
> db.shards.find()
{
  "_id" : "shard01", // 복제 셋의 이름 -> 고유해야함.
  "host" : "shard01/localhost:27018,localhost:27019,localhost:27020",
  "state" : 1
}
{
  "_id" : "shard02",
  "host" : "shard02/localhost:27021,localhost:27022,localhost:27023",
  "state" : 1
}

{
  "_id" : "shard03",
  "host" : "shard03/localhost:27024,localhost:27025,localhost:27026",
  "state" : 1
}
```

여기에서 shard의 _id는 복제 셋의 이름에서 가져온다. 그러므로 클러스터 안에 있는 각 복제 셋의 이름은 고유해야한다.

<h3>config.databases</h3>
database 컬렉션은 클러스터가 알고 있는 모든 샤딩 및 비샤딩 데이터베이스를 추적한다.

```
> db.databases.find()
{ "_id" :"video",
"primary":"shard02", ☞ primary 는 데이터베이스의 홈베이스
"partitioned":true,  ☞ enableSharding이 데이터베이스에 실행된 적이 있으면 partitioned 는 true가 된다.
..........
}
```

<h3>config.collections</h3>

collections 컬렉션은 모든 샤딩된 컬렉션을 추적한다.

```
> db.collections.find().pretty()
{
"_id": "video.movies", ☞ 컬렉션의 네임스페이스
...
"key" : {              ☞  샤드키. 여기서는 "imdbId"에 해시된 샤드 키.
  "imdbId":"hashed"
  },
"unique" : false,      ☞ 샤드 키가 고유한 인덱스는 아님을 나타낸다. 기본적으로 샤드키는 고유하지 않다.
...
}
```

<h3>config.chunks</h3>

chunks 컬렉션은 모든 컬렉션 내 모든 청크의 기록을 보관한다.

```
> db.chunks.find().skip(1).limit(1).pretty()
{
  "_id":"video.movies-imdbId_MinKey", ☞ 청크의 고유 식별자. 일반적으로 네임스페이스, 샤드 키, 하우 청크 범위다.
  "lastmod" : Timestamp(2,0),         ☞ 청크 버전 관리를 추적한다.
  "lastmodEpoch" : ObjectId("5db........"),
  "ns" :"video.movies",               ☞ 청크가 위치한 컬렉션
  "min":{
    "imdbid" : {"$minKey":1}          ☞ 청크 범위(경계포함) 내 최솟값
  },
  "max":{
    "imdbid" : {NumberLong("-72........") ☞ 청크 내 모든 값은 이 값보다 작다.
  },
  "shard" :"shard01",                 ☞ 청크가 위치한 샤드
  ... 
}
```

"lastmod"필드는 청크 버전 관리를 추적한다. <br/>
예를 들어, "video.movies-imdbId_MinKey" 청크가 두 개의 청크로 분할됐다면, 이전의 단일 청크와 분할돼서 작아진 "video.movies-imdbId_MinKey" 청크를 구별하는 방법이 필요하다.<br/>
따라서 Timestamp 값의 첫 번째 구성 요소는 청크가 새 샤드로 마이그레이션된 횟수를 반영한다.<br/>
두번째 구성 요소는 분할 수를 반영한다.<br/>
"lastmodEpoch" 필드는 컬렉션의 생성 시기를 지정하며, 컬렉션이 삭제되고 즉시 재생성될 때 동일한 컬렉션 이름에 대한 요청을 구별하는 데 사용된다.<br/>

<h3>config.changelog</h3>

changelog 컬렉션은 발생한 분할과 마이그레이션을 모두 기록하므로 클러스터가 무엇을 하고 있는지 추적하는데 유용하다.

1) 분할
```
> db.changelog.find({what:"split"}).pretty()
{
....
"detail" : {
    "before" : {
      ...
      "lastmod":Timestamp(9,1),
      "lastmodEpoch":Objectid("5bdf72c021b6e...")
    },
    "left" : {
      ...
      "lastmod":Timestamp(9,2),
      "lastmodEpoch":Objectid("5bdf72c021b6e...")    
    },
    "right" : {
      ...
      "lastmod":Timestamp(9,3),
      "lastmodEpoch":Objectid("5bdf72c021b6e...")    
    }
  }

}
```

각각의 새 청크에서 "lastmod"의 두번째 구성 요소가 갱신됐고, 값은 각각 Timestamp(9,2)와 Timestamp(9,3)이다.

마이그레이션은 더 복잡하며, 실제로 네 개로 나뉜 체인지로그 도큐먼트가 생긴다.<br/>
하나는 마이그레이션의 시작을 명시하고, 하나는 '원본' 샤드, 하나는 '목적지' 샤드, 나머지 하나는 마이그레이션에 대한 '커밋 정보'를 포함한다.<br/>
'원본'샤드와 '목적지'샤드에 대한 도큐먼트는 프로세스에서 단계별로 소요된 시간의 명세를 제공한다.<br/>
이를 통해 마이그레이션에서 병목 현상을 일으키는 원인이 디스크인지, 네트워크 혹은 다른 무언가인지 추정할 수 있다.<br/>

<b>예를 들어 '원본' 샤드에 의해 생성된 도큐먼트는 다음과 같다.</b>

```
> db.changelog.findOne({what:"moveChunk.to"}) // 원본 샤드에서 생성된 도큐먼트
{
  ...
  "what":"moveChunk.to",
  "ns" : "video.movies", //위치
  ...
  "detail" : {
  ...
    "step 1 of 6" : 965,
    "step 2 of 6" : 608,
    "step 2 of 6" : 15424,
    "step 4 of 6" : 0,
    "step 5 of 6" : 72,
    "step 6 of 6" : 258,
    "note":"success"
    }
}
```

"detail"에 나열된 각 단계에서 시간이 기록되며 "stepN of N"메세지는 단계의 소요 시간을 밀리초 단위로 보여준다.

'원본'샤드가 mongos로부터 moveChunk 명령을 받으면 다음과 같은 작업을 수행한다.<br/>
1. 명령 매개변수를 확인한다.<br/>
2. 구성 서버가 마이그레이션을 위해 분산된 락을 획득할 수 있는지 확인한다.<br/>
3. '목적지' 샤드에 접속을 시도한다.<br/>
4. 데이터를 복사한다. 이는 'the critical section'으로 명시돼 기록된다.<br/>
5. '목적지' 샤드 및 구성 서버와 조정해 이동을 확정한다.<br/>

'목적지'와 '원본'샤드는 "step 4 of 6"부터는 서로 통신이 가능한 상태여야 한다.<br/>
마지막 단계에서 원본 서버의 네트워크 연결이 비정상적이라면, 마이그레이션을 되돌리거나 계속 진행할 수 없는 상태가 된다.<br/>
이럴 때 mongod가 종료된다.<br/>

<b>'목적지' 샤드의 changelog 도큐먼트는 '원본' 샤드의 changelog 도큐먼트와 비슷하지만 단계가 약간 다르다.</b>

```
> db.changelog.find({what:"moveChunk.from","details.max.imdbId": .....).pretty()
{
  ...
  "what":"moveChunk.from",
  "ns":"video.movies",
  "detail" : {
  ...
    "step 1 of 6" : 0,
    "step 2 of 6" : 4,
    "step 2 of 6" : 191,
    "step 4 of 6" : 17000,
    "step 5 of 6" : 341,
    "step 6 of 6" : 39,
    "to:"shard01"
    "from":"shard02",
    "note":"success"
  }

}
```

'목적지' 샤드가 '원본'샤드로부터 명령을 받으면 다음 작업을 수행한다.<br/>
1. 인덱스를 마이그레이션한다. <br/>
2. 청크 범위 안에 있는 모든 데이터를 삭제한다.<br/>
3. 청크 내 모든 도큐먼트를 '목적지' 샤드로 복사한다.<br/>
4. 복사하는 동안에 도큐먼트에 일어난 작업을 재실행한다.<br/>
5. '목적지' 샤드가 새로 마이그레이션된 데이터를 대부분의 서버로 복제하도록 기다린다.<br/>
6. 청크의 메타데이터가 '목적지' 샤드에 위치한다고 바꿔서 마이그레이션을 확정한다.<br/>

<h3>config.settings</h3>
현재의 밸런서 설정과 청크 크기를 나타내는 도큐먼트를 포함한다.<br/>
컬렉션 내 도큐먼트를 변경해서 밸런서를 켜고 끄거나 청크 크기를 변경할 수 있다.<br/>
컬렉션 안의 값을 변경할 때 구성 서버에 직접 연결하지 말고 항상 mongos에 연결해야함을 명시하자.<br/>

<h2>네트워크 연결 추적</h2>
<h3>연결 통계 정보 얻어오기</h3>

connPoolStats 명령은 현재 데이터베이스 인스턴스에서 샤드 클러스터나 복제 셋의 다른 멤버로 나가는 열린 연결에 대한 정보를 반환한다.<br/>
connPoolStats는 실행 중인 작업과 간섭을 피하려고 락을 사용하지 않는다.<br/>
따라서 connPoolStats가 정보를 수집할 때 개수가 약간 바뀌어, 호스트와 풀 연결 개수 간에 약간의 차이가 생길 수 있다.<br/>

```
> db.adminCommnad({"connPoolStats":1})
{
  "numClientConnections" : 10,  ☞ 인스턴스에서 샤드 클러스터나 복제 셋의 다른 구성원으로 나가는 활성 및 저장된 동기 연결 수.     
  "numAScopedConnections": 0,   ☞ 인스턴스에서 샤드 클러스터나 복제 셋으 다른 구성원으로 나가는 활성 및 저장된 범위 동기 연결 수,
  "totalInUse": 0,              ☞ 인스턴스에서 현재 사용 중인 샤드 클러스터나 복제 셋의 다른 구성원으로 나가는 총 연결 수.
  "totalAvailable" : 13,        ☞ 샤드 클러스터나 복제 셋의 다른 구성원으로 나가는 사용 가능한 총 발신 연결 수를 나타낸다.
  "totalCreated": 86,           ☞ 샤드 클러스터나 복제 셋의 다른 구성원으로 생성한 총 발신 연결 수를 나타낸다.
  "totalRefreshing": 0,         ☞ 인스터스에서 현재 새로 새로고침되는 샤드 클러스터나 복제셋의 다른 구성원으로 나가는 총 발신 연결 수.
  "pools" : {
    ........
    "localhost:27017" : {
      "inUse" : 0,             ☞ 호스트 단위의 사용중
      "available:1,            ☞ 호스트 단위의 사용 가능
      "created":1,             ☞ 호스트 단위의 생성됨
      "refreshing":0           ☞ 호스트 단위의 새로고침
    }
    ...........
}
```

<h3>연결 개수 제한하기</h3>
클라이언트가 mongos에 접속하면 mongos는 클라이언트의 요청을 전달하려고 적어도 하나의 샤드에 연결을 생성한다.  <br/>
따라서 mongos에 들어온 각 클라이언트 연결은 mongos에서 샤드로 나가는 연결을 적어도 한 개는 만든다.<br/>





