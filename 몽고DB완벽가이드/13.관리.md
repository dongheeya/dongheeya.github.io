<h1>Chapter13.관리</h1>
<h2>13.1 독립 실행형 모드에서 멤버 시작</h2>
많은 유지보수 작업은 세컨더리에서 수행될 수 없으며, 애플리케이션 성능에 영향을 미치기 때문에 프라이머리에서 수행되면 안된다.<BR/>
그래서 다음 절에서는 독립 실행형 모드 서버 시작을 자주 언급한다.<BR/>

독립 실행형 모드에서 시작하려면 (1) 명령행 인수를 확인해야된다.<BR/>

```
> db.serverCmdLineOpts()
{
  "argv" : [ "mongod","-f","/var/lib/mongod.conf"],
  "parsed":{
        "replSet":"mySet",
        "port":"27017",
        "dbpath":"/var/lib/db"
        },
  "ok" : 1
}
```
이 서버에서 유지보수를 수행하려면 replSet 옵션 없이 서버를 재시작하면된다.<BR/>
일반적인 독립 실행형 mongod처럼 읽기와 쓰기가 가능하게 해준다.<BR/>
복제 셋에 있는 다른 서버에서 이 서버와 토인하기를 원치 않으므로 서버가 다른 포트로 수신하게 된다.<BR/>
마지막으로 서버 데이터를 조작하려고 이런 방식으로 시작하므로 dbpath는 그대로 유지한다.<BR/>

1) 먼저 mongo 셸에서 서버를 종료한다.
```
> db.shutdownServer()
```
2) replSet 매개변수 없이 다른 포트에서 mongod를 시작한다
```
$ mongod --port 30000 --dbpath /var/lib/db
```

독립 실행형 서버로 구동되며 연결을 위한 포트는 30000번이다.<BR/>
복제 셋의 다른 멤버는 27017번 포트로 이 서버에 접속을 시도하고, 곧 서버가 다운됐다고 추정하게 된다.<BR/>

서버에서 유지보수 수행을 마치면, 서버를 종료하고 원래 옵션으로 재시작할 수 있다.<BR/>

<h2>13.2 복제 셋 구성</h2>
복제셋 구성은 항상 local.system.replset 컬렉션의 도큐먼트에 보관된다.<BR/>
이 도큐먼트는 복제 셋의 모든 멤버에서 같다.<BR/>
절대 update를 이용해 도큐먼트를 변경하지 말자.<BR/>
대신 항상 rs보조자나 replSetReconfig 명령을 사용하자<BR/>

<h3>13.2.1 복제 셋 설정하기</h3>
멤버로 만들 mongod 들을 시작하고 그 중 하나에 rs.initiate()를 사용해 구성 정보를 전달함으로써 복제셋을 생성한다.<BR/>
복제셋의 한 멤버에서만 rs.initiate를 호출할 수 있으며, 항상 config 객체를 rs.initiate에 전달해야한다.<BR/>

<h3>13.3.2 복제 셋 멤버 교체하기</h3>
복제 셋에 새로운 멤버를 추라할 때는 데이터 디렉터리에 아무것도 존재하지 않거나 다른 멤버 데이터 복제본이 있어야한다.<BR/>
프라이머리에 연결하고 다음처럼 새로운 멤버를 추가하자.<BR/>

```
>rs.add("spock:27017")
```
더 복잡한 멤버 구성을 도큐먼트 형태로 명시한다.<BR/>
```
>rs.add({"host":"spock:27017","priority":0, "hidden":true})
```
host필드를 이용해서 멤버를 제거할 수도 있다.
```
>rs.remove("spock:27017")
```

재구성을 통해 멤버의 설정을 바꿀 수 있다.<BR/>
멤버의 설정을 바구는 데는 다음과 같은 제약사항이 있다.<BR/>
- 멤버의 "_id"는 변경할 수 없다.<BR/>
- 재구성 정보를 전달하려는 멤버(일반적으로 프라이머리)의 우선순위를 0으로 할 수 없다.<BR/>
- 아비터에서 아비터가 아닌 것으로 변경할 수 없으며, 반대도 마찬가지다.<BR/>
- 멤버의 "buildIndexes"를 false에서 true로 변경할 수 없다.<BR/>

멤버의 "host"필드는 변경할 수 있다.<BR/>
따라서 만약 호스트 정보를 잘못 명시했다면 나중에 간단히 구성을 변경해 올바른 IP로 정정할 수 있다.<BR/>

호스트명을 변경하려면 다음과 같이 하면된다.<BR/>
```
> var config = rs.config()
> config.members[0].host = "spock:27017"
> rs.reconfig(config)
```

<h3>13.2.3 큰 복제 셋 만들기</h3>
복제 셋에서 멤버는 50개 투표 멤버는 7개로 제한된다.<BR/>
다른 멤버에 하트비트를 보내는 데 필요한 네트워크 트래픽량을 줄이고 선출에 걸리는 시간을 제한하기 위함이다.<BR/>

멤버가 7개 이상인 복제 셋을 생성한다면, 모든 추가적인 멤버는 투표권이 0개여야한다.<BR/>
이를 수행하려면 멤버 구성 정보에 다음처럼 명시한다.<BR/>
```
> rs.add({"_id":7, "host":"server-7:27017","votes":0})
```
이는 해당 멤버들이 선출 과정에서 투표권을 행사하는 것을 방지한다.<BR/>

<h3>13.2.4 재구성 강제하기</h3>
복제 셋의 과반수를 영구적으로 잃으면, 프라이머리가 없는 상태에서 설정을 재구성할 필요가 있다.<BR/>
일반적으로 재구성을 프라이머리에 요청하기 떄문이다.<BR/>
셸에서 세컨더리에 연결하고 "force"옵션을 이용해 재구성 명령을 전달한다.<BR/>
```
> rs.reconfig(config, {"force":true})
```
강제 재구성은 일반 재구성과 같은 규칙을 따르며, 사용자는 유효하고 잘 구성된 구성 정보를 올바른 옵션으로 보내야한다.<BR/>
"force"옵션은 유효하지 않은 구성 정보를 허용하지 않고, 다만 세컨더리가 재구성 정보를 받아들이도록 허용한다.<BR/>

강제 재구성은 복제 셋 'version"번호를 크게 높인다.<BR/>
세컨더리는 재구성 정보를 받으면 자신의 구성 정보를 갱신하고 새로운 구성정보를 다른 멤버에 전달한다.<BR/>
재구성 정보가 네트워크 파티션 양쪽에 있을 때 버전 번호가 충돌하지 않도록 하기 위함이다.<BR/>

세컨더리는 재구성 정보를 받으면 자신의 구성 정보를 갱신하고 새로운 구성정보를 다른 멤버에 전달한다.<BR/>
모든 멤버가 새로운 호스트명을 가지면 복제 셋의 각 멤버를 다운시키고, 새로운 멤버를 독립 실행형 모드로 시작한 뒤, <BR/>
local.system.replset 도뮤컨트를 수동으로 변경하고 멤버를 재시작한다.<BR/>

<h2>13.3 멤버 상태 조작</h2>

유지보수를 수행할 떄나 부하에 대한 응답으로 수동으로 멤버 상태를 변경하는 방법은 여러가지다.<BR/>
복제 셋을 상황에 맞게 구성하는 것 외에는 방법이 없다.<BR/>

<h3>13.3.1 프라이머리에서 세컨더리로 변경하기</h3>
stepDown 함수를 이용하면 프라이머리를 세컨더리로 강등할 수 있다.
```
> rs.stepDown()
```
프라이머리를 60초 동안 SECONDARY 상태로 만든다.<BR/>
그 기간동안에는 다른 프라이머리가 선출되지 않으면 세컨더리 상태로 변했던 프라이머리는 재선출을 시도할 수 있다.<BR/>

<h3>13.3.2 선출 방지하기</h3>
프라이머리상에서 유지보수 작업을 수행해야 하고, 그 사이에 자격이 있는 다른 멤버가 프라이머리가 되지 않도록 하려면,<BR/>
각각의 멤버에 freeze명령을 실행함으로써 세컨더리 상태에 머물게 한다.<BR/>

```
> rs.freeze(10000)
```

<h2> 13.4 복제 모니터링</h2>
복제 셋의 상태를 모니터링하는 것이 중요하다.<BR/>
모든 멤버가 정상적으로 기동했는지, 멤버가 어떤 상태인지, 복제가 얼마나 최신 상태인지 모니터링한다<BR/>

<h3>13.4.1 상태 정보 가져오기</h3>
복제 셋의 모든 멤버의 정보를 얻는 데 가장 유용한 명령은 replSetGetStatus다.<BR/>
```
>rs.status()
```
1) self : rs.status()가 실행된 멤버에만 존재한다
2) stateStr : 서버의 상태를 나타내는 문자열이다.
3) uptime : 멤버에 도달할 수 있었던 시간 혹은 이 서버가 self멤버를 위해 시작된 이후부터의 시간이다.
4) optimeDate : 각 멤버의 oplog에서 마지막 연산 수행 시각을 의미한다.
5) lastHearBeat : 서버가 self멤버로부터 마지막으로 하트비트를 받는 시간
6) pingMs : 이 서버에 대한 하트비트에 걸린 평균 실행 시간
7) errmsg : 멤버가 하트비트 요청에 반환하기로 선택한 모든 상태 메세지

<h3>13.4.3 복제 루프</h3>
모든 멤버가 다른 멤버로부터 복제를 수행하는 상태이다,
모든 복제 루프 멤버는 프라이머리가 될 수 없으므로, 멤버들은 복제를 위한 새로운 명령을 받을 수 없고, 뒤처지게 된다.
멤버가 동기화할 멤버를 자동으로 고를 때는 복제 루프가 발생하지 않는다


<h3>13.4.4 복제 사슬 비활성화하기</h3>
- 복제 사슬은 세컨더리가 또 다른 세컨더리와 동기화할때 발생한다.
- "chainingAllowed"설정을 false로 변경해 모든 멤버가 동기화히게 함으로써 복제 사슬을 사용하지 않도록 설정할 수 있다.
- "chainingAllowed"설정을 false로 변경하면 모든 멤버는 프라미어리와 동기화한다. 프라이머리가 이용 불가능한 상태가 되면 세컨더리와 동기화하게 된다.

<h3>13.4.5 지연 계산하기</h3>
복제를 추적하는 지표로, 세컨더리가 얼마나 프라이머리를 잘 따라잡는지가 중요하다.
지연은 세컨더리가 얼마나 뒤처져있는지 나타내는데, 프라이머리가 마지막으로 수행한 연산과 세컨더리가
마지막으로 적용한 연산 타임스탬프의 차이를 의미한다.

로그 길이는 적어도 전체적으로 재동기화하는 데 걸리는 시간만큼 길면 좋다.
초기 동기화를 완료하기 전에 세컨더리가 oplog의 긑에서 밀려나는 상황은 생기지 않는다.

```
>rs.pringSlaveReplicationInfo();

```
프라이머리를 기준으로 상대적으로 계산된다는 점을 기억하자.
해당 함수를 사용해 각 멤버의 syncedTo값과 마지막 oplog항목이 각 세컨더리에 기록된 시간을 가져올 수 있다.

<h3>13.4.6 Oplog 크기 변경하기</h3>
oplog는 유지보수 시간으로 여겨진다.
잘못된 부분을 고칠 수 잇는 시간이 하시간 정보라는 의미이다.
아쉽게도 oplog가 얼마나 지속될지는 가득 차기전까지 쉽게 알 수 없다.

와이어드타이거 스토리지 엔젠을 사용하면 서버가 실행되는 동안 oplog크기를 조정할 수 있다.
oplog의 크기를 늘릴려면 다음 단계를 수행한다.
1. 복제 셋 멤버에 연결한다. 인증이 활성화됐다면 local 데이터베이스를 수정할 권한이 있는 사용자를 사용해야한다.
2. oplog의 현재 크기를 확인한다.

```
> use local
> db.oplog.rs.stats(1024*1024).maxSize
```
3. 복제 셋 멤버의 oplog크기를 변경한다
```
> db.adminCommand({replSetResizeOplog : 1, size: 160000})
```
4. 마지막으로 oplog의 크기를 줄였다면 compact를 실행해 할당된 디스크 공간을 회수해야할 수도 있다.

<h3>13.4.7 인덱스 구축하기</h3>
프라이머리는 정상적으로 인덱스를 구축하며, 세컨더리는 build index연산을 복제할 때 인덱스를 구축한다.
애플리케이션에 대한 영향을 최고화하려면 인덱스는 한 번에 한 멤버씩 구축하는 것이 바람직하다.
```
1. 세컨더리를 종료한다.
2. 종료한 ㅅ컨더리를 독립 실행형 서버로 시작한다
3. 재시작한 서버에 인덱스를 추가한다.
4. 인덱스 구축이 완료되면 서버를 복제 셋 멤버로 재시작한다.
5. 복제 셋의 각 세컨더리에 1~4단계까지 반복한다.
```

여기까지 하면 프라미어리를 제외한 모든 멤버의 인덱스가 추가된다.
그런 다음 두가지 선택지 중, 실제 시스템에 가장 적게 영향을 미치는 방법을 선택해야한다.

```
1. 프라이머리에 인덱스를 구축한다. 트래픽이 적을 때 'off'시간을 가질 수 있다면 이때 구축하면 좋다.
프라이머리는 인덱스 구축을 세컨더리에 복제하지만, 세컨더리는 이미 인덱스가 있으므로 어떤 연산 작업도 발생하지 않는다.
2. 프라이머리를 강등한 후 앞에서 설명한 2~4단계를 거친다. 이 방식에는 장애 조치가 필요하지만 기존 프라이머리가 인덱스를 구축하는 동안 정상적으로 작동하는 프라이머리가 있다.
인덱스 구축이 완료된 후 기존 프라이머리를 복제 셋에 재도입할 수 있다.
```
이 방법으로 세컨더리에서 다른 복제 셋 멤버의 인덱스와 다른 인덱스를 구축할 우도 있다.
인덱스가 다른 멤버는 절대 프라이머리가 될 수 없으며 우선순위가 항상 0임을 기억하자.

<h3>13.4.8 한정된 예산에서 복제하기</h3>
고성능 서버를 두 개 이상 구하기 어렵다면, 적은 램과 cpu, 속도가 느린 디스크 입출력을 갖는 재해 복구용 세컨더리 서버를 고려해보자.
좋은 서버는 항상 프라이머로 쓰고, 상대적으로 값싼 서버는 절대 클라이언트 트래픽을 처리하지 않게 한다.

다음은 값싼 서버를 설정하기 위한 옵션이다.
1. priority : 0 ☜ 해당 서버가 절대 프라이머가 되지 않도록 설정한다.
2. hidden:true ☜ 클라이언트가 해당 세컨더리에 읽기 요청을 절대 보내지 않도록 설정한다.
3. buildIndexes :false ☜ 이는 선택적이지만, 해당 서버가 처리해야하는 부하를 상당히 줄일 수 있다.
4. votes : 0 ☜ 서버가 두 개 뿐이라면 세컨더리의 votes를 0으로 설정해서 해당 서버가 다운되더라도 프라이머리가 프라이머리로 유지되도록 한다.

이러한 세컨더리가 이씨으면 두 개의 고성능 서버 없이도 안정성과 보안성을 얻을 수 있다.<BR/>
